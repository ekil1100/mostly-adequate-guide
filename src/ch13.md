# 第 13 章：幺半群将它们组合在一起

##百搭组合

在本章中，我们将通过*半群* 来研究*幺半群*。 * Monoids* 是数学抽象头发中的泡泡糖。他们捕捉到一个跨越多个学科的想法，形象地和字面地将它们整合在一起。它们是连接所有计算的不祥之力。我们代码库中的氧气，它运行的地面，量子纠缠编码。

*Monoids* 是关于组合的。但什么是组合？它可以意味着很多事情，从累积到串联，再到乘法，再到选择、组合、排序，甚至评估！我们会在这里看到很多例子，但我们只会在幺半群山的山脚下踮起脚尖。实例丰富，应用广泛。本章的目的是提供一个很好的直觉，这样你就可以制作一些你自己的 *monoids*。

## 抽象加法

加法有一些我想讨论的有趣品质。让我们通过我们的抽象护目镜来看看它。

对于初学者来说，它是一个二元运算，也就是说，一个取两个值并返回一个值的运算，它们都在同一个集合中。

```js
// a binary operation
1 + 1 = 2
```

See? Two values in the domain, one value in the codomain, all the same set - numbers, as it were. Some might say numbers are "closed under addition", meaning the type won't ever change no matter which ones get tossed into the mix. That means we can chain the operation since the result is always another number:

```js
// we can run this on any amount of numbers
1 + 7 + 5 + 4 + ...
```

除此之外（多么巧妙的双关语......），我们有关联性，这使我们能够根据需要对操作进行分组。顺便说一下，关联的二元运算是并行计算的一个秘诀，因为我们可以分块和分配工作。

```js
// associativity
(1 + 2) + 3 = 6
1 + (2 + 3) = 6
```

Now, don't go confusing this with commutativity which allows us to rearrange the order. While that holds for addition, we're not particularly interested in that property at the moment - too specific for our abstraction needs.

Come to think of it, what properties should be in our abstract superclass anyways? What traits are specific to addition and what ones can be generalized? Are there other abstractions amidst this hierarchy or is it all one chunk? It's this kind of thinking that our mathematical forefathers applied when conceiving the interfaces in abstract algebra.

As it happens, those old school abstractionists landed on the concept of a *group* when abstracting addition. A *group* has all the bells and whistles including the concept of negative numbers. Here, we're only interested in that associative binary operator so we'll choose the less specific interface *Semigroup*. A *Semigroup* is a type with a `concat` method which acts as our associative binary operator.

Let's implement it for addition and call it `Sum`:

```js
const Sum = x => ({
  x,
  concat: other => Sum(x + other.x)
})
```

请注意，我们将“concat”与其他一些“Sum”结合在一起，并始终返回“Sum”。

我在这里使用了对象工厂而不是我们典型的原型仪式，主要是因为 `Sum` 不是 *pointed* 并且我们不想输入 `new`。无论如何，这是在行动：

```js
Sum(1).concat(Sum(3)) // Sum(4)
Sum(4).concat(Sum(37)) // Sum(41)
```

Just like that, we can program to an interface, not an implementation. Since this interface comes from group theory it has centuries of literature backing it up. Free docs!

Now, as mentioned, `Sum` is not *pointed*, nor a *functor*. As an exercise, go back and check the laws to see why. Okay, I'll just tell you: it can only hold a number, so `map` does not make sense here as we cannot transform the underlying value to another type. That would be a very limited `map` indeed!

So why is this useful? Well, as with any interface, we can swap out our instance to achieve different results:

```js
const Product = x => ({ x, concat: other => Product(x * other.x) })

const Min = x => ({ x, concat: other => Min(x < other.x ? x : other.x) })

const Max = x => ({ x, concat: other => Max(x > other.x ? x : other.x) })
```

This isn't limited to numbers, though. Let's see some other types:

```js
const Any = x => ({ x, concat: other => Any(x || other.x) })
const All = x => ({ x, concat: other => All(x && other.x) })

Any(false).concat(Any(true)) // Any(true)
Any(false).concat(Any(false)) // Any(false)

All(false).concat(All(true)) // All(false)
All(true).concat(All(true)) // All(true)

[1,2].concat([3,4]) // [1,2,3,4]

"奇迹成长".concat("n") // 奇迹成长"

Map({day: 'night'}).concat(Map({white: 'nikes'})) // Map({day: 'night', white: 'nikes'})
```

If you stare at these long enough the pattern will pop out at you like a magic eye poster. It's everywhere. We're merging data structures, combining logic, building strings...it seems one can bludgeon almost any task into this combination based interface.

I've used `Map` a few times now. Pardon me if you two weren't properly introduced. `Map` simply wraps `Object` so we can embellish it with some extra methods without altering the fabric of the universe.


## All my favourite functors are semigroups.

The types we've seen so far which implement the functor interface all implement semigroup one as well. Let's look at `Identity` (the artist previously known as Container):

```js
Identity.prototype.concat = function(other) {
  return new Identity(this.__value.concat(other.__value))
}

Identity.of(Sum(4)).concat(Identity.of(Sum(1))) // Identity(Sum(5))
Identity.of(4).concat(Identity.of(1)) // TypeError: this.__value.concat is not a function
```

It is a *semigroup* if and only if its `__value` is a *semigroup*. Like a butterfingered hang glider, it is one whilst it holds one.

Other types have similar behavior:

```js
// combine with error handling
Right(Sum(2)).concat(Right(Sum(3))) // Right(Sum(5))
Right(Sum(2)).concat(Left('some error')) // Left('some error')


// combine async
Task.of([1,2]).concat(Task.of([3,4])) // Task([1,2,3,4])
```

This gets particularly useful when we stack these semigroups into a cascading combination:

```js
// formValues :: Selector -> IO (Map String String)
// validate :: Map String String -> Either Error (Map String String)

formValues('#signup').map(validate).concat(formValues('#terms').map(validate)) // IO(Right(Map({username: 'andre3000', Accepted: true})))
formValues('#signup').map(validate).concat(formValues('#terms').map(validate)) // IO(Left('一个人必须接受我们的极权协议'))

serverA.get('/friends').concat(serverB.get('/friends')) // 任务([friend1,friend2])

// loadSetting :: String -> Task Error (Maybe (Map String Boolean))
loadSetting('email').concat(loadSetting('general')) // Task(Maybe(Map({backgroundColor: true, autoSave: false})))
```

In the top example, we've combined an `IO` holding an `Either` holding a `Map` to validate and merge form values. Next, we've hit a couple of different servers and combined their results in an async way using `Task` and `Array`. Lastly, we've stacked `Task`, `Maybe`, and `Map` to load, parse, and merge multiple settings.

These can be `chain`ed or `ap`'d, but *semigroups* capture what we'd like to do much more concisely.

This extends beyond functors. In fact, it turns out that anything made up entirely of semigroups, is itself, a semigroup: if we can concat the kit, then we can concat the caboodle.

```js
const Analytics = (clicks, path, idleTime) => ({
  clicks,
  path,
  idleTime,
  concat: other =>
    Analytics(clicks.concat(other.clicks), path.concat(other.path), idleTime.concat(other.idleTime))
})

Analytics(Sum(2), ['/home', '/about'], Right(Max(2000))).concat(Analytics(Sum(1), ['/contact'], Right(Max(1000))))
// Analytics(Sum(3), ['/home', '/about', '/contact'], Right(Max(2000)))
```

See, everything knows how to combine itself nicely. Turns out, we could do the same thing for free just by using the `Map` type:

```js
Map({clicks: Sum(2), path: ['/home', '/about'], idleTime: Right(Max(2000))}).concat(Map({clicks: Sum(1), path: ['/contact'], idleTime: Right(Max(1000))}))
// Map({clicks: Sum(3), path: ['/home', '/about', '/contact'], idleTime: Right(Max(2000))})
```

我们可以根据需要堆叠和组合任意数量的这些。这只是根据您的代码库向森林中添加另一棵树，或向森林火灾中添加另一个火焰的问题。

默认的、直观的行为是组合类型所持有的内容，但是，在某些情况下，我们会忽略内部内容并组合容器本身。考虑像 `Stream` 这样的类型：

```js
const submitStream = Stream.fromEvent('click', $('#submit'))
const enterStream = filter(x => x.key === 'Enter', Stream.fromEvent('keydown', $('#myForm')))

submitStream.concat(enterStream).map(submitForm) // Stream()
```

我们可以通过从两者中捕获事件作为一个新流来组合事件流。或者，我们可以通过坚持他们持有一个半组来合并他们。事实上，每种类型都有许多可能的实例。考虑`Task`，我们可以通过选择两者中较早或较晚的来组合它们。我们总是可以选择第一个 `Right` 而不是在 `Left` 上短路，这具有忽略错误的效果。有一个名为 *Alternative* 的接口，它实现了其中的一些替代实例，通常侧重于选择而不是级联组合。如果您需要这样的功能，值得研究。

## Monoids 一无所有

我们正在抽象加法，但像巴比伦人一样，我们缺乏零的概念（零提及它）。

零充当 *identity* 意味着添加到“0”的任何元素都将返回相同的元素。在抽象方面，将“0”视为一种中性或 *空* 元素是有帮助的。重要的是它在我们二元运算的左侧和右侧以相同的方式运行：

```js
// identity
1 + 0 = 1
0 + 1 = 1
```

Let's call this concept `empty` and create a new interface with it. Like so many startups, we'll choose a heinously uninformative, yet conveniently googleable name: *Monoid*. The recipe for *Monoid* is to take any *semigroup* and add a special *identity* element. We'll implement that with an `empty` function on the type itself:

```js
Array.empty = () => []
String.empty = () => ""
Sum.empty = () => Sum(0)
Product.empty = () => Product(1)
Min.empty = () => Min(Infinity)
Max.empty = () => Max(-Infinity)
All.empty = () => All(true)
Any.empty = () => Any(false)
```

什么时候可以证明空的身份值有用？这就像问为什么零是有用的。就像什么都不问...

当我们一无所有时，还能指望谁？零。我们想要多少个错误？零。这是我们对不安全代码的容忍度。一个新的开始。最终的价格标签。它可以消灭它所经过的一切，或者在紧要关头拯救我们。一个黄金救生员和一个绝望的深渊。

Codewise，它们对应于合理的默认值：

```js
const settings = (prefix="", overrides=[], total=0) => ...

const settings = (prefix=String.empty(), overrides=Array.empty(), total=Sum.empty()) => ...
```

或者在我们没有别的东西时返回一个有用的值：

```js
sum([]) // 0
```

They are also the perfect initial value for an accumulator...

## Folding down the house

It just so happens that `concat` and `empty` fit perfectly in the first two slots of `reduce`. We can actually `reduce` an array of *semigroup*'s down by ignoring the *empty* value, but as you can see, that leads to a precarious situation:

```js
// concat :: Semigroup s => s -> s -> s
const concat = x => y => x.concat(y)

[Sum(1), Sum(2)].reduce(concat) // Sum(3)

[].reduce(concat) // TypeError: Reduce of empty array with no initial value
```

Boom goes the dynamite. Like a twisted ankle in a marathon, we have ourselves a runtime exception. JavaScript is more than happy to let us strap pistols to our sneakers before running - it is a conservative sort of language, I suppose, but it stops us dead in our tracks when the array is barren. What could it return anyhow? `NaN`, `false`, `-1`? If we were to continue on in our program, we'd like a result of the right type. It could return a `Maybe` to indicate the possibility of failure, but we can do one better.

Let's use our curried `reduce` function and make a safe version where the `empty` value is not optional. It shall henceforth be known as `fold`:

```js
// fold :: Monoid m => m -> [m] -> m
const fold = reduce(concat)
```

最初的 `m` 是我们的 `empty` 值 - 我们的中性起点，然后我们取一组 `m` 并将它们粉碎成一个美丽的钻石般的价值。

```js
fold(Sum.empty(), [Sum(1), Sum(2)]) // Sum(3)
fold(Sum.empty(), []) // Sum(0)

fold(Any.empty(), [Any(false), Any(true)]) // Any(true)
fold(Any.empty(), []) // Any(false)


fold(Either.of(Max.empty()), [Right(Max(3)), Right(Max(21)), Right(Max(11))]) // Right(Max(21))
fold(Either.of(Max.empty()), [Right(Max(3)), Left('error retrieving value'), Right(Max(11))]) // Left('error retrieving value')

fold(IO.of([]), ['.link', 'a'].map($)) // IO([<a>, <button class="link"/>, <a>])
```

我们为最后两个提供了一个手动的 `empty` 值，因为我们无法在类型本身上定义一个。那完全没问题。类型化语言可以自己解决这个问题，但我们必须在这里传递它。

## 不是一个幺半群

有一些*半群*不能成为*幺半群*，即提供初始值。看“第一”：

```js
const First = x => ({ x, concat: other => First(x) })

Map({id: First(123), isPaid: Any(true), points: Sum(13)}).concat(Map({id: First(2242), isPaid: Any(false), points: Sum(1)}))
// Map({id: First(123), isPaid: Any(true), points: Sum(14)})
```

我们将合并几个帐户并保留“第一个”ID。无法为其定义“空”值。不代表没用。


##大统一理论

##群论还是范畴论？

二元运算的概念在抽象代数中无处不在。事实上，它是*类别*的主要操作。然而，我们不能在没有*身份*的情况下对我们在范畴论中的操作进行建模。这就是为什么我们从群论中的半群开始，然后一旦我们有*空*就跳到范畴论中的幺半群。

Monoids 形成一个单一的对象类别，其中态射是`concat`，`empty` 是身份，并且组合是有保证的。

### 作为幺半群的组合

`a -> a` 类型的函数，其中域与余域在同一个集合中，被称为*内同态*。我们可以制作一个名为“Endo”的 *monoid* 来捕捉这个想法：

```js
const Endo = run => ({
  run,
  concat: other =>
    Endo(compose(run, other.run))
})

Endo.empty = () => Endo(identity)


// in action

// thingDownFlipAndReverse :: Endo [String] -> [String]
const thingDownFlipAndReverse = fold(Endo(() => []), [Endo(reverse), Endo(sort), Endo(append('thing down')])

thingDownFlipAndReverse.run(['let me work it', 'is it worth it?'])
// ['thing down', 'let me work it', 'is it worth it?']
```

由于它们都是相同的类型，我们可以通过 `compose` 来 `concat`，并且类型总是对齐的。

### Monad 作为幺半群

您可能已经注意到 `join` 是一种操作，它采用两个（嵌套的）monad 并以关联方式将它们压缩为一个。它也是一种自然变换或“函子函数”。如前所述，我们可以将一类函子作为具有自然变换的对象作为态射。现在，如果我们将它专门用于 *Endofunctors*，即相同类型的函子，那么 `join` 为我们提供了一个 Endofunctors 类别中的幺半群，也称为 Monad。要在代码中显示确切的公式需要一些小技巧，我鼓励您使用谷歌搜索，但这是总体思路。

### 作为幺半群应用

甚至应用函子也有一个在范畴论中称为*松散幺半群函子*的幺半群公式。我们可以将接口实现为 monoid 并从中恢复“ap”：

```js
// concat :: f a -> f b -> f [a, b]
// empty :: () -> f ()

// ap :: Functor f => f (a -> b) -> f a -> f b
const ap = compose(map(([f, x]) => f(x)), concat)
```


＃＃ 总之

所以你看，一切都是相连的，或者可以。这种深刻的认识使 *Monoids* 成为一种强大的建模工具，适用于广泛的应用程序架构到最微小的数据块。我鼓励你在应用程序中直接积累或组合时考虑 *monoids*，然后一旦你解决了这个问题，就开始将定义扩展到更多的应用程序（你会惊讶于一个人可以用*单体*）。

## 练习

