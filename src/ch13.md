# 第 13 章：幺半群将它们组合在一起

##百搭组合

在本章中，我们将通过*半群* 来研究*幺半群*。 _ Monoids_ 是数学抽象头发中的泡泡糖。他们捕捉到一个跨越多个学科的想法，形象地和字面地将它们整合在一起。它们是连接所有计算的不祥之力。我们代码库中的氧气，它运行的地面，量子纠缠编码。

_Monoids_ 是关于组合的。但什么是组合？它可以意味着很多事情，从累积到串联，再到乘法，再到选择、组合、排序，甚至评估！我们会在这里看到很多例子，但我们只会在幺半群山的山脚下踮起脚尖。实例丰富，应用广泛。本章的目的是提供一个很好的直觉，这样你就可以制作一些你自己的 _monoids_。

## 抽象加法

加法有一些我想讨论的有趣品质。让我们通过我们的抽象护目镜来看看它。

对于初学者来说，它是一个二元运算，也就是说，一个取两个值并返回一个值的运算，它们都在同一个集合中。

```js
// a binary operation
1 + 1 = 2
```

看？域中的两个值，codomain 中的一个值，所有相同的集合 - 数字，就像它一样。有些人可能会说数字是“在加法下封闭的”，这意味着无论将哪些数字加入组合中，类型都不会改变。这意味着我们可以链接操作，因为结果总是另一个数字：

```js
// we can run this on any amount of numbers
1 + 7 + 5 + 4 + ...
```

除此之外（多么巧妙的双关语......），我们有关联性，这使我们能够根据需要对操作进行分组。顺便说一下，关联的二元运算是并行计算的一个秘诀，因为我们可以分块和分配工作。

```js
// associativity
1 + 2 + 3 = 6
1 + (2 + 3) = 6
```

现在，不要把它与允许我们重新排列顺序的交换性混淆。虽然这适用于加法，但我们目前对该属性并不是特别感兴趣——对于我们的抽象需求来说太具体了。

想想看，无论如何，我们的抽象超类中应该有哪些属性？哪些特征是加法特有的，哪些特征可以推广？在这个层次结构中是否还有其他抽象，或者都是一个块？我们的数学先驱在抽象代数中构思接口时应用的就是这种思想。

碰巧的是，那些老派抽象主义者在抽象加法时使用了*组*的概念。 *组*具有所有花里胡哨的功能，包括负数的概念。在这里，我们只对关联二元运算符感兴趣，因此我们将选择不太具体的接口 _Semigroup_。 _Semigroup_ 是一种带有 `concat` 方法的类型，它充当我们的关联二元运算符。

让我们实现它以进行加法并将其称为“Sum”：

```js
const Sum = (x) => ({
  x,
  concat: (other) => Sum(x + other.x),
})
```

请注意，我们将“concat”与其他一些“Sum”结合在一起，并始终返回“Sum”。

我在这里使用了对象工厂而不是我们典型的原型仪式，主要是因为 `Sum` 不是 _pointed_ 并且我们不想输入 `new`。无论如何，这是在行动：

```js
Sum(1).concat(Sum(3)) // Sum(4)
Sum(4).concat(Sum(37)) // Sum(41)
```

就像那样，我们可以编程到一个接口，而不是一个实现。由于这个接口来自群论，它有几个世纪的文献支持。免费文档！

现在，如前所述，`Sum` 不是 _pointed_，也不是 _functor_。作为练习，请返回并检查法律以了解原因。好吧，我只是告诉你：它只能容纳一个数字，所以 `map` 在这里没有意义，因为我们无法将底层值转换为另一种类型。那确实是一个非常有限的“地图”！

那么为什么这很有用呢？好吧，与任何接口一样，我们可以换出我们的实例来实现不同的结果：

```js
const Product = (x) => ({ x, concat: (other) => Product(x * other.x) })

const Min = (x) => ({ x, concat: (other) => Min(x < other.x ? x : other.x) })

const Max = (x) => ({ x, concat: (other) => Max(x > other.x ? x : other.x) })
```

但这不仅限于数字。让我们看看其他一些类型：

```js
const Any = (x) => ({ x, concat: (other) => Any(x || other.x) })
const All = (x) => ({ x, concat: (other) => All(x && other.x) })

Any(false).concat(Any(true)) // Any(true)
Any(false).concat(Any(false)) // Any(false)

All(false).concat(All(true)) // All(false)
All(true)
  .concat(All(true)) // All(true)

  [(1, 2)].concat([3, 4]) // [1,2,3,4]

'miracle grow'.concat('n') // miracle grown"

Map({ day: 'night' }).concat(Map({ white: 'nikes' })) // Map({day: 'night', white: 'nikes'})
```

如果你盯着这些看够久，图案就会像魔眼海报一样突然出现在你身上。它无处不在。我们正在合并数据结构、组合逻辑、构建字符串……似乎几乎可以将任何任务融入这个基于组合的界面中。

我已经使用了几次`Map`。如果没有正确介绍你们两个，请原谅我。 `Map` 简单地包装了 `Object`，因此我们可以用一些额外的方法来修饰它，而不会改变宇宙的结构。

## 我最喜欢的函子都是半群。

到目前为止我们看到的实现函子接口的类型也都实现了半群一。让我们看看`Identity`（艺术家以前称为 Container）：

```js
Identity.prototype.concat = function (other) {
  return new Identity(this.__value.concat(other.__value))
}

Identity.of(Sum(4)).concat(Identity.of(Sum(1))) // Identity(Sum(5))
Identity.of(4).concat(Identity.of(1)) // TypeError: this.__value.concat is not a function
```

当且仅当它的 `__value` 是一个 _semigroup_ 时，它是一个 _semigroup_。就像一个带蝴蝶结的悬挂式滑翔机，它是一个同时持有一个。

其他类型有类似的行为：

```js
// combine with error handling
Right(Sum(2)).concat(Right(Sum(3))) // Right(Sum(5))
Right(Sum(2)).concat(Left('some error')) // Left('some error')

// combine async
Task.of([1, 2]).concat(Task.of([3, 4])) // Task([1,2,3,4])
```

当我们将这些半群堆叠成级联组合时，这变得特别有用：

```js
// formValues :: Selector -> IO (Map String String)
// validate :: Map String String -> Either Error (Map String String)

formValues('#signup').map(validate).concat(formValues('#terms').map(validate)) // IO(Right(Map({username: 'andre3000', accepted: true})))
formValues('#signup').map(validate).concat(formValues('#terms').map(validate)) // IO(Left('one must accept our totalitarian agreement'))

serverA.get('/friends').concat(serverB.get('/friends')) // Task([friend1, friend2])

// loadSetting :: String -> Task Error (Maybe (Map String Boolean))
loadSetting('email').concat(loadSetting('general')) // Task(Maybe(Map({backgroundColor: true, autoSave: false})))
```

在最上面的例子中，我们结合了一个包含一个 `Either` 和一个 `Map` 的 `IO` 来验证和合并表单值。接下来，我们访问了几个不同的服务器，并使用 `Task` 和 `Array` 以异步方式组合它们的结果。最后，我们堆叠了 `Task`、`Maybe` 和 `Map` 来加载、解析和合并多个设置。

这些可以是`chain`ed 或`ap`d，但*semigroups* 更简洁地捕捉我们想要做的事情。

这超出了函子的范畴。事实上，事实证明，任何完全由半群组成的东西本身就是一个半群：如果我们可以连接套件，那么我们就可以连接一堆。

```js
const Analytics = (clicks, path, idleTime) => ({
  clicks,
  path,
  idleTime,
  concat: (other) =>
    Analytics(
      clicks.concat(other.clicks),
      path.concat(other.path),
      idleTime.concat(other.idleTime),
    ),
})

Analytics(Sum(2), ['/home', '/about'], Right(Max(2000))).concat(
  Analytics(Sum(1), ['/contact'], Right(Max(1000))),
)
// Analytics(Sum(3), ['/home', '/about', '/contact'], Right(Max(2000)))
```

看，一切都知道如何很好地结合自己。事实证明，我们可以通过使用 Map 类型免费做同样的事情：

```js
Map({
  clicks: Sum(2),
  path: ['/home', '/about'],
  idleTime: Right(Max(2000)),
}).concat(
  Map({ clicks: Sum(1), path: ['/contact'], idleTime: Right(Max(1000)) }),
)
// Map({clicks: Sum(3), path: ['/home', '/about', '/contact'], idleTime: Right(Max(2000))})
```

我们可以根据需要堆叠和组合任意数量的这些。这只是根据您的代码库向森林中添加另一棵树，或向森林火灾中添加另一个火焰的问题。

默认的、直观的行为是组合类型所持有的内容，但是，在某些情况下，我们会忽略内部内容并组合容器本身。考虑像 `Stream` 这样的类型：

```js
const submitStream = Stream.fromEvent('click', $('#submit'))
const enterStream = filter(
  (x) => x.key === 'Enter',
  Stream.fromEvent('keydown', $('#myForm')),
)

submitStream.concat(enterStream).map(submitForm) // Stream()
```

我们可以通过从两者中捕获事件作为一个新流来组合事件流。或者，我们可以通过坚持他们持有一个半组来合并他们。事实上，每种类型都有许多可能的实例。考虑`Task`，我们可以通过选择两者中较早或较晚的来组合它们。我们总是可以选择第一个 `Right` 而不是在 `Left` 上短路，这具有忽略错误的效果。有一个名为 _Alternative_ 的接口，它实现了其中的一些替代实例，通常侧重于选择而不是级联组合。如果您需要这样的功能，值得研究。

## Monoids 一无所有

我们正在抽象加法，但像巴比伦人一样，我们缺乏零的概念（零提及它）。

零充当 _identity_ 意味着添加到“0”的任何元素都将返回相同的元素。在抽象方面，将“0”视为一种中性或 _空_ 元素是有帮助的。重要的是它在我们二元运算的左侧和右侧以相同的方式运行：

```js
// identity
1 + 0 = 1
0 + 1 = 1
```

让我们称这个概念为“空”并用它创建一个新界面。像许多初创公司一样，我们将选择一个信息量极少但又可以方便地在 google 上搜索的名称：_Monoid_。 _Monoid_ 的配方是采用任何 _semigroup_ 并添加一个特殊的 _identity_ 元素。我们将在类型本身上使用一个 `empty` 函数来实现它：

```js
Array.empty = () => []
String.empty = () => ''
Sum.empty = () => Sum(0)
Product.empty = () => Product(1)
Min.empty = () => Min(Infinity)
Max.empty = () => Max(-Infinity)
All.empty = () => All(true)
Any.empty = () => Any(false)
```

什么时候可以证明空的身份值有用？这就像问为什么零是有用的。就像什么都不问...

当我们一无所有时，还能指望谁？零。我们想要多少个错误？零。这是我们对不安全代码的容忍度。一个新的开始。最终的价格标签。它可以消灭它所经过的一切，或者在紧要关头拯救我们。一个黄金救生员和一个绝望的深渊。

Codewise，它们对应于合理的默认值：

```js
const settings = (prefix="", overrides=[], total=0) => ...

const settings = (prefix=String.empty(), overrides=Array.empty(), total=Sum.empty()) => ...
```

或者在我们没有别的东西时返回一个有用的值：

```js
sum([]) // 0
```

它们也是累加器的完美初始值......

##折叠房子

碰巧 `concat` 和 `empty` 正好适合 `reduce` 的前两个插槽。我们实际上可以通过忽略 _empty_ 值来“减少”一个 _semigroup_ 的数组，但是正如你所看到的，这会导致一个不稳定的情况：

```js
// concat :: Semigroup s => s -> s -> s
const concat = x => y => x.concat(y)

[Sum(1), Sum(2)].reduce(concat) // Sum(3)

[].reduce(concat) // TypeError: Reduce of empty array with no initial value
```

炸药爆炸了。就像马拉松比赛中扭伤的脚踝一样，我们自己也有一个运行时异常。 JavaScript 非常乐意让我们在跑步前将手枪绑在运动鞋上 - 我想这是一种保守的语言，但是当数组贫瘠时，它可以阻止我们死在我们的轨道上。它还能返回什么？ `NaN`、`false`、`-1`？如果我们要继续我们的程序，我们希望得到正确类型的结果。它可以返回一个 `Maybe` 来表示失败的可能性，但我们可以做得更好。

让我们使用柯里化的 `reduce` 函数并制作一个安全的版本，其中 `empty` 值不是可选的。此后，它将被称为“折叠”：

```js
// fold :: Monoid m => m -> [m] -> m
const fold = reduce(concat)
```

最初的 `m` 是我们的 `empty` 值 - 我们的中性起点，然后我们取一组 `m` 并将它们粉碎成一个美丽的钻石般的价值。

```js
fold(Sum.empty(), [Sum(1), Sum(2)]) // Sum(3)
fold(Sum.empty(), []) // Sum(0)

fold(Any.empty(), [Any(false), Any(true)]) // Any(true)
fold(Any.empty(), []) // Any(false)

fold(Either.of(Max.empty()), [Right(Max(3)), Right(Max(21)), Right(Max(11))]) // Right(Max(21))
fold(Either.of(Max.empty()), [
  Right(Max(3)),
  Left('error retrieving value'),
  Right(Max(11)),
]) // Left('error retrieving value')

fold(IO.of([]), ['.link', 'a'].map($)) // IO([<a>, <button class="link"/>, <a>])
```

我们为最后两个提供了一个手动的 `empty` 值，因为我们无法在类型本身上定义一个。那完全没问题。类型化语言可以自己解决这个问题，但我们必须在这里传递它。

## 不是一个幺半群

有一些*半群*不能成为*幺半群*，即提供初始值。看“第一”：

```js
const First = (x) => ({ x, concat: (other) => First(x) })

Map({ id: First(123), isPaid: Any(true), points: Sum(13) }).concat(
  Map({ id: First(2242), isPaid: Any(false), points: Sum(1) }),
)
// Map({id: First(123), isPaid: Any(true), points: Sum(14)})
```

我们将合并几个帐户并保留“第一个”ID。无法为其定义“空”值。不代表没用。

##大统一理论

##群论还是范畴论？

二元运算的概念在抽象代数中无处不在。事实上，它是*类别*的主要操作。然而，我们不能在没有*身份*的情况下对我们在范畴论中的操作进行建模。这就是为什么我们从群论中的半群开始，然后一旦我们有*空*就跳到范畴论中的幺半群。

Monoids 形成一个单一的对象类别，其中态射是`concat`，`empty` 是身份，并且组合是有保证的。

### 作为幺半群的组合

`a -> a` 类型的函数，其中域与余域在同一个集合中，被称为*内同态*。我们可以制作一个名为“Endo”的 _monoid_ 来捕捉这个想法：

```js
const Endo = run => ({
  run,
  concat: other =>
    Endo(compose(run, other.run))
})

Endo.empty = () => Endo(identity)


// in action

// thingDownFlipAndReverse :: Endo [String] -> [String]
const thingDownFlipAndReverse = fold(Endo(() => []), [Endo(reverse), Endo(sort), Endo(append('thing down')])

thingDownFlipAndReverse.run(['let me work it', 'is it worth it?'])
// ['thing down', 'let me work it', 'is it worth it?']
```

由于它们都是相同的类型，我们可以通过 `compose` 来 `concat`，并且类型总是对齐的。

### Monad 作为幺半群

您可能已经注意到 `join` 是一种操作，它采用两个（嵌套的）monad 并以关联方式将它们压缩为一个。它也是一种自然变换或“函子函数”。如前所述，我们可以将一类函子作为具有自然变换的对象作为态射。现在，如果我们将它专门用于 _Endofunctors_，即相同类型的函子，那么 `join` 为我们提供了一个 Endofunctors 类别中的幺半群，也称为 Monad。要在代码中显示确切的公式需要一些小技巧，我鼓励您使用谷歌搜索，但这是总体思路。

### 作为幺半群应用

甚至应用函子也有一个在范畴论中称为*松散幺半群函子*的幺半群公式。我们可以将接口实现为 monoid 并从中恢复“ap”：

```js
// concat :: f a -> f b -> f [a, b]
// empty :: () -> f ()

// ap :: Functor f => f (a -> b) -> f a -> f b
const ap = compose(
  map(([f, x]) => f(x)),
  concat,
)
```

＃＃ 总之

所以你看，一切都是相连的，或者可以。这种深刻的认识使 _Monoids_ 成为一种强大的建模工具，适用于广泛的应用程序架构到最微小的数据块。我鼓励你在应用程序中直接积累或组合时考虑 _monoids_，然后一旦你解决了这个问题，就开始将定义扩展到更多的应用程序（你会惊讶于一个人可以用*单体*）。

## 练习
