#第 08 章：特百惠

## 强大的容器

<img src="images/jar.jpg" alt="http://blog.dwinegar.com/2011/06/another-jar.html" />

我们已经看到了如何编写通过一系列纯函数传输数据的程序。它们是行为的声明性规范。但是控制流、错误处理、异步操作、状态以及，我敢说，效果呢？！在本章中，我们将发现构建所有这些有用的抽象的基础。

首先，我们将创建一个容器。这个容器必须保存任何类型的值；只能装木薯布丁的拉链锁很少有用。它将是一个对象，但我们不会在 OO 意义上给它属性和方法。不，我们会把它当作一个宝箱——一个特殊的盒子，用来存放我们宝贵的数据。

```js
class Container {
  constructor(x) {
    this.$value = x
  }

  static of(x) {
    return new Container(x)
  }
}
```

这是我们的第一个容器。我们贴心地将其命名为“Container”。我们将使用 `Container.of` 作为构造函数，这样我们就不必到处写那个可怕的 `new` 关键字。 `of` 函数的作用远不止眼前一亮，但就目前而言，请将其视为将值放入我们的容器中的正确方法。

让我们检查一下我们全新的盒子......

```js
Container.of(3)
// Container(3)

Container.of('hotdogs')
// Container("hotdogs")

Container.of(Container.of({ name: 'yoda' }))
// Container(Container({ name: 'yoda' }))
```

如果你使用 node，你会看到 `{$value: x}`，即使我们有一个 `Container(x)`。 Chrome 会正确输出类型，但没关系；只要我们了解`Container` 是什么样子，我们就会没事的。在某些环境中，如果您愿意，您可以覆盖 `inspect` 方法，但我们不会如此彻底。对于本书，我们将编写概念输出，就像我们覆盖了 `inspect` 一样，因为出于教学和美学原因，它比 `{$value: x}` 更有指导意义。

在我们继续之前，让我们先弄清楚一些事情：

- `Container` 是一个具有一个属性的对象。许多容器只装一件事，尽管它们不仅限于一件。我们随意地将它的属性命名为“$value”。

- `$value` 不能是一种特定的类型，否则我们的 `Container` 将难以名副其实。

- 一旦数据进入`Container`，它就会留在那里。我们*可以*通过使用`.$value`来解决它，但这会破坏目的。

我们这样做的原因就像一个石匠罐子一样清楚，但现在，请耐心等待。

## 我的第一个函子

一旦我们的值，无论它是什么，都在容器中，我们需要一种在其上运行函数的方法。

```js
// (a -> b) -> Container a -> Container b
Container.prototype.map = function (f) {
  return Container.of(f(this.$value))
}
```

为什么，就像 Array 著名的 `map` 一样，只是我们有 `Container a` 而不是 `[a]`。它的工作原理基本相同：

```js
Container.of(2).map((two) => two + 2)
// Container(4)

Container.of('flamethrowers').map((s) => s.toUpperCase())
// Container('FLAMETHROWERS')

Container.of('bombs').map(append(' away')).map(prop('length'))
// Container(10)
```

我们可以使用我们的价值而不必离开`Container`。这是一件了不起的事情。我们在 `Container` 中的值被传递给 `map` 函数，因此我们可以对它大惊小怪，然后返回到它的 `Container` 以安全保存。由于从不离开 `Container`，我们可以继续 `map` 离开，随心所欲地运行函数。我们甚至可以按照三个示例中的后一个示例进行操作来更改类型。

等一下，如果我们继续调用`map`，它似乎是某种组合！这里有什么数学魔法在起作用？好吧，伙计们，我们刚刚发现了 _Functors_。

> Functor 是一种实现 `map` 并遵守一些规律的类型

是的，_Functor_ 只是一个带有合约的接口。我们可以很容易地将它命名为 _Mappable_，但现在，它的 _乐趣_ 在哪里？函子来自范畴论，我们将在本章末尾详细研究数学，但现在，让我们研究这个命名怪异的接口的直觉和实际用途。

我们可能有什么理由将一个值装瓶并使用 `map` 来获取它？如果我们选择一个更好的问题，答案就会显现出来：让我们的容器为我们应用函数，我们能得到什么？嗯，函数应用的抽象。当我们`map`一个函数时，我们要求容器类型为我们运行它。这确实是一个非常强大的概念。

##薛定谔的可能

<img src="images/cat.png" alt="酷猫，需要参考" />

`Container` 很无聊。事实上，它通常被称为“身份”并且与我们的“id”函数具有大致相同的影响（同样，我们将在适当的时候查看数学联系）。但是，还有其他函子，即具有适当`map` 函数的类容器类型，可以在映射时提供有用的行为。现在让我们定义一个。

> [附录 B](./appendix_b.md#Maybe) 中给出了完整的实现

```js
class Maybe {
  static of(x) {
    return new Maybe(x)
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined
  }

  constructor(x) {
    this.$value = x
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value))
  }

  inspect() {
    return this.isNothing ? 'Nothing' : `Just(${inspect(this.$value)})`
  }
}
```

现在，`Maybe` 看起来很像 `Container`，只是做了一个小改动：它会在调用提供的函数之前首先检查它是否有值。这具有在我们“映射”时侧步那些讨厌的空值的效果（请注意，此实现是为了教学而简化的）。

```js
Maybe.of('Malkovich Malkovich').map(match(/a/gi))
// Just(True)

Maybe.of(null).map(match(/a/gi))
// Nothing

Maybe.of({ name: 'Boris' }).map(prop('age')).map(add(10))
// Nothing

Maybe.of({ name: 'Dinah', age: 14 }).map(prop('age')).map(add(10))
// Just(24)
```

请注意，当我们将函数映射到空值上时，我们的应用程序不会因错误而爆炸。这是因为 `Maybe` 每次应用一个函数时都会小心地检查一个值。

这种点语法非常好且实用，但由于第 1 部分中提到的原因，我们希望保持我们的 pointfree 风格。碰巧的是，`map` 完全具备委托给它接收到的任何函子的能力：

```js
// map :: Functor f => (a -> b) -> f a -> f b
const map = curry((f, anyFunctor) => anyFunctor.map(f))
```

这很令人愉快，因为我们可以照常进行合成，并且 `map` 将按预期工作。 ramda 的`map` 也是这种情况。我们将在有指导意义时使用点表示法，在方便时使用 pointfree 版本。你注意到了吗？我偷偷地在我们的类型签名中引入了额外的符号。 `Functor f =>` 告诉我们 `f` 必须是一个 Functor。没那么难，但我觉得我应该提到它。

＃＃ 用例

实际上，我们通常会在可能无法返回结果的函数中看到“Maybe”。

```js
// safeHead :: [a] -> Maybe(a)
const safeHead = (xs) => Maybe.of(xs[0])

// streetName :: Object -> Maybe String
const streetName = compose(map(prop('street')), safeHead, prop('addresses'))

streetName({ addresses: [] })
// Nothing

streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] })
// Just('Shady Ln.')
```

`safeHead` 就像我们普通的 `head`，但增加了类型安全性。当 `Maybe` 被引入我们的代码时，会发生一件奇怪的事情；我们被迫处理那些偷偷摸摸的 `null` 值。 `safeHead` 函数对它可能的失败是诚实和预先说明的 - 真的没有什么可羞耻的 - 所以它返回一个 `Maybe` 来通知我们这个问题。然而，我们不仅仅是*知情*，因为我们被迫通过`map` 来获得我们想要的值，因为它隐藏在`Maybe` 对象中。本质上，这是由“safeHead”函数本身强制执行的“null”检查。我们现在可以在晚上睡得更好，因为知道 `null` 值不会在我们最意想不到的时候抬起它丑陋的、被斩首的头。像这样的 API 将把脆弱的应用程序从纸和大头钉升级到木头和钉子。他们将保证更安全的软件。

有时，函数可能会显式返回“Nothing”以表示失败。例如：

```js
// withdraw :: Number -> Account -> Maybe(Account)
const withdraw = curry((amount, { balance }) =>
  Maybe.of(balance >= amount ? { balance: balance - amount } : null),
)

// This function is hypothetical, not implemented here... nor anywhere else.
// updateLedger :: Account -> Account
const updateLedger = (account) => account

// remainingBalance :: Account -> String
const remainingBalance = ({ balance }) => `Your balance is $${balance}`

// finishTransaction :: Account -> String
const finishTransaction = compose(remainingBalance, updateLedger)

// getTwenty :: Account -> Maybe(String)
const getTwenty = compose(map(finishTransaction), withdraw(20))

getTwenty({ balance: 200.0 })
// Just('Your balance is $180')

getTwenty({ balance: 10.0 })
// Nothing
```

如果我们现金短缺，`withdraw` 会对我们嗤之以鼻，并返回`Nothing`。这个函数也传达了它的变化无常，让我们别无选择，只能在事后“映射”一切。不同之处在于这里的 `null` 是故意的。代替`Just('..')`，我们得到了`Nothing` 返回信号失败，我们的应用程序有效地停止了它的轨道。需要注意的是：如果`withdraw` 失败，那么`map` 将切断我们剩余的计算，因为它永远不会运行映射函数，即`finishTransaction`。这正是预期的行为，因为如果我们没有成功提取资金，我们不希望更新我们的分类账或显示新的余额。

## 释放值

人们经常错过的一件事是，总会有终点；一些有效的函数，可以发送 JSON，或者打印到屏幕上，或者改变我们的文件系统，或者你有什么。我们不能使用 `return` 来传递输出，我们必须运行某个函数或其他函数才能将其发送到世界上。我们可以用禅宗的公案来形容它：“如果一个程序没有可观察到的效果，它甚至会运行吗？”。它是否为了自己的满足而正确运行？我怀疑它只是燃烧了一些周期并重新入睡......

我们的应用程序的工作是检索、转换和携带该数据，直到该说再见为止，并且可以映射执行此操作的函数，因此值不必离开其容器的温暖子宫。事实上，一个常见的错误是试图以一种或另一种方式从我们的“也许”中删除价值，好像里面可能的价值会突然实现并且一切都会被原谅。我们必须明白，它可能是代码的一个分支，我们的价值无法实现它的命运。我们的代码，很像薛定谔的猫，同时处于两种状态，并且应该保持这一事实直到最终函数。尽管存在逻辑分支，这为我们的代码提供了线性流程。

然而，有一个逃生舱口。如果我们更愿意返回一个自定义值并继续，我们可以使用一个名为“maybe”的小助手。

```js
// maybe :: b -> (a -> b) -> Maybe a -> b
const maybe = curry((v, f, m) => {
  if (m.isNothing) {
    return v
  }

  return f(m.$value)
})

// getTwenty :: Account -> String
const getTwenty = compose(
  maybe("You're broke!", finishTransaction),
  withdraw(20),
)

getTwenty({ balance: 200.0 })
// 'Your balance is $180.00'

getTwenty({ balance: 10.0 })
// 'You\'re broke!'
```

我们现在要么返回一个静态值（与 `finishTransaction` 返回的类型相同），或者继续愉快地完成交易，而没有 `Maybe`。对于 `maybe`，我们看到了与 `if/else` 语句等价的语句，而对于 `map`，命令式类似物是：`if (x !== null) { return f(x) }`。

`Maybe` 的引入可能会引起一些最初的不适。 Swift 和 Scala 的用户会明白我的意思，因为它以 `Option(al)` 为幌子直接嵌入到核心库中。当一直被要求处理 `null` 检查时（有时我们绝对确定该值存在），大多数人不禁觉得这有点费力。然而，随着时间的推移，它会成为第二天性，你可能会喜欢这种安全性。毕竟，在大多数情况下，它可以防止偷工减料并节省我们的生皮。

编写不安全的软件就像在把鸡蛋扔进车流之前小心地用粉彩涂上每个鸡蛋；就像用三只小猪警告过的材料建造养老院一样。在我们的功能中加入一些安全性对我们有好处，“也许”可以帮助我们做到这一点。

如果我没有提到“真正的”实现会将 `Maybe` 分为两种类型：一种是为了某事，另一种是什么都没有。这允许我们遵守 `map` 中的参数化，因此像 `null` 和 `undefined` 这样的值仍然可以被映射，并且函子中值的通用限定将得到尊重。您经常会看到类似“Some(x)/None”或“Just(x)/Nothing”这样的类型，而不是“Maybe”，它会对其值进行“null”检查。

## 纯错误处理

<img src="images/fists.jpg" alt="拿起手...需要参考" />

这可能会让人感到震惊，但 `throw/catch` 并不是很纯粹。当抛出错误时，我们不会返回输出值，而是发出警报！该函数攻击，像盾牌和长矛一样喷出数千个 0 和 1，与我们的入侵输入进行电战。有了我们的新朋友“Either”，我们可以做得比对输入宣战更好，我们可以用礼貌的消息回应。让我们来看看：

> [附录 B](./appendix_b.md#Either) 中给出了完整的实现

```js
class Either {
  static of(x) {
    return new Right(x)
  }

  constructor(x) {
    this.$value = x
  }
}

class Left extends Either {
  map(f) {
    return this
  }

  inspect() {
    return `Left(${inspect(this.$value)})`
  }
}

class Right extends Either {
  map(f) {
    return Either.of(f(this.$value))
  }

  inspect() {
    return `Right(${inspect(this.$value)})`
  }
}

const left = (x) => new Left(x)
```

`Left` 和 `Right` 是我们称为 `Either` 的抽象类型的两个子类。我已经跳过了创建“Either”超类的过程，因为我们永远不会使用它，但很高兴知道。那么，除了这两种类型之外，这里没有什么新东西。让我们看看他们是如何行动的：

```js
Either.of('rain').map((str) => `b${str}`)
// Right('brain')

left('rain').map((str) => `It's gonna ${str}, better bring your umbrella!`)
// Left('rain')

Either.of({ host: 'localhost', port: 80 }).map(prop('host'))
// Right('localhost')

left('rolls eyes...').map(prop('host'))
// Left('rolls eyes...')
```

`Left` 是青少年类型，忽略我们对它进行 `map` 的请求。 `Right` 将像 `Container`（又名身份）一样工作。强大的功能来自在“Left”中嵌入错误消息的能力。

假设我们有一个可能不会成功的函数。我们如何从出生日期计算年龄。我们可以使用“Nothing”来表示失败并分支我们的程序，但是，这并没有告诉我们太多。也许，我们想知道为什么它失败了。让我们使用“Either”来编写它。

```js
const moment = require('moment')

// getAge :: Date -> User -> Either(String, Number)
const getAge = curry((now, user) => {
  const birthDate = moment(user.birthDate, 'YYYY-MM-DD')

  return birthDate.isValid()
    ? Either.of(now.diff(birthDate, 'years'))
    : left('Birth date could not be parsed')
})

getAge(moment(), { birthDate: '2005-12-12' })
// Right(9)

getAge(moment(), { birthDate: 'July 4, 2001' })
// Left('Birth date could not be parsed')
```

现在，就像“Nothing”一样，当我们返回“Left”时，我们正在短路我们的应用程序。不同之处在于，现在我们知道为什么我们的程序出轨了。需要注意的是，我们返回了 `Either(String, Number)`，它保存了一个 `String` 作为它的左值，一个 `Number` 作为它的 `Right`。这种类型签名有点不正式，因为我们还没有花时间定义实际的“Either”超类，但是，我们从该类型中学到了很多东西。它通知我们要么收到错误消息，要么返回年龄。

```js
// fortune :: Number -> String
const fortune = compose(
  concat('If you survive, you will be '),
  toString,
  add(1),
)

// zoltar :: User -> Either(String, _)
const zoltar = compose(map(console.log), map(fortune), getAge(moment()))

zoltar({ birthDate: '2005-12-12' })
// 'If you survive, you will be 10'
// Right(undefined)

zoltar({ birthDate: 'balloons!' })
// Left('Birth date could not be parsed')
```

当“birthDate”有效时，程序将其神秘的财富输出到屏幕上供我们观看。否则，我们会收到一个“Left”，错误信息很简单，尽管仍然隐藏在它的容器中。这就像我们抛出了错误一样，但是以一种平静、温和的方式，而不是在出现问题时像孩子一样发脾气和尖叫。

在这个例子中，我们根据出生日期的有效性在逻辑上分支我们的控制流，但它读作从右到左的线性运动，而不是爬过条件语句的花括号。通常，我们会将 `console.log` 移出我们的 `zoltar` 函数并在调用时对其进行 `map`，但了解 `Right` 分支的不同之处会很有帮助。我们在右侧分支的类型签名中使用 `_` 来表示它是一个应该被忽略的值（在某些浏览器中你必须使用 `console.log.bind(console)` 来使用它）。

我想借此机会指出你可能遗漏的一些东西：`fortune`，尽管在这个例子中与 `Either` 一起使用，它完全不知道有任何函子在四处游荡。前面示例中的“finishTransaction”也是这种情况。在调用时，一个函数可以被 `map` 包围，以非正式的方式将它从一个非函子函数转换为函子函数。我们称这个过程为*提升*。函数最好使用普通数据类型而不是容器类型，然后根据需要*提升*到正确的容器中。这导致了更简单、更可重用的函数，可以根据需要对其进行更改以与任何函子一起使用。

`Either` 非常适用于验证等偶然错误以及更严重的错误，停止显示错误，例如丢失文件或损坏的套接字。尝试用“Either”替换一些“Maybe”示例以提供更好的反馈。

现在，我不禁觉得我把它仅仅作为一个错误消息的容器来引入“要么”是一种伤害。它捕获类型中的逻辑析取（又名`||`）。它还编码了来自范畴论的 _Coproduct_ 的思想，本书不会涉及到这一点，但值得一读，因为有一些属性可以利用。它是规范和类型（或集合的不相交并集），因为它可能的居民数量是两个包含类型的总和（我知道这有点摇摆不定，所以这是一篇 [很棒的文章](https://www.schoolofhaskell) .com/school/to-infinity-and-beyond/pick-of-the-week/sum-types))。 “Either”可以是很多东西，但作为函子，它用于错误处理。

就像 `Maybe` 一样，我们很少有 `either`，它的行为类似，但需要两个函数而不是一个和一个静态值。每个函数都应该返回相同的类型：

```js
// either :: (a -> c) -> (b -> c) -> Either a b -> c
const either = curry((f, g, e) => {
  let result

  switch (e.constructor) {
    case Left:
      result = f(e.$value)
      break

    case Right:
      result = g(e.$value)
      break

    // No Default
  }

  return result
})

// zoltar :: User -> _
const zoltar = compose(console.log, either(id, fortune), getAge(moment()))

zoltar({ birthDate: '2005-12-12' })
// 'If you survive, you will be 10'
// undefined

zoltar({ birthDate: 'balloons!' })
// 'Birth date could not be parsed'
// undefined
```

最后，使用那个神秘的 `id` 函数。它只是简单地将“Left”中的值回传给“console.log”。我们通过在 `getAge` 中强制执行错误处理，使我们的算命应用程序更加健壮。我们要么用硬道理给用户耳光，比如来自掌上电脑的高五，要么继续我们的流程。有了这个，我们已经准备好转向一种完全不同类型的函子。

##老麦当劳有影响...

<img src="images/dominoes.jpg" alt="dominoes.. 需要参考" />

在关于纯函数的章节中，我们看到了纯函数的一个特殊例子。这个函数包含一个副作用，但我们通过将它的动作包装在另一个函数中来称它为纯函数。这是另一个例子：

```js
// getFromStorage :: String -> (_ -> String)
const getFromStorage = (key) => () => localStorage[key]
```

如果我们没有在另一个函数中包围它的内脏，`getFromStorage` 将根据外部环境改变其输出。有了坚固的包装器，我们将始终为每个输入获得相同的输出：该函数在调用时将从 `localStorage` 中检索特定项目。就像那样（也许会加入一些万福玛丽）我们已经清除了我们的良心，一切都被原谅了。

除了，这现在不是特别有用，是吗。就像原始包装中的可收藏动作玩偶一样，我们实际上无法使用它。如果只有一种方法可以到达容器内部并获取其内容...输入`IO`。

```js
class IO {
  static of(x) {
    return new IO(() => x)
  }

  constructor(fn) {
    this.$value = fn
  }

  map(fn) {
    return new IO(compose(fn, this.$value))
  }

  inspect() {
    return `IO(${inspect(this.$value)})`
  }
}
```

`IO` 与之前的函子的不同之处在于 `$value` 始终是一个函数。我们不
然而，将它的 `$value` 视为一个函数 - 这是一个实现细节，我们最好
忽略它。正在发生的事情正是我们在 `getFromStorage` 示例中看到的：`IO`
通过在函数包装器中捕获它来延迟不纯的动作。因此，我们将“IO”视为
包含包装操作的返回值而不是包装器本身。这很明显
在 `of` 函数中：我们有一个 `IO(x)`，`IO(() => x)` 只需要
避免评价。请注意，为了简化阅读，我们将显示包含的假设值
结果在`IO`中；但是在实践中，直到你已经知道这个值是什么
居然发挥了效果！

让我们看看它的使用情况：

```js
// ioWindow :: IO Window
const ioWindow = new IO(() => window)

ioWindow.map((win) => win.innerWidth)
// IO(1430)

ioWindow.map(prop('location')).map(prop('href')).map(split('/'))
// IO(['http:', '', 'localhost:8000', 'blog', 'posts'])

// $ :: String -> IO [DOM]
const $ = (selector) => new IO(() => document.querySelectorAll(selector))

$('#myDiv')
  .map(head)
  .map((div) => div.innerHTML)
// IO('I am some inner html')
```

这里，`ioWindow` 是一个实际的 `IO`，我们可以直接对其进行 `map`，而 `$` 是一个在调用后返回 `IO` 的函数。我已经写出了 _conceptual_ 返回值以更好地表达 `IO`，但实际上，它始终是 `{ $value: [Function] }`。当我们在我们的 IO 上`map` 时，我们将该函数粘贴在组合的末尾，而该组合又变成了新的 `$value`，依此类推。我们的映射函数不会运行，它们会在我们正在构建的计算结束时按功能添加，就像小心放置我们不敢翻倒的多米诺骨牌一样。结果让人想起四人组的命令模式或队列。

花点时间来引导你的函子直觉。如果我们看过去的实现细节，我们应该觉得在任何容器上映射都是正确的，无论它的怪癖或特质如何。我们有函子定律，我们将在本章末尾探索，以感谢这种伪精神力量。无论如何，我们终于可以在不牺牲我们宝贵的纯度的情况下玩弄不纯的价值。

现在，我们已经把野兽关在笼子里，但我们仍然需要在某个时候把它放出来。映射我们的“IO”已经建立了一个强大的不纯计算并且运行它肯定会破坏和平。那么我们何时何地可以扣动扳机呢？甚至有可能运行我们的 IO 并且在我们的婚礼上仍然穿着白色吗？答案是肯定的，如果我们把责任放在调用代码上。我们的纯代码，尽管有邪恶的阴谋和诡计，但仍保持其清白，而调用者承担了实际运行效果的责任。让我们看一个例子来具体说明这一点。

```js
// url :: IO String
const url = new IO(() => window.location.href)

// toPairs :: String -> [[String]]
const toPairs = compose(map(split('=')), split('&'))

// params :: String -> [[String]]
const params = compose(toPairs, last, split('?'))

// findParam :: String -> IO Maybe [String]
const findParam = (key) =>
  map(compose(Maybe.of, find(compose(eq(key), head)), params), url)

// -- Impure calling code ----------------------------------------------

// run it by calling $value()!
findParam('searchTerm').$value()
// Just(['searchTerm', 'wafflehouse'])
```

我们的库通过将 `url` 包装在一个 `IO` 中并将其传递给调用者来保持它的手干净。您可能还注意到我们已经堆叠了我们的容器；拥有一个 `IO(Maybe([x]))` 是完全合理的，它是三个函子深（`Array` 绝对是一个可映射的容器类型）并且非常具有表现力。

有件事一直困扰着我，我们应该立即纠正它：`IO` 的 `$value` 并不是它真正包含的值，也不是私有财产。它是手榴弹中的大头针，旨在以最公开的方式由来电者拉动。让我们将此属性重命名为 `unsafePerformIO` 以提醒我们的用户它的波动性。

```js
class IO {
  constructor(io) {
    this.unsafePerformIO = io
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO))
  }
}
```

在那里，好多了。现在我们的调用代码变成了`findParam('searchTerm').unsafePerformIO()`，这对应用程序的用户（和读者）来说是显而易见的。

`IO` 将是一个忠实的伙伴，帮助我们驯服那些野蛮的不纯行为。接下来，我们将看到一种在精神上相似但具有截然不同的用例的类型。

## 异步任务

回调是通往地狱的狭窄螺旋楼梯。它们是由 M.C. 设计的控制流。埃舍尔。随着每个嵌套回调都挤在花括号和括号的丛林健身房之间，它们感觉就像在一个 oubliette 中（我们能走多低？！）。光是想到它们，我就会感到幽闭恐惧症。不用担心，我们有更好的处理异步代码的方法，它以“F”开头。

内部结构有点过于复杂，无法在整个页面上展开，因此我们将使用 Quildreen Motta 的精彩 [Folktale](https://folktale.origamitower.com/) 中的 `Data.Task`（以前称为 `Data.Future`） ）。看一些示例用法：

```js
// -- Node readFile example ------------------------------------------

const fs = require('fs')

// readFile :: String -> Task Error String
const readFile = (filename) =>
  new Task((reject, result) => {
    fs.readFile(filename, (err, data) => (err ? reject(err) : result(data)))
  })

readFile('metamorphosis').map(split('\n')).map(head)
// Task('One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that
// in bed he had been changed into a monstrous verminous bug.')

// -- jQuery getJSON example -----------------------------------------

// getJSON :: String -> {} -> Task Error JSON
const getJSON = curry(
  (url, params) =>
    new Task((reject, result) => {
      $.getJSON(url, params, result).fail(reject)
    }),
)

getJSON('/video', { id: 10 }).map(prop('title'))
// Task('Family Matters ep 15')

// -- Default Minimal Context ----------------------------------------

// We can put normal, non futuristic values inside as well
Task.of(3).map((three) => three + 1)
// Task(4)
```

我调用 `reject` 和 `result` 的函数分别是我们的错误和成功回调。如您所见，我们简单地对“任务”进行“映射”以处理未来值，就好像它就在我们手中一样。现在`map` 应该是旧帽子。

如果您熟悉 promise，您可能会将函数 `map` 识别为 `then`，而 `Task` 扮演我们的 promise 的角色。如果您不熟悉 promise，请不要担心，无论如何我们都不会使用它们，因为它们不纯，但类比仍然成立。

和`IO`一样，`Task`会耐心等待我们给它开绿灯再运行。事实上，因为它等待我们的命令，`IO` 被`Task` 有效地包含在所有异步事物中； `readFile` 和 `getJSON` 不需要额外的 `IO` 容器就可以是纯的。更重要的是，当我们对它进行“映射”时，“任务”以类似的方式工作：我们为未来放置指令，就像时间胶囊中的家务图表 - 一种复杂的技术拖延行为。

要运行我们的 `Task`，我们必须调用方法 `fork`。这与 `unsafePerformIO` 类似，但顾名思义，它会分叉我们的进程并继续评估，而不会阻塞我们的线程。这可以通过线程等以多种方式实现，但在这里它充当正常的异步调用，并且事件循环的大轮子不断转动。让我们看看`fork`：

```js
// -- Pure application -------------------------------------------------
// blogPage :: Posts -> HTML
const blogPage = Handlebars.compile(blogTemplate)

// renderPage :: Posts -> HTML
const renderPage = compose(blogPage, sortBy(prop('date')))

// blog :: Params -> Task Error HTML
const blog = compose(map(renderPage), getJSON('/posts'))

// -- Impure calling code ----------------------------------------------
blog({}).fork(
  (error) => $('#error').html(error.message),
  (page) => $('#main').html(page),
)

$('#spinner').show()
```

在调用 `fork` 后，`Task` 会匆忙寻找一些帖子并渲染页面。同时，我们展示了一个微调器，因为 `fork` 不会等待响应。最后，我们将显示错误或将页面呈现到屏幕上，具体取决于 `getJSON` 调用是否成功。

花点时间考虑一下这里的控制流有多线性。我们只是从下到上，从右到左阅读，即使程序在执行过程中实际上会跳一点。这使得阅读和推理我们的应用程序比不得不在回调和错误处理块之间跳来跳去更简单。

天哪，你看看，‘任务’也吞噬了‘Either’！它必须这样做才能处理未来的故障，因为我们的正常控制流不适用于异步世界。这一切都很好，因为它提供了开箱即用的充分和纯粹的错误处理。

即使有 `Task`，我们的 `IO` 和 `Either` 函子也不会失业。请耐心看一个简单的例子，它倾向于更复杂和更假设的一面，但对于说明目的很有用。

```js
// Postgres.connect :: Url -> IO DbConnection
// runQuery :: DbConnection -> ResultSet
// readFile :: String -> Task Error String

// -- Pure application -------------------------------------------------

// dbUrl :: Config -> Either Error Url
const dbUrl = ({ uname, pass, host, db }) => {
  if (uname && pass && host && db) {
    return Either.of(`db:pg://${uname}:${pass}@${host}5432/${db}`)
  }

  return left(Error('Invalid config!'))
}

// connectDb :: Config -> Either Error (IO DbConnection)
const connectDb = compose(map(Postgres.connect), dbUrl)

// getConfig :: Filename -> Task Error (Either Error (IO DbConnection))
const getConfig = compose(map(compose(connectDb, JSON.parse)), readFile)

// -- Impure calling code ----------------------------------------------

getConfig('db.json').fork(
  logErr("couldn't read file"),
  either(console.log, map(runQuery)),
)
```

在这个例子中，我们仍然使用 `readFile` 的成功分支中的 `Either` 和 `IO`。 `Task` 处理异步读取文件的杂质，但我们仍然处理使用 `Either` 验证配置并使用 `IO` 处理数据库连接。所以你看，我们仍然在做所有同步的事情。

我可以继续，但仅此而已。简单如`map`。

在实践中，您可能会在一个工作流中拥有多个异步任务，而我们还没有获得完整的容器 API 来解决这种情况。不用担心，我们很快就会研究 monad 等，但首先，我们必须检查使这一切成为可能的数学。

## 一个理论点

如前所述，函子来自范畴论并满足一些定律。让我们首先探索这些有用的属性。

```js
// identity
map(id) === id

// composition
compose(map(f), map(g)) === map(compose(f, g))
```

*身份*定律很简单，但很重要。这些定律是可运行的代码段，因此我们可以在自己的函子上尝试它们以验证它们的合法性。

```js
const idLaw1 = map(id)
const idLaw2 = id

idLaw1(Container.of(2)) // Container(2)
idLaw2(Container.of(2)) // Container(2)
```

你看，他们是平等的。接下来让我们看看组成。

```js
const compLaw1 = compose(map(append(' world')), map(append(' cruel')))
const compLaw2 = map(compose(append(' world'), append(' cruel')))

compLaw1(Container.of('Goodbye')) // Container('Goodbye cruel world')
compLaw2(Container.of('Goodbye')) // Container('Goodbye cruel world')
```

在范畴论中，函子取一个范畴的对象和态射，并将它们映射到一个不同的范畴。根据定义，这个新范畴必须有一个身份和组合态射的能力，但我们不需要检查，因为前面提到的定律确保它们被保留。

或许我们对一个类别的定义还有些模糊。您可以将类别视为具有连接它们的态射的对象网络。因此，函子将一个类别映射到另一个类别而不会破坏网络。如果一个对象`a`在我们的源类别`C`中，当我们用函子`F`将它映射到类别`D`时，我们将该对象称为`F a`（如果你把它放在一起，那拼什么？！）。或许，最好看一张图：

<img src="images/catmap.png" alt="类别映射" />

例如，`Maybe` 将我们的类型和函数类别映射到一个类别，其中每个对象可能不存在并且每个态射都有一个 `null` 检查。我们通过用 `map` 包围每个函数并用我们的函子包围每个类型来在代码中实现这一点。我们知道，在这个新世界中，我们的每个正常类型和功能都将继续组成。从技术上讲，我们代码中的每个函子都映射到类型和函数的一个子类别，这使得所有函子都成为一个特定的品牌，称为内函子，但出于我们的目的，我们将其视为不同的类别。

我们还可以使用此图可视化态射及其对应对象的映射：

<img src="images/functormap.png" alt="函子图" />

除了在函子“F”下可视化从一个类别到另一个类别的映射态射之外，我们还看到该图是通勤的，也就是说，如果您沿着箭头走，每条路线都会产生相同的结果。不同的路由意味着不同的行为，但我们总是以相同的类型结束。这种形式主义为我们提供了推理代码的原则性方法——我们可以大胆地应用公式，而无需解析和检查每个单独的场景。让我们举一个具体的例子。

```js
// topRoute :: String -> Maybe String
const topRoute = compose(Maybe.of, reverse)

// bottomRoute :: String -> Maybe String
const bottomRoute = compose(map(reverse), Maybe.of)

topRoute('hi') // Just('ih')
bottomRoute('hi') // Just('ih')
```

或者视觉上：

<img src="images/functormapmaybe.png" alt="函子图2" />

我们可以根据所有函子持有的属性立即查看和重构代码。

函子可以堆叠：

```js
const nested = Task.of([Either.of('pillows'), left('no sleep for you')])

map(map(map(toUpperCase)), nested)
// Task([Right('PILLOWS'), Left('no sleep for you')])
```

我们在这里的 `nested` 是一个未来可能是错误的元素数组。我们`map` 剥离每一层并在元素上运行我们的函数。我们没有看到回调、if/else 或 for 循环；只是一个明确的上下文。但是，我们必须使用`map(map(map(f)))`。我们可以改为组合函子。你没听错：

```js
class Compose {
  constructor(fgx) {
    this.getCompose = fgx
  }

  static of(fgx) {
    return new Compose(fgx)
  }

  map(fn) {
    return new Compose(map(map(fn), this.getCompose))
  }
}

const tmd = Task.of(Maybe.of('Rock over London'))

const ctmd = Compose.of(tmd)

const ctmd2 = map(append(', rock on, Chicago'), ctmd)
// Compose(Task(Just('Rock over London, rock on, Chicago')))

ctmd2.getCompose
// Task(Just('Rock over London, rock on, Chicago'))
```

在那里，一张“地图”。 Functor 组合是关联的，之前我们定义了 `Container`，它实际上被称为 `Identity` 函子。如果我们有恒等和联想组合，我们就有了一个范畴。这个特殊的范畴有范畴是对象，函子是态射，足以让人脑子出汗。我们不会深入探讨这一点，但很高兴能够欣赏到架构的含义，甚至只是模式中简单的抽象美。

＃＃ 总之

我们已经看到了一些不同的函子，但有无穷多个。一些值得注意的遗漏是可迭代的数据结构，如树、列表、地图、对等。事件流和可观察对象都是函子。其他的可以用于封装，甚至只是类型建模。函子无处不在，我们将在整本书中广泛使用它们。

调用具有多个函子参数的函数怎么样？如何处理不纯或异步操作的顺序序列？我们还没有获得在这个封闭的世界中工作的完整工具集。接下来，我们将切入正题，看看 monad。

【第 09 章：一元洋葱】(ch09.md)

## 练习

{％ 锻炼 ％}
使用 `add` 和 `map` 来创建一个在函子内递增值的函数。

{% 初始 src="./exercises/ch08/exercise_a.js#L3;" %}

```js
// incrF :: Functor f => f Int -> f Int
const incrF = undefined
```

{% 解决方案 src="./exercises/ch08/solution_a.js" %}
{% 验证 src="./exercises/ch08/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

给定以下 User 对象：

```js
const user = { id: 2, name: 'Albert', active: true }
```

{％ 锻炼 ％}
使用 `safeProp` 和 `head` 来查找用户的第一个首字母。

{% 初始 src="./exercises/ch08/exercise_b.js#L7;" %}

```js
// initial :: User -> Maybe String
const initial = undefined
```

{% 解决方案 src="./exercises/ch08/solution_b.js" %}
{% 验证 src="./exercises/ch08/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

给定以下辅助函数：

```js
// showWelcome :: User -> String
const showWelcome = compose(concat('Welcome '), prop('name'))

// checkActive :: User -> Either String User
const checkActive = function checkActive(user) {
  return user.active ? Either.of(user) : left('Your account is not active')
}
```

{％ 锻炼 ％}
编写一个函数，使用 `checkActive` 和 `showWelcome` 授予访问权限或返回错误。

{% 初始 src="./exercises/ch08/exercise_c.js#L15;" %}

```js
// eitherWelcome :: User -> Either String String
const eitherWelcome = undefined
```

{% 解决方案 src="./exercises/ch08/solution_c.js" %}
{% 验证 src="./exercises/ch08/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

我们现在考虑以下函数：

```js
// validateUser :: (User -> Either String ()) -> User -> Either String User
const validateUser = curry((validate, user) => validate(user).map((_) => user))

// save :: User -> IO User
const save = (user) => new IO(() => ({ ...user, saved: true }))
```

{％ 锻炼 ％}
编写一个函数 `validateName` 来检查用户的名字是否超过 3 个字符
或返回错误信息。然后使用`either`、`showWelcome`和`save`写一个`register`
当验证正常时注册和欢迎用户的功能。

记住任何一个的两个参数必须返回相同的类型。

{% 初始 src="./exercises/ch08/exercise_d.js#L15;" %}

```js
// validateName :: User -> Either String ()
const validateName = undefined

// register :: User -> IO String
const register = compose(undefined, validateUser(validateName))
```

{% 解决方案 src="./exercises/ch08/solution_d.js" %}
{% 验证 src="./exercises/ch08/validation_d.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
