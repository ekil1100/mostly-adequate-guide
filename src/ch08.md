#第08章：特百惠

##强大的容器

<img src="images/jar.jpg" alt="http://blog.dwinegar.com/2011/06/another-jar.html" /> 

 我们已经看到了如何编写通过一系列纯函数管道数据的程序。它们是行为的声明性规范。但是控制流、错误处理、异步操作、状态以及，我敢说，效果呢？！在本章中，我们将发现构建所有这些有用的抽象的基础。

首先我们将创建一个容器。这个容器必须保存任何类型的值；只能装木薯布丁的拉链锁很少有用。它将是一个对象，但我们不会在 OO 意义上给它属性和方法。不，我们会把它当成一个宝箱——一个特殊的盒子，用来存放我们宝贵的数据。

```js
class Container {
  constructor(x) {
    this.$value = x;
  }
  
  static of(x) {
    return new Container(x);
  }
}
```





```js
Container.of(3);
// Container(3)
%%%% 
Container.of('hotdogs');
// Container("hotdogs")

Container.of(Container.of({ name: 'yoda' }));
// Container(Container({ name: 'yoda' }))
```

这是我们的第一个容器。我们贴心地将其命名为“Container”。我们将使用 `Container.of` 作为构造函数，这样我们就不必到处写那个可怕的 `new` 关键字。 `of` 函数的作用远不止眼前一亮，但就目前而言，将其视为将值放入我们的容器中的正确方法。

% 让我们检查一下我们全新的盒子... 









 



```js
// (a -> b) -> Container a -> Container b
Container.prototype.map = function (f) {
  return Container.of(f(this.$value));
};
```
%%%%在我们继续之前，让我们先弄清楚一些事情：

* `Container` 是一个具有一个属性的对象。许多容器只装一件事，尽管它们不仅限于一件。我们随意将其属性命名为 `$value`。
```js
Container.of(2).map(two => two + 2); 
// Container(4)

Container.of('flamethrowers').map(s => s.toUpperCase()); 
// Container('FLAMETHROWERS')

Container.of('bombs').map(append(' away')).map(prop('length')); 
// Container(10)
```





%%% %为什么，就像 Array 著名的 `map` 一样，只是我们有 `Container a` 而不是 `[a]`。它的工作原理基本相同：







% 



%%%我们可以使用我们的价值而无需离开“容器”。这是一件了不起的事情。我们在 `Container` 中的值被传递给 `map` 函数，因此我们可以对它大惊小怪，然后返回到它的 `Container` 以安全保存。由于从不离开 `Container`，我们可以继续 `map` 离开，随心所欲地运行函数。我们甚至可以像后面三个例子中展示的那样，随着我们继续改变类型。

```js
class Maybe {
  static of(x) {
    return new Maybe(x);
  }

  get isNothing() {
    return this.$value === null || this.$value === undefined;
  }

  constructor(x) {
    this.$value = x;
  }

  map(fn) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
  }

  inspect() {
    return this.isNothing ? 'Nothing' : `Just(${inspect(this.$value)})`;
  }
}
```



```js
Maybe.of('Malkovich Malkovich').map(match(/a/ig));
// Just(True)

Maybe.of(null).map(match(/a/ig));
// Nothing

Maybe.of({ name: 'Boris' }).map(prop('age')).map(add(10));
// Nothing

Maybe.of({ name: 'Dinah', age: 14 }).map(prop('age')).map(add(10));
// Just(24)
```
% 现在，`Maybe` 看起来很像 `Container`，只是做了一个小改动：它会在调用提供的函数之前先检查它是否有值。这具有在我们“映射”时侧步那些讨厌的空值的效果（请注意，此实现是为教学而简化的）。



%%% 
```js
// map :: Functor f => (a -> b) -> f a -> f b
const map = curry((f, anyFunctor) => anyFunctor.map(f));
```







```js
// safeHead :: [a] -> Maybe(a)
const safeHead = xs => Maybe.of(xs[0]);

// streetName :: Object -> Maybe String
const streetName = compose(map(prop('street')), safeHead, prop('addresses'));

streetName({ addresses: [] });
// Nothing

streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] });
// Just('Shady Ln.')
```

 
%注意我们的应用程序不会因错误而爆炸，因为我们将函数映射到我们的空值上。这是因为 `Maybe` 每次应用一个函数时都会小心地检查一个值。

%这个点语法非常好而且功能强大，但是由于第 1 部分中提到的原因， 

```js
// withdraw :: Number -> Account -> Maybe(Account)
const withdraw = curry((amount, { balance }) =>
  Maybe.of(balance >= amount ? { balance: balance - amount } : null));

// This function is hypothetical, not implemented here... nor anywhere else.
// updateLedger :: Account -> Account 
const updateLedger = account => account;

// remainingBalance :: Account -> String
const remainingBalance = ({ balance }) => `Your balance is $${balance}`;

// finishTransaction :: Account -> String
const finishTransaction = compose(remainingBalance, updateLedger);
我们想保持我们的 pointfree 风格。碰巧的是，`map` 完全具备委托给它接收的任何函子的能力：

// getTwenty :: Account -> Maybe(String)
const getTwenty = compose(map(finishTransaction), withdraw(20));

getTwenty({ balance: 200.00 }); 
// Just('Your balance is $180')

getTwenty({ balance: 10.00 });
// Nothing
```







% 



```js
// maybe :: b -> (a -> b) -> Maybe a -> b
const maybe = curry((v, f, m) => {
  if (m.isNothing) {
    return v;
  }
有时一个函数可能会明确返回一个“Nothing”来表示失败。例如：％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％％ 
  return f(m.$value);
});

// getTwenty :: Account -> String
const getTwenty = compose(maybe('You\'re broke!', finishTransaction), withdraw(20));

getTwenty({ balance: 200.00 }); 
// 'Your balance is $180.00'

getTwenty({ balance: 10.00 }); 
// 'You\'re broke!'
```





%%`撤回`会歪着鼻子如果我们缺少现金，请返回“Nothing”。这个函数也传达了它的变化无常，让我们别无选择，只能在事后“映射”一切。不同之处在于这里的 `null` 是故意的。代替`Just(&#39;..&#39;)`，我们得到了`Nothing` 返回信号失败，我们的应用程序有效地停止了它的轨道。需要注意的是：如果`withdraw` 失败，那么`map` 将切断我们剩余的计算，因为它永远不会运行映射函数，即`finishTransaction`。这正是预期的行为，因为如果我们没有成功提取资金，我们不希望更新我们的分类帐或显示新的余额。

##释放价值
 
人们经常错过的一件事是总会有终点；一些有效的函数，可以发送 JSON，或者打印到屏幕上，或者改变我们的文件系统，或者你有什么。我们不能使用 `return` 来传递输出，我们必须运行某个函数或其他函数才能将其发送到世界上。我们可以用禅宗的公案来形容它：“如果一个程序没有可观察到的效果，它甚至会运行吗？”。它是否为了自己的满足而正确运行？我怀疑它只是消耗了一些周期并重新进入睡眠状态...

%我们的应用程序的工作是检索、转换和携带这些数据，直到该说再见的时候了so 可以被映射，因此该值不需要离开其容器的温暖子宫。事实上，一个常见的错误是试图以一种或另一种方式从我们的“也许”中删除价值，好像里面可能的价值会突然实现并且一切都会被原谅。我们必须明白，它可能是代码的一个分支，我们的价值无法实现它的命运。我们的代码，很像薛定谔的猫，同时处于两种状态，并且应该保持这一事实直到最终函数。尽管存在逻辑分支，这为我们的代码提供了线性流程。

% 然而，有一个逃生舱口。如果我们更愿意返回一个自定义值并继续，我们可以使用一个名为 `maybe` 的小助手。



```js
class Either {
  static of(x) {
    return new Right(x);
  }

  constructor(x) {
    this.$value = x;
  }
}

class Left extends Either {
  map(f) {
    return this;
  }

  inspect() {
    return `Left(${inspect(this.$value)})`;
  }
}
编写不安全的软件就像在将鸡蛋投入交通之前小心地用粉彩涂上每个鸡蛋；就像用三只小猪警告过的材料建造养老院一样。在我们的函数中加入一些安全性对我们有好处，“也许”可以帮助我们做到这一点。
class Right extends Either {
  map(f) {
    return Either.of(f(this.$value));
  }
<img src="images/fists.jpg" alt="选择一只手...需要参考" /> 
  inspect() {
    return `Right(${inspect(this.$value)})`;
  }
}

const left = x => new Left(x);
```



```js
Either.of('rain').map(str => `b${str}`); 
// Right('brain')

left('rain').map(str => `It's gonna ${str}, better bring your umbrella!`); 
// Left('rain')

Either.of({ host: 'localhost', port: 80 }).map(prop('host'));
// Right('localhost')

left('rolls eyes...').map(prop('host'));
// Left('rolls eyes...')
```


 


```js
const moment = require('moment');

// getAge :: Date -> User -> Either(String, Number)
const getAge = curry((now, user) => {
  const birthDate = moment(user.birthDate, 'YYYY-MM-DD');

  return birthDate.isValid()
    ? Either.of(now.diff(birthDate, 'years'))
    : left('Birth date could not be parsed');
});

getAge(moment(), { birthDate: '2005-12-12' });
// Right(9)

getAge(moment(), { birthDate: 'July 4, 2001' });
// Left('Birth date could not be parsed')
```
%%% 


```js
// fortune :: Number -> String
const fortune = compose(concat('If you survive, you will be '), toString, add(1));
%%%%`Left`是青少年排序，忽略我们对`map的请求` 在它上面。 `Right` 会像 `Container`（又名 Identity）一样工作。强大的功能来自在“Left”中嵌入错误消息的能力。
// zoltar :: User -> Either(String, _)
const zoltar = compose(map(console.log), map(fortune), getAge(moment()));

zoltar({ birthDate: '2005-12-12' });
// 'If you survive, you will be 10'
// Right(undefined)

zoltar({ birthDate: 'balloons!' });
// Left('Birth date could not be parsed')
```









 

%%%现在，就像“Nothing”一样，当我们返回“Left”时，我们正在短路我们的应用程序。不同之处在于，现在我们知道为什么我们的程序出轨了。需要注意的是，我们返回了 `Either(String, Number)`，它保存了一个 `String` 作为它的左值，一个 `Number` 作为它的 `Right`。这种类型签名有点不正式，因为我们还没有花时间定义实际的“Either”超类，但是，我们从该类型中学到了很多东西。它通知我们，我们要么收到错误消息，要么返回年龄。

```js
// either :: (a -> c) -> (b -> c) -> Either a b -> c
const either = curry((f, g, e) => {
  let result;
%% 
  switch (e.constructor) {
    case Left:
      result = f(e.$value);
      break;

    case Right:
      result = g(e.$value);
      break;

    // No Default
  }
在这个例子中，我们根据出生日期的有效性在逻辑上分支我们的控制流，但它读作从右到左的线性运动，而不是爬过条件语句的花括号。通常，我们会将 `console.log` 移出我们的 `zoltar` 函数并在调用时对其进行 `map`，但了解 `Right` 分支的不同之处会很有帮助。我们在右侧分支的类型签名中使用 `_` 来表示它是一个应该被忽略的值（在某些浏览器中你必须使用 `console.log.bind(console)` 来使用它第一类）。
  return result;
});

// zoltar :: User -> _
const zoltar = compose(console.log, either(id, fortune), getAge(moment()));
%现在，我不禁觉得我把它介绍为对 `Either` 造成了伤害只是一个错误消息的容器。它捕获类型中的逻辑析取（又名`||`）。它还编码了来自范畴论的 *Coproduct* 的概念，本书不会涉及，但非常值得一读，因为有一些属性可以利用。它是规范和类型（或集合的不相交并集），因为它可能的居民数量是两个包含类型的总和（我知道这有点摇摆不定，所以这是一篇 [很棒的文章](https://www.schoolofhaskell) .com/school/to-infinity-and-beyond/pick-of-the-week/sum-types))。 `Either` 可以是很多东西，但作为一个函子，它被用于错误处理。
zoltar({ birthDate: '2005-12-12' });
// 'If you survive, you will be 10'
// undefined

zoltar({ birthDate: 'balloons!' });
// 'Birth date could not be parsed'
// undefined
```

% 







```js
// getFromStorage :: String -> (_ -> String)
const getFromStorage = key => () => localStorage[key];
```





```js
class IO {
  static of(x) {
    return new IO(() => x);
  }

  constructor(fn) {
    this.$value = fn;
  }

  map(fn) {
    return new IO(compose(fn, this.$value));
  }

  inspect() {
    return `IO(${inspect(this.$value)})`;
  }
}
```


如果我们没有在另一个函数中包围它的内脏, `getFromStorage` 会根据外部环境改变其输出。有了坚固的包装器，我们将始终为每个输入获得相同的输出：该函数在调用时将从 `localStorage` 中检索特定项目。就像那样（也许会加入一些万福玛丽）我们已经清除了我们的良心，一切都被原谅了。

%除了，这现在不是特别有用，是吗。就像原始包装中的可收藏动作玩偶一样，我们实际上无法使用它。如果只有一种方法可以到达容器内部并获取其内容...输入“IO”。



%%%% 




```js
// ioWindow :: IO Window
const ioWindow = new IO(() => window);

ioWindow.map(win => win.innerWidth);
// IO(1430)

ioWindow
  .map(prop('location'))
  .map(prop('href'))
  .map(split('/'));
// IO(['http:', '', 'localhost:8000', 'blog', 'posts'])
认为它的`$value`是一个函数，然而——这是一个实现细节，我们最好忽略它。正在发生的事情正是我们在 `getFromStorage` 示例中看到的：`IO`
 通过在函数包装器中捕获它来延迟不纯的操作。因此，我们将 IO 视为包含包装操作的返回值的 
// $ :: String -> IO [DOM]
const $ = selector => new IO(() => document.querySelectorAll(selector));
的假设值作为结果；但是在实践中，你无法知道这个值是什么，直到你
$('#myDiv').map(head).map(div => div.innerHTML);
// IO('I am some inner html')
```
%% 






```js
// url :: IO String
const url = new IO(() => window.location.href);
 
// toPairs :: String -> [[String]]
const toPairs = compose(map(split('=')), split('&'));

// params :: String -> [[String]]
const params = compose(toPairs, last, split('?'));

// findParam :: String -> IO Maybe [String]
const findParam = key => map(compose(Maybe.of, find(compose(eq(key), head)), params), url);

// -- Impure calling code ----------------------------------------------
%%% 在这里，`ioWindow` 是一个实际的 `IO`，我们可以直接对其进行 `map`，而 `$` 是一个在调用后返回一个 `IO` 的函数。我已经写出了 *conceptual* 返回值以更好地表达 `IO`，但实际上，它始终是 `{ $value: [Function] }`。当我们在我们的 IO 上`map` 时，我们将该函数粘贴在组合的末尾，而该组合又变成了新的 `$value`，依此类推。我们的映射函数不会运行，它们会在我们正在构建的计算结束时按功能添加，就像小心放置我们不敢翻倒的多米诺骨牌一样。结果让人想起四人组的命令模式或队列。
// run it by calling $value()!
findParam('searchTerm').$value();
// Just(['searchTerm', 'wafflehouse'])
```





```js
class IO {
  constructor(io) {
    this.unsafePerformIO = io;
  }

  map(fn) {
    return new IO(compose(fn, this.unsafePerformIO));
  }
}
```

 


%%%%我们的库通过将 `url` 包装在 `IO` 中并将责任传递给调用者来保持其手部清洁。您可能还注意到我们已经堆叠了我们的容器；拥有一个 `IO(Maybe([x]))` 是完全合理的，它是三个函子深（`Array` 绝对是一个可映射的容器类型）并且非常具有表现力。

有一直困扰着我的东西，我们应该立即纠正它：`IO` 的`$value` 并不是它真正包含的价值，也不是私有财产。它是手榴弹中的大头针，旨在以最公开的方式由来电者拉动。让我们将此属性重命名为 `unsafePerformIO` 以提醒我们的用户它的波动性。





```js
// -- Node readFile example ------------------------------------------

const fs = require('fs');

// readFile :: String -> Task Error String
const readFile = filename => new Task((reject, result) => {
  fs.readFile(filename, (err, data) => (err ? reject(err) : result(data)));
});
`IO` 将是一个忠实的同伴，帮助我们驯服那些野蛮的不纯行为。接下来，我们将看到一个精神相似的类型，但具有截然不同的用例。
readFile('metamorphosis').map(split('\n')).map(head);
// Task('One morning, as Gregor Samsa was waking up from anxious dreams, he discovered that
// in bed he had been changed into a monstrous verminous bug.')

回调是通往地狱的狭窄螺旋楼梯。它们是由 MC Escher 设计的控制流。随着每个嵌套回调都挤在花括号和括号的丛林健身房之间，它们感觉就像在一个 oubliette 中（我们能走多低？！）。光是想到它们，我就会感到幽闭恐惧症。不用担心，我们有一个更好的处理异步代码的方法，它以“F”开头。
// -- jQuery getJSON example -----------------------------------------
%内部有点太复杂了，无法在整个页面上展开，所以我们将使用 Quildreen Motta 的精彩 [Folktale](https://folktale.origamitower.com/) 中的 `Data.Task`（以前称为 `Data.Future`）。看一些例子用法：
// getJSON :: String -> {} -> Task Error JSON
const getJSON = curry((url, params) => new Task((reject, result) => {
  $.getJSON(url, params, result).fail(reject);
}));

getJSON('/video', { id: 10 }).map(prop('title'));
// Task('Family Matters ep 15')
%%% 

// -- Default Minimal Context ----------------------------------------

// We can put normal, non futuristic values inside as well
Task.of(3).map(three => three + 1);
// Task(4)
```


 






```js
// -- Pure application -------------------------------------------------
// blogPage :: Posts -> HTML
const blogPage = Handlebars.compile(blogTemplate);

// renderPage :: Posts -> HTML
const renderPage = compose(blogPage, sortBy(prop('date')));

// blog :: Params -> Task Error HTML
const blog = compose(map(renderPage), getJSON('/posts'));
% 如果你熟悉 promise，你可能会认出函数 `map` 是 `then`，而 `Task` 扮演我们的 promise 的角色.如果您不熟悉 promise，请不要担心，我们无论如何都不会使用它们，因为它们不纯，但类比仍然成立。

// -- Impure calling code ----------------------------------------------
blog({}).fork(
  error => $('#error').html(error.message),
  page => $('#main').html(page),
);

$('#spinner').show();
```

% 







```js
// Postgres.connect :: Url -> IO DbConnection
// runQuery :: DbConnection -> ResultSet
// readFile :: String -> Task Error String

// -- Pure application -------------------------------------------------
%%在调用`fork`后，`Task`会匆忙寻找一些帖子并渲染页面。同时，我们展示了一个微调器，因为 `fork` 不会等待响应。最后，根据 `getJSON` 调用是否成功，我们将显示错误或将页面渲染到屏幕上。
// dbUrl :: Config -> Either Error Url
const dbUrl = ({ uname, pass, host, db }) => {
  if (uname && pass && host && db) {
    return Either.of(`db:pg://${uname}:${pass}@${host}5432/${db}`);
  }
即使使用 `Task`，我们的 `IO` 和 `Either` 函子也不会失去工作.请看一个简单的例子，它倾向于更复杂和假设的一面，但对于说明目的很有用。
  return left(Error('Invalid config!'));
};

// connectDb :: Config -> Either Error (IO DbConnection)
const connectDb = compose(map(Postgres.connect), dbUrl);

// getConfig :: Filename -> Task Error (Either Error (IO DbConnection))
const getConfig = compose(map(compose(connectDb, JSON.parse)), readFile);


// -- Impure calling code ----------------------------------------------

getConfig('db.json').fork(
  logErr('couldn\'t read file'),
  either(console.log, map(runQuery)),
);
```







 




```js
// identity
map(id) === id;

// composition
compose(map(f), map(g)) === map(compose(f, g));
```

%%%%## 理论点% 
%%%% 正如前面提到的，函子来自范畴论并满足一些定律。我们先来探讨一下这些有用的属性。
```js
const idLaw1 = map(id);
const idLaw2 = id;

idLaw1(Container.of(2)); // Container(2)
idLaw2(Container.of(2)); // Container(2)
```
%% 
%%*身份*法则很简单，但很重要。这些定律是可运行的代码段，因此我们可以在我们自己的函子上尝试它们以验证它们的合法性。

```js
const compLaw1 = compose(map(append(' world')), map(append(' cruel')));
const compLaw2 = map(compose(append(' world'), append(' cruel')));
%%% 
compLaw1(Container.of('Goodbye')); // Container('Goodbye cruel world')
compLaw2(Container.of('Goodbye')); // Container('Goodbye cruel world')
```
%你看，他们是平等的。接下来我们来看看组成。







%% 
%在范畴论中，函子取一个范畴的对象和态射，并将它们映射到不同的范畴。根据定义，这个新的范畴必须有一个恒等式和组合态射的能力，但我们不需要检查，因为前面提到的定律确保它们被保留。

也许我们对一个范畴的定义仍然是有点模糊。您可以将类别视为具有连接它们的态射的对象网络。因此，函子将一个类别映射到另一个类别而不会破坏网络。如果一个对象`a`在我们的源类别`C`中，当我们用函子`F`将它映射到类别`D`时，我们将该对象称为`F a`（如果你把它放在一起，那拼什么？！）。或许，看个图比较好：

<img src="images/catmap.png" alt="映射的类别" /> 

```js
// topRoute :: String -> Maybe String
const topRoute = compose(Maybe.of, reverse);
 
// bottomRoute :: String -> Maybe String
const bottomRoute = compose(map(reverse), Maybe.of);

topRoute('hi'); // Just('ih')
bottomRoute('hi'); // Just('ih')
```









```js
const nested = Task.of([Either.of('pillows'), left('no sleep for you')]);

map(map(map(toUpperCase)), nested);
// Task([Right('PILLOWS'), Left('no sleep for you')])
```
%%<img src="images/functormap.png" alt="函子图" /> 

 除了在函子 `F` 下可视化从一个类别到另一个类别的映射态射，我们看到该图是通勤的，也就是说，如果你按照箭头走，每条路线都会产生同样的结果。不同的路由意味着不同的行为，但我们总是以相同的类型结束。这种形式主义为我们提供了推理代码的原则性方法——我们可以大胆地应用公式，而无需解析和检查每个单独的场景。举个具体的例子。
```js
class Compose {
  constructor(fgx) {
    this.getCompose = fgx;
  }

  static of(fgx) {
    return new Compose(fgx);
  }

  map(fn) {
    return new Compose(map(map(fn), this.getCompose));
  }
}

const tmd = Task.of(Maybe.of('Rock over London'));

const ctmd = Compose.of(tmd);

const ctmd2 = map(append(', rock on, Chicago'), ctmd);
// Compose(Task(Just('Rock over London, rock on, Chicago')))

ctmd2.getCompose;
// Task(Just('Rock over London, rock on, Chicago'))
```
%%%我们这里的`nested`是一个未来的元素数组是错误。我们`map` 剥离每一层并在元素上运行我们的函数。我们没有看到回调、if/else 或 for 循环；只是一个明确的上下文。但是，我们必须使用`map(map(map(f)))`。我们可以改为组合函子。你没听错：







%%%% 









```js  
// incrF :: Functor f => f Int -> f Int  
const incrF = undefined;  
```  




%%%%那里，一张`地图`. Functor 组合是关联的，之前我们定义了 `Container`，它实际上被称为 `Identity` 函子。如果我们有恒等和联想组合，我们就有了一个范畴。这个特殊的范畴有范畴是对象，函子是态射，足以让人脑子出汗。我们不会深入研究这个，但很高兴欣赏架构的含义，甚至只是模式中简单的抽象美。


## 总结%% 
%%%我们已经看到了几个不同的函子，但是有无穷多个。一些值得注意的遗漏是可迭代的数据结构，如树、列表、地图、对等。事件流和可观察对象都是函子。其他的可以用于封装，甚至只是类型建模。函子随处可见，我们将在整本书中广泛使用它们。

调用具有多个函子参数的函数怎么样？如何处理不纯或异步操作的顺序序列？我们还没有获得在这个封闭的世界中工作的完整工具集。接下来，我们将切入正题，看看 monad。

```js  
const user = { id: 2, name: 'Albert', active: true };  
```  

{% 练习 %} 
使用 `add` 和 `map` 来创建一个函数，该函数在函子内增加一个值。 
 
{% 初始 src=&quot;./exercises/ch08/exercise_a.js#L3;&quot; %} 
```js  
// initial :: User -> Maybe String  
const initial = undefined;  
```  

{% solution src=&quot;./exercises/ch08/solution_a.js&quot; %} 
{% 验证 src=&quot;./exercises/ch08/validation_a.js&quot; %} 
{% 上下文 src=&quot;./exercises/support.js&quot; %} 
{ % endexercise %} 


---

 
给定以下用户对象：

```js
// showWelcome :: User -> String
const showWelcome = compose(concat('Welcome '), prop('name'));

// checkActive :: User -> Either String User
const checkActive = function checkActive(user) {
  return user.active
    ? Either.of(user)
    : left('Your account is not active');
};
```





```js
// eitherWelcome :: User -> Either String String
const eitherWelcome = undefined;
```













```js
// validateUser :: (User -> Either String ()) -> User -> Either String User
const validateUser = curry((validate, user) => validate(user).map(_ => user));

// save :: User -> IO User
const save = user => new IO(() => ({ ...user, saved: true }));
```



%%% 


%%% 
{%运动%} 
使用`safeProp`和`head`找到用户的第一个首字母。 
```js
// validateName :: User -> Either String ()
const validateName = undefined;

// register :: User -> IO String
const register = compose(undefined, validateUser(validateName));
```
{% 验证 src=&quot;./exercises/ch08/validation_b.js&quot; %} 
{% 上下文 src=&quot;./exercises/support.js&quot; %} 
{ % endexercise %} 


---


给定以下辅助函数：
%% 









 

%%%{% Exercise %} 
编写一个函数，使用 `checkActive` 和 `showWelcome` 来授予访问权限或返回错误。
%% %%%{% 初始 src=&quot;./exercises/ch08/exercise_c.js#L15;&quot; %} 





%%%%{% solution src=&quot;./exercises/ch08/solution_c .js&quot; %} 
{% 验证 src=&quot;./exercises/ch08/validation_c.js&quot; %} 
{% 上下文 src=&quot;./exercises/support.js&quot; %} % %%%%{% endexercise %} 


---


我们现在考虑以下函数：% 








%%%%{ % 练习 %} 
 编写一个函数`validateName` 来检查用户的名字是否超过 3 个字符
 或返回错误信息。然后使用`either`、`showWelcome`和`save`写一个`register`
函数来注册并在验证正常时欢迎用户。

记住其中之一参数必须返回相同的类型。

{% initial src=&quot;./exercises/ch08/exercise_d.js#L15;&quot; %} 








%% %%{% 解决方案 src=&quot;./exercises/ch08/solution_d.js&quot; %} 
{% 验证 src=&quot;./exercises/ch08/validation_d.js&quot; %} 
{%上下文 src=&quot;./exercises/support.js&quot; %} 
{% endexercise %} 
