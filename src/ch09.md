#第09章：一元洋葱

## Pointy Functor 工厂

在我们进一步讨论之前，我有一个坦白：对于我们在每个类型上放置的 `of` 方法，我并没有完全诚实。事实证明，它不是为了避免使用 `new` 关键字，而是为了将值放置在所谓的 *默认最小上下文 * 中。是的，`of` 实际上并没有取代构造函数——它是我们称为 *Pointed* 的重要接口的一部分。

> 一个 *pointed functor* 是一个带有 `of` 方法的 functor

这里重要的是能够删除我们类型中的任何值并开始映射。

```js
IO.of('tetris').map(concat(' master'));
// IO('tetris master')

Maybe.of(1336).map(add(1));
// Maybe(1337)

Task.of([{ id: 2 }, { id: 3 }]).map(map(prop('id')));
// Task([2,3])

Either.of('The past, present and future walk into a bar...').map(concat('it was tense.'));
// Right('The past, present and future walk into a bar...it was tense.')
```

如果你还记得，`IO` 和 `Task` 的构造函数期望一个函数作为它们的参数，但 `Maybe` 和 `Either` 不需要。这个接口的动机是一种通用的、一致的方法，可以将一个值放入我们的函子中，而没有构造函数的复杂性和特定要求。术语“默认最小上下文”缺乏精确性，但很好地捕捉了这个想法：我们希望按照任何函子的预期行为，按照通常的方式提升我们的类型和 `map` 中的任何值。

在这一点上我必须做的一个重要更正，双关语是，`Left.of` 没有任何意义。每个函子必须有一种方法可以在其中放置一个值，并且使用“Either”，那就是“new Right(x)”。我们使用`Right`定义`of`，因为如果我们的类型*可以*`map`，它*应该*`map`。看看上面的例子，我们应该对 `of` 通常如何工作有一个直觉，而 `Left` 打破了这种模式。

您可能听说过诸如“pure”、“point”、“unit”和“return”之类的函数。这些是我们的“of”方法、神秘的国际功能的各种绰号。当我们开始使用 monad 时，`of` 将变得很重要，因为我们将看到，手动将值放回类型是我们的责任。

为了避免使用 `new` 关键字，有几个标准的 JavaScript 技巧或库，所以让我们从现在开始使用它们并像负责任的成年人一样使用 `of`。我建议使用来自 `folktale`、`ramda` 或 `fantasy-land` 的函子实例，因为它们提供了正确的 `of` 方法以及不依赖于 `new` 的漂亮构造函数。


##混合隐喻

<img src="images/onion.png" alt="onion" />

你看，除了太空卷饼（如果你听过传言），monads 就像洋葱。让我用一个常见的情况来证明：

```js
const fs = require('fs');

// readFile :: String -> IO String
const readFile = filename => new IO(() => fs.readFileSync(filename, 'utf-8'));

// print :: String -> IO String
const print = x => new IO(() => {
  console.log(x);
  return x;
});

// cat :: String -> IO (IO String)
const cat = compose(map(print), readFile);

cat('.git/config');
// IO(IO('[core]\nrepositoryformatversion = 0\n'))
```

我们在这里得到的是一个困在另一个 IO 中的 IO，因为在我们的 map 期间，print 引入了第二个 IO。要继续处理我们的字符串，我们必须`map(map(f))`，为了观察效果，我们必须`unsafePerformIO().unsafePerformIO()`。

```js
// cat :: String -> IO (IO String)
const cat = compose(map(print), readFile);

// catFirstChar :: String -> IO (IO String)
const catFirstChar = compose(map(map(head)), cat);

catFirstChar('.git/config');
// IO(IO('['))
```

虽然很高兴看到我们打包了两个效果并准备好在我们的应用程序中使用，但感觉有点像在两个危险品套装中工作，我们最终得到了一个令人不舒服的尴尬 API。我们再来看另一种情况：

```js
// safeProp :: Key -> {Key: a} -> Maybe a
const safeProp = curry((x, obj) => Maybe.of(obj[x]));

// safeHead :: [a] -> Maybe a
const safeHead = safeProp(0);

// firstAddressStreet :: User -> Maybe (Maybe (Maybe Street))
const firstAddressStreet = compose(
  map(map(safeProp('street'))),
  map(safeHead),
  safeProp('addresses'),
);

firstAddressStreet({
  addresses: [{ street: { name: 'Mulburry', number: 8402 }, postcode: 'WC2N' }],
});
// Maybe(Maybe(Maybe({name: 'Mulburry', number: 8402})))
```

再次，我们看到这种嵌套函子的情况，在我们的函数中很容易看到三种可能的失败，但是期望调用者三次 `map` 来获取值有点冒昧 - 我们只是刚刚遇到。这种模式会一次又一次地出现，这是我们需要将强大的单子符号照亮夜空的主要情况。

我说 monad 就像洋葱，因为当我们用 `map` 剥离嵌套函子的每一层以获得内部值时，眼泪会涌出。我们可以擦干眼睛，深呼吸，使用一种叫做“join”的方法。

```js
const mmo = Maybe.of(Maybe.of('nunchucks'));
// Maybe(Maybe('nunchucks'))

mmo.join();
// Maybe('nunchucks')

const ioio = IO.of(IO.of('pizza'));
// IO(IO('pizza'))

ioio.join();
// IO('pizza')

const ttt = Task.of(Task.of(Task.of('sewers')));
// Task(Task(Task('sewers')));

ttt.join();
// Task(Task('sewers'))
```

如果我们有两个相同类型的层，我们可以用`join`将它们粉碎在一起。这种结合在一起的能力，这种函子婚姻，是使 monad 成为 monad 的原因。让我们用更准确的东西来接近完整的定义：

> Monads 是可以展平的尖函子

任何定义了`join` 方法、具有`of` 方法并遵守一些定律的函子都是monad。定义 `join` 并不太难，所以让我们为 `Maybe` 定义：

```js
Maybe.prototype.join = function join() {
  return this.isNothing() ? Maybe.of(null) : this.$value;
};
```

There, simple as consuming one's twin in the womb. If we have a `Maybe(Maybe(x))` then `.$value` will just remove the unnecessary extra layer and we can safely `map` from there. Otherwise, we'll just have the one `Maybe` as nothing would have been mapped in the first place.

Now that we have a `join` method, let's sprinkle some magic monad dust over the `firstAddressStreet` example and see it in action:

```js
// join :: Monad m => m (m a) -> m a
const join = mma => mma.join();

// firstAddressStreet :: User -> Maybe Street
const firstAddressStreet = compose(
  加入，
  地图（safeProp（'街道'）），
  加入，
  地图（safeHead），safeProp（'地址'），
);

firstAddressStreet({
  addresses: [{ street: { name: 'Mulburry', number: 8402 }, postcode: 'WC2N' }],
});
// Maybe({name: 'Mulburry', number: 8402})
```

We added `join` wherever we encountered the nested `Maybe`'s to keep them from getting out of hand. Let's do the same with `IO` to give us a feel for that.

```js
IO.prototype.join = () => this.unsafePerformIO();
```

同样，我们只是删除了一层。请注意，我们并没有抛弃纯度，只是去除了一层多余的收缩包装。

```js
// log :: a -> IO a
const log = x => new IO(() => {
  console.log(x);
  return x;
});

// setStyle :: Selector -> CSSProps -> IO DOM
const setStyle =
  curry((sel, props) => new IO(() => jQuery(sel).css(props)));

// getItem :: String -> IO String
const getItem = key => new IO(() => localStorage.getItem(key));

// applyPreferences :: String -> IO DOM
const applyPreferences = compose(
  join,
  map(setStyle('#main')),
  join,
  map(log),
  map(JSON.parse),
  getItem,
);

applyPreferences('preferences').unsafePerformIO();
// Object {backgroundColor: "green"}
// <div style="background-color: 'green'"/>
```

`getItem` 返回一个 `IO String`，所以我们用 `map` 来解析它。 `log` 和 `setStyle` 都返回 `IO` 本身，所以我们必须 `join` 来控制我们的嵌套。

## 我的链子撞到我的胸口

<img src="images/chain.jpg" alt="chain" />

您可能已经注意到一种模式。我们经常在“map”之后立即调用“join”。让我们将其抽象为一个名为“chain”的函数。

```js
// chain :: Monad m => (a -> m b) -> m a -> m b
const chain = curry((f, m) => m.map(f).join());

// or

// chain :: Monad m => (a -> m b) -> m a -> m b
const chain = f => compose(join, map(f));
```

我们只是将这个 map/join 组合捆绑到一个函数中。如果您之前阅读过关于 monad 的文章，您可能已经看到名为 `>>=`（发音为 bind）或 `flatMap` 的 `chain`，它们都是同一个概念的别名。我个人认为 `flatMap` 是最准确的名称，但我们会坚持使用 `chain`，因为它是 JS 中被广泛接受的名称。让我们用 `chain` 重构上面的两个例子：

```js
// map/join
const firstAddressStreet = compose(
  join,
  map(safeProp('street')),
  join,
  map(safeHead),
  safeProp('addresses'),
);

// chain
const firstAddressStreet = compose(
  chain(safeProp('street')),
  chain(safeHead),
  safeProp('addresses'),
);

// map/join
const applyPreferences = compose(
  join,
  map(setStyle('#main')),
  join,
  map(log),
  map(JSON.parse),
  getItem,
);

// chain
const applyPreferences = compose(
  chain(setStyle('#main')),
  chain(log),
  map(JSON.parse),
  getItem,
);
```

我用我们新的 `chain` 函数替换了任何 `map/join` 来整理一些东西。清洁度很好，但“连锁”比表面上看的更多 - 它更像是龙卷风而不是真空。因为`chain` 可以毫不费力地嵌套效果，所以我们可以以纯函数方式捕获*序列* 和*变量赋值*。

```js
// getJSON :: Url -> Params -> Task JSON
getJSON('/authenticate', { username: 'stale', password: 'crackers' })
  .chain(user => getJSON('/friends', { user_id: user.id }));
// Task([{name: 'Seimith', id: 14}, {name: 'Ric', id: 39}]);

// querySelector :: Selector -> IO DOM
querySelector('input.username')
  .chain(({ value: uname }) =>
    querySelector('input.email')
      .chain(({ value: email }) => IO.of(`Welcome ${uname} prepare for spam at ${email}`))
  );
// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');

Maybe.of(3)
  .chain(three => Maybe.of(2).map(add(three)));
// Maybe(5);

Maybe.of(null)
  .chain(safeProp('address'))
  .chain(safeProp('street'));
// Maybe(null);
```

我们可以用`compose`来编写这些例子，但是我们需要一些辅助函数，而且这种风格无论如何都可以通过闭包进行显式的变量赋值。相反，我们使用了 `chain` 的中缀版本，顺便说一下，它可以自动从任何类型的 `map` 和 `join` 派生： `t.prototype.chain = function(f) { return this.map(f ）。加入（）; }`。如果我们想要一种错误的性能感，我们也可以手动定义 `chain`，尽管我们必须注意维护正确的功能 - 也就是说，它必须等于 `map` 后跟 `join`。一个有趣的事实是，如果我们创建了 `chain`，只需在完成 `of` 后将值装瓶即可免费派生 `map`。使用 `chain`，我们还可以将 `join` 定义为 `chain(id)`。感觉就像和水钻魔术师玩德州扑克，因为我只是把事情从我的背后拉出来，但是，与大多数数学一样，所有这些原则性结构都是相互关联的。 [fantasyland](https://github.com/fantasyland/fantasy-land) repo 中提到了很多这些派生，这是 JavaScript 中代数数据类型的官方规范。

不管怎样，让我们来看看上面的例子。在第一个示例中，我们看到两个“Task”以一系列异步操作链接在一起——首先它检索“user”，然后找到具有该用户 ID 的朋友。我们使用 `chain` 来避免出现 `Task(Task([Friend]))` 的情况。

接下来，我们使用 `querySelector` 来查找几个不同的输入并创建欢迎消息。请注意我们如何在最内部的函数中同时访问 `uname` 和 `email` - 这是最好的函数变量赋值。由于 IO 慷慨地借给我们它的价值，我们负责将它放回我们发现它的方式 - 我们不想破坏它的信任（和我们的程序）。 `IO.of` 是完成这项工作的完美工具，这就是为什么 Pointed 是 Monad 接口的重要先决条件。但是，我们可以选择`map`，因为这也将返回正确的类型：

```js
querySelector('input.username').chain(({ value: uname }) =>
  querySelector('input.email').map(({ value: email }) =>
    `Welcome ${uname} prepare for spam at ${email}`));
// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');
```

Finally, we have two examples using `Maybe`. Since `chain` is mapping under the hood, if any value is `null`, we stop the computation dead in its tracks.

Don't worry if these examples are hard to grasp at first. Play with them. Poke them with a stick. Smash them to bits and reassemble. Remember to `map` when returning a "normal" value and `chain` when we're returning another functor. In the next chapter, we'll approach `Applicatives` and see nice tricks to make this kind of expressions nicer and highly readable. 

As a reminder, this does not work with two different nested types. Functor composition and later, monad transformers, can help us in that situation.

## Power Trip

Container style programming can be confusing at times. We sometimes find ourselves struggling to understand how many containers deep a value is or if we need `map` or `chain` (soon we'll see more container methods). We can greatly improve debugging with tricks like implementing `inspect` and we'll learn how to create a "stack" that can handle whatever effects we throw at it, but there are times when we question if it's worth the hassle.

I'd like to swing the fiery monadic sword for a moment to exhibit the power of programming this way.

Let's read a file, then upload it directly afterward:

```js
// readFile :: Filename -> Either String (Task Error String)
// httpPost :: String -> String -> Task Error JSON
// upload :: Filename -> Either String (Task Error JSON)
const upload = compose(map(chain(httpPost('/uploads'))), readFile);
```

在这里，我们对代码进行了多次分支。查看类型签名，我可以看到我们可以防止 3 个错误 - `readFile` 使用 `Either` 来验证输入（可能确保文件名存在），`readFile` 在访问文件时可能会出错，如第一种类型所示`Task` 的参数，并且上传可能会因 `httpPost` 中的 `Error` 表示的任何原因而失败。我们随意地使用 `chain` 完成了两个嵌套的、顺序的异步操作。

所有这一切都是在一个从左到右的线性流程中实现的。这一切都是纯粹的和声明性的。它具有等式推理和可靠的特性。我们不会被迫添加不必要的和令人困惑的变量名称。我们的 `upload` 函数是针对通用接口编写的，而不是针对特定的一次性 api。看在上帝的份上，这是一条血线。

相比之下，让我们看看实现这一点的标准命令式方法：

```js
// upload :: Filename -> (String -> a) -> Void
const upload = (filename, callback) => {
  if (!filename) {
    throw new Error('You need a filename!');
  } else {
    readFile(filename, (errF, contents) => {
      if (errF) throw errF;
      httpPost('/uploads', contents, (errH, json) => {
        if (errH) throw errH;
        callback(json);
      });
    });
  }
};
```

Well isn't that the devil's arithmetic. We're pinballed through a volatile maze of madness. Imagine if it were a typical app that also mutated variables along the way! We'd be in the tar pit indeed.

## Theory

The first law we'll look at is associativity, but perhaps not in the way you're used to it.

```js
// associativity
compose(join, map(join)) === compose(join, join);
```

这些定律涉及 monad 的嵌套性质，因此关联性侧重于首先连接内部或外部类型以实现相同的结果。一张图片可能更有启发性：

<img src="images/monad_associativity.png" alt="monad 结合律" />

从左上角向下移动开始，我们可以先“加入”“M(M(M a))”的外部两个“M”，然后再通过另一个“加入”巡航到我们想要的“M a”。或者，我们可以打开引擎盖并使用 `map(join)` 压平内部的两个 `M`。无论我们是先加入内部还是外部的“M”，我们最终都会得到相同的“M a”，这就是结合性的全部内容。值得注意的是`map(join) != join`。中间步骤的值可能不同，但最后一个“join”的最终结果将是相同的。

第二定律类似：

```js
// identity for all (M a)
compose(join, of) === compose(join, map(of)) === id;
```

It states that, for any monad `M`, `of` and `join` amounts to `id`. We can also `map(of)` and attack it from the inside out. We call this "triangle identity" because it makes such a shape when visualized:

<img src="images/triangle_identity.png" alt="monad identity law" />

If we start at the top left heading right, we can see that `of` does indeed drop our `M a` in another `M` container. Then if we move downward and `join` it, we get the same as if we just called `id` in the first place. Moving right to left, we see that if we sneak under the covers with `map` and call `of` of the plain `a`, we'll still end up with `M (M a)` and `join`ing will bring us back to square one.

I should mention that I've just written `of`, however, it must be the specific `M.of` for whatever monad we're using.

Now, I've seen these laws, identity and associativity, somewhere before... Hold on, I'm thinking...Yes of course! They are the laws for a category. But that would mean we need a composition function to complete the definition. Behold:

```js
const mcompose = (f, g) => compose(chain(f), g);

// 左身份
mcompose(M, f) === f;

// 正确的身份
mcompose(f, M) === f;

// associativity
mcompose(mcompose(f, g), h) === mcompose(f, mcompose(g, h));
```

They are the category laws after all. Monads form a category called the "Kleisli category" where all objects are monads and morphisms are chained functions. I don't mean to taunt you with bits and bobs of category theory without much explanation of how the jigsaw fits together. The intention is to scratch the surface enough to show the relevance and spark some interest while focusing on the practical properties we can use each day.


## In Summary

Monads let us drill downward into nested computations. We can assign variables, run sequential effects, perform asynchronous tasks, all without laying one brick in a pyramid of doom. They come to the rescue when a value finds itself jailed in multiple layers of the same type. With the help of the trusty sidekick "pointed", monads are able to lend us an unboxed value and know we'll be able to place it back in when we're done.

Yes, monads are very powerful, yet we still find ourselves needing some extra container functions. For instance, what if we wanted to run a list of api calls at once, then gather the results? We can accomplish this task with monads, but we'd have to wait for each one to finish before calling the next. What about combining several validations? We'd like to continue validating to gather the list of errors, but monads would stop the show after the first `Left` entered the picture.

In the next chapter, we'll see how applicative functors fit into the container world and why we prefer them to monads in many cases.

[Chapter 10: Applicative Functors](ch10.md)


## Exercises


Considering a User object as follow:

```js  
const user = {  
  id: 1,  
  name: 'Albert',  
  address: {  
    street: {  
      number: 22,  
      name: 'Walnut St',  
    },  
  },  
};  
```  
  
{% exercise %}  
Use `safeProp` and `map/join` or `chain` to safely get the street name when given a user  
  
{% initial src="./exercises/ch09/exercise_a.js#L16;" %}  
```js  
// getStreetName :: User -> Maybe String  
const getStreetName = undefined;  
```  
  
  
{% solution src="./exercises/ch09/solution_a.js" %}  
{% validation src="./exercises/ch09/validation_a.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  


---


我们现在考虑以下项目：

```js
// getFile :: IO String
const getFile = IO.of('/home/mostly-adequate/ch09.md');

// pureLog :: String -> IO ()
const pureLog = str => new IO(() => console.log(str));
```

{% exercise %}  
Use getFile to get the filepath, remove the directory and keep only the basename,  
then purely log it. Hint: you may want to use `split` and `last` to obtain the  
basename from a filepath.  
  
{% initial src="./exercises/ch09/exercise_b.js#L13;" %}  
```js  
// logFilename :: IO ()  
const logFilename = undefined;  
  
```  
  
  
{% solution src="./exercises/ch09/solution_b.js" %}  
{% validation src="./exercises/ch09/validation_b.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  


---

For this exercise, we consider helpers with the following signatures:

```js
// validateEmail :: Email -> Either String Email
// addToMailingList :: Email -> IO([Email])
// emailBlast :: [Email] -> IO ()
```

{% exercise %}  
Use `validateEmail`, `addToMailingList` and `emailBlast` to create a function  
which adds a new email to the mailing list if valid, and then notify the whole  
list.  
  
{% initial src="./exercises/ch09/exercise_c.js#L11;" %}  
```js  
// joinMailingList :: Email -> Either String (IO ())  
const joinMailingList = undefined;  
```  
  
  
{% solution src="./exercises/ch09/solution_c.js" %}  
{% validation src="./exercises/ch09/validation_c.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
