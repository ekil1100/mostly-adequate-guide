#第 09 章：一元洋葱

## Pointy Functor 工厂

在我们进一步讨论之前，我有一个坦白：对于我们在每个类型上放置的 `of` 方法，我并没有完全诚实。事实证明，它不是为了避免使用 `new` 关键字，而是为了将值放置在所谓的 _默认最小上下文 _ 中。是的，`of` 实际上并没有取代构造函数——它是我们称为 _Pointed_ 的重要接口的一部分。

> 一个 _pointed functor_ 是一个带有 `of` 方法的 functor

这里重要的是能够删除我们类型中的任何值并开始映射。

```js
IO.of('tetris').map(concat(' master'))
// IO('tetris master')

Maybe.of(1336).map(add(1))
// Maybe(1337)

Task.of([{ id: 2 }, { id: 3 }]).map(map(prop('id')))
// Task([2,3])

Either.of('The past, present and future walk into a bar...').map(
  concat('it was tense.'),
)
// Right('The past, present and future walk into a bar...it was tense.')
```

如果你还记得，`IO` 和 `Task` 的构造函数期望一个函数作为它们的参数，但 `Maybe` 和 `Either` 不需要。这个接口的动机是一种通用的、一致的方法，可以将一个值放入我们的函子中，而没有构造函数的复杂性和特定要求。术语“默认最小上下文”缺乏精确性，但很好地捕捉了这个想法：我们希望按照任何函子的预期行为，按照通常的方式提升我们的类型和 `map` 中的任何值。

在这一点上我必须做的一个重要更正，双关语是，`Left.of` 没有任何意义。每个函子必须有一种方法可以在其中放置一个值，并且使用“Either”，那就是“new Right(x)”。我们使用`Right`定义`of`，因为如果我们的类型*可以*`map`，它*应该*`map`。看看上面的例子，我们应该对 `of` 通常如何工作有一个直觉，而 `Left` 打破了这种模式。

您可能听说过诸如“pure”、“point”、“unit”和“return”之类的函数。这些是我们的“of”方法、神秘的国际功能的各种绰号。当我们开始使用 monad 时，`of` 将变得很重要，因为我们将看到，手动将值放回类型是我们的责任。

为了避免使用 `new` 关键字，有几个标准的 JavaScript 技巧或库，所以让我们从现在开始使用它们并像负责任的成年人一样使用 `of`。我建议使用来自 `folktale`、`ramda` 或 `fantasy-land` 的函子实例，因为它们提供了正确的 `of` 方法以及不依赖于 `new` 的漂亮构造函数。

##混合隐喻

<img src="images/onion.png" alt="onion" />

你看，除了太空卷饼（如果你听过传言），monads 就像洋葱。让我用一个常见的情况来证明：

```js
const fs = require('fs')

// readFile :: String -> IO String
const readFile = (filename) => new IO(() => fs.readFileSync(filename, 'utf-8'))

// print :: String -> IO String
const print = (x) =>
  new IO(() => {
    console.log(x)
    return x
  })

// cat :: String -> IO (IO String)
const cat = compose(map(print), readFile)

cat('.git/config')
// IO(IO('[core]\nrepositoryformatversion = 0\n'))
```

我们在这里得到的是一个困在另一个 IO 中的 IO，因为在我们的 map 期间，print 引入了第二个 IO。要继续处理我们的字符串，我们必须`map(map(f))`，为了观察效果，我们必须`unsafePerformIO().unsafePerformIO()`。

```js
// cat :: String -> IO (IO String)
const cat = compose(map(print), readFile)

// catFirstChar :: String -> IO (IO String)
const catFirstChar = compose(map(map(head)), cat)

catFirstChar('.git/config')
// IO(IO('['))
```

虽然很高兴看到我们打包了两个效果并准备好在我们的应用程序中使用，但感觉有点像在两个危险品套装中工作，我们最终得到了一个令人不舒服的尴尬 API。我们再来看另一种情况：

```js
// safeProp :: Key -> {Key: a} -> Maybe a
const safeProp = curry((x, obj) => Maybe.of(obj[x]))

// safeHead :: [a] -> Maybe a
const safeHead = safeProp(0)

// firstAddressStreet :: User -> Maybe (Maybe (Maybe Street))
const firstAddressStreet = compose(
  map(map(safeProp('street'))),
  map(safeHead),
  safeProp('addresses'),
)

firstAddressStreet({
  addresses: [{ street: { name: 'Mulburry', number: 8402 }, postcode: 'WC2N' }],
})
// Maybe(Maybe(Maybe({name: 'Mulburry', number: 8402})))
```

再次，我们看到这种嵌套函子的情况，在我们的函数中很容易看到三种可能的失败，但是期望调用者三次 `map` 来获取值有点冒昧 - 我们只是刚刚遇到。这种模式会一次又一次地出现，这是我们需要将强大的单子符号照亮夜空的主要情况。

我说 monad 就像洋葱，因为当我们用 `map` 剥离嵌套函子的每一层以获得内部值时，眼泪会涌出。我们可以擦干眼睛，深呼吸，使用一种叫做“join”的方法。

```js
const mmo = Maybe.of(Maybe.of('nunchucks'))
// Maybe(Maybe('nunchucks'))

mmo.join()
// Maybe('nunchucks')

const ioio = IO.of(IO.of('pizza'))
// IO(IO('pizza'))

ioio.join()
// IO('pizza')

const ttt = Task.of(Task.of(Task.of('sewers')))
// Task(Task(Task('sewers')));

ttt.join()
// Task(Task('sewers'))
```

如果我们有两个相同类型的层，我们可以用`join`将它们粉碎在一起。这种结合在一起的能力，这种函子婚姻，是使 monad 成为 monad 的原因。让我们用更准确的东西来接近完整的定义：

> Monads 是可以展平的尖函子

任何定义了`join` 方法、具有`of` 方法并遵守一些定律的函子都是 monad。定义 `join` 并不太难，所以让我们为 `Maybe` 定义：

```js
Maybe.prototype.join = function join() {
  return this.isNothing() ? Maybe.of(null) : this.$value
}
```

在那里，就像在子宫里吃掉一个人的双胞胎一样简单。如果我们有一个`Maybe(Maybe(x))`，那么`.$value` 将删除不必要的额外层，我们可以从那里安全地`map`。否则，我们将只有一个 `Maybe`，因为一开始什么都不会被映射。

现在我们有了一个 `join` 方法，让我们在 `firstAddressStreet` 示例上撒一些神奇的 monad 灰尘，看看它的实际效果：

```js
// join :: Monad m => m (m a) -> m a
const join = (mma) => mma.join()

// firstAddressStreet :: User -> Maybe Street
const firstAddressStreet = compose(
  join,
  map(safeProp('street')),
  join,
  map(safeHead),
  safeProp('addresses'),
)

firstAddressStreet({
  addresses: [{ street: { name: 'Mulburry', number: 8402 }, postcode: 'WC2N' }],
})
// Maybe({name: 'Mulburry', number: 8402})
```

我们在遇到嵌套的“Maybe”的地方添加了“join”，以防止它们失控。让我们对 `IO` 做同样的事情，让我们感受一下。

```js
IO.prototype.join = () => this.unsafePerformIO()
```

同样，我们只是删除了一层。请注意，我们并没有抛弃纯度，只是去除了一层多余的收缩包装。

```js
// log :: a -> IO a
const log = (x) =>
  new IO(() => {
    console.log(x)
    return x
  })

// setStyle :: Selector -> CSSProps -> IO DOM
const setStyle = curry((sel, props) => new IO(() => jQuery(sel).css(props)))

// getItem :: String -> IO String
const getItem = (key) => new IO(() => localStorage.getItem(key))

// applyPreferences :: String -> IO DOM
const applyPreferences = compose(
  join,
  map(setStyle('#main')),
  join,
  map(log),
  map(JSON.parse),
  getItem,
)

applyPreferences('preferences').unsafePerformIO()
// Object {backgroundColor: "green"}
// <div style="background-color: 'green'"/>
```

`getItem` 返回一个 `IO String`，所以我们用 `map` 来解析它。 `log` 和 `setStyle` 都返回 `IO` 本身，所以我们必须 `join` 来控制我们的嵌套。

## 我的链子撞到我的胸口

<img src="images/chain.jpg" alt="chain" />

您可能已经注意到一种模式。我们经常在“map”之后立即调用“join”。让我们将其抽象为一个名为“chain”的函数。

```js
// chain :: Monad m => (a -> m b) -> m a -> m b
const chain = curry((f, m) => m.map(f).join())

// or

// chain :: Monad m => (a -> m b) -> m a -> m b
const chain = (f) => compose(join, map(f))
```

我们只是将这个 map/join 组合捆绑到一个函数中。如果您之前阅读过关于 monad 的文章，您可能已经看到名为 `>>=`（发音为 bind）或 `flatMap` 的 `chain`，它们都是同一个概念的别名。我个人认为 `flatMap` 是最准确的名称，但我们会坚持使用 `chain`，因为它是 JS 中被广泛接受的名称。让我们用 `chain` 重构上面的两个例子：

```js
// map/join
const firstAddressStreet = compose(
  join,
  map(safeProp('street')),
  join,
  map(safeHead),
  safeProp('addresses'),
)

// chain
const firstAddressStreet = compose(
  chain(safeProp('street')),
  chain(safeHead),
  safeProp('addresses'),
)

// map/join
const applyPreferences = compose(
  join,
  map(setStyle('#main')),
  join,
  map(log),
  map(JSON.parse),
  getItem,
)

// chain
const applyPreferences = compose(
  chain(setStyle('#main')),
  chain(log),
  map(JSON.parse),
  getItem,
)
```

我用我们新的 `chain` 函数替换了任何 `map/join` 来整理一些东西。清洁度很好，但“连锁”比表面上看的更多 - 它更像是龙卷风而不是真空。因为`chain` 可以毫不费力地嵌套效果，所以我们可以以纯函数方式捕获*序列* 和*变量赋值*。

```js
// getJSON :: Url -> Params -> Task JSON
getJSON('/authenticate', {
  username: 'stale',
  password: 'crackers',
}).chain((user) => getJSON('/friends', { user_id: user.id }))
// Task([{name: 'Seimith', id: 14}, {name: 'Ric', id: 39}]);

// querySelector :: Selector -> IO DOM
querySelector('input.username').chain(({ value: uname }) =>
  querySelector('input.email').chain(({ value: email }) =>
    IO.of(`Welcome ${uname} prepare for spam at ${email}`),
  ),
)
// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');

Maybe.of(3).chain((three) => Maybe.of(2).map(add(three)))
// Maybe(5);

Maybe.of(null).chain(safeProp('address')).chain(safeProp('street'))
// Maybe(null);
```

我们可以用`compose`来编写这些例子，但是我们需要一些辅助函数，而且这种风格无论如何都可以通过闭包进行显式的变量赋值。相反，我们使用了 `chain` 的中缀版本，顺便说一下，它可以自动从任何类型的 `map` 和 `join` 派生： `t.prototype.chain = function(f) { return this.map(f ）。加入（）; }`。如果我们想要一种错误的性能感，我们也可以手动定义 `chain`，尽管我们必须注意维护正确的功能 - 也就是说，它必须等于 `map` 后跟 `join`。一个有趣的事实是，如果我们创建了 `chain`，只需在完成 `of` 后将值装瓶即可免费派生 `map`。使用 `chain`，我们还可以将 `join` 定义为 `chain(id)`。感觉就像和水钻魔术师玩德州扑克，因为我只是把事情从我的背后拉出来，但是，与大多数数学一样，所有这些原则性结构都是相互关联的。 [fantasyland](https://github.com/fantasyland/fantasy-land) repo 中提到了很多这些派生，这是 JavaScript 中代数数据类型的官方规范。

不管怎样，让我们来看看上面的例子。在第一个示例中，我们看到两个“Task”以一系列异步操作链接在一起——首先它检索“user”，然后找到具有该用户 ID 的朋友。我们使用 `chain` 来避免出现 `Task(Task([Friend]))` 的情况。

接下来，我们使用 `querySelector` 来查找几个不同的输入并创建欢迎消息。请注意我们如何在最内部的函数中同时访问 `uname` 和 `email` - 这是最好的函数变量赋值。由于 IO 慷慨地借给我们它的价值，我们负责将它放回我们发现它的方式 - 我们不想破坏它的信任（和我们的程序）。 `IO.of` 是完成这项工作的完美工具，这就是为什么 Pointed 是 Monad 接口的重要先决条件。但是，我们可以选择`map`，因为这也将返回正确的类型：

```js
querySelector('input.username').chain(({ value: uname }) =>
  querySelector('input.email').map(
    ({ value: email }) => `Welcome ${uname} prepare for spam at ${email}`,
  ),
)
// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');
```

最后，我们有两个使用“Maybe”的例子。由于 `chain` 在底层映射，如果任何值为 `null`，我们就会停止计算。

如果这些示例一开始难以理解，请不要担心。和他们一起玩。用棍子戳他们。将它们粉碎成碎片并重新组装。记住在返回“正常”值时使用 `map`，当我们返回另一个函子时使用 `chain`。在下一章中，我们将接近 `Applicatives` 并看到一些很好的技巧来使这种表达式更好、更易读。

提醒一下，这不适用于两种不同的嵌套类型。在这种情况下，函子组合以及后来的 monad 转换器可以帮助我们。

## 电力旅行

容器风格的编程有时会令人困惑。我们有时会发现自己很难理解一个值有多少个容器深，或者我们是否需要 `map` 或 `chain`（很快我们就会看到更多的容器方法）。我们可以使用诸如实现 `inspect` 之类的技巧来极大地改进调试，并且我们将学习如何创建一个“堆栈”来处理我们抛出的任何效果，但有时我们会质疑是否值得麻烦。

我想挥动火热的一元剑，以这种方式展示编程的力量。

让我们读取一个文件，然后直接上传它：

```js
// readFile :: Filename -> Either String (Task Error String)
// httpPost :: String -> String -> Task Error JSON
// upload :: Filename -> Either String (Task Error JSON)
const upload = compose(map(chain(httpPost('/uploads'))), readFile)
```

在这里，我们对代码进行了多次分支。查看类型签名，我可以看到我们可以防止 3 个错误 - `readFile` 使用 `Either` 来验证输入（可能确保文件名存在），`readFile` 在访问文件时可能会出错，如第一种类型所示`Task` 的参数，并且上传可能会因 `httpPost` 中的 `Error` 表示的任何原因而失败。我们随意地使用 `chain` 完成了两个嵌套的、顺序的异步操作。

所有这一切都是在一个从左到右的线性流程中实现的。这一切都是纯粹的和声明性的。它具有等式推理和可靠的特性。我们不会被迫添加不必要的和令人困惑的变量名称。我们的 `upload` 函数是针对通用接口编写的，而不是针对特定的一次性 api。看在上帝的份上，这是一条血线。

相比之下，让我们看看实现这一点的标准命令式方法：

```js
// upload :: Filename -> (String -> a) -> Void
const upload = (filename, callback) => {
  if (!filename) {
    throw new Error('You need a filename!')
  } else {
    readFile(filename, (errF, contents) => {
      if (errF) throw errF
      httpPost('/uploads', contents, (errH, json) => {
        if (errH) throw errH
        callback(json)
      })
    })
  }
}
```

好吧，这不是魔鬼的算术。我们在一个多变的疯狂迷宫中穿梭。想象一下，如果它是一个典型的应用程序，也会在此过程中改变变量！我们确实会在焦油坑中。

＃＃ 理论

我们要研究的第一条定律是结合性，但可能与您习惯的方式不同。

```js
// associativity
compose(join, map(join)) === compose(join, join)
```

这些定律涉及 monad 的嵌套性质，因此关联性侧重于首先连接内部或外部类型以实现相同的结果。一张图片可能更有启发性：

<img src="images/monad_associativity.png" alt="monad 结合律" />

从左上角向下移动开始，我们可以先“加入”“M(M(M a))”的外部两个“M”，然后再通过另一个“加入”巡航到我们想要的“M a”。或者，我们可以打开引擎盖并使用 `map(join)` 压平内部的两个 `M`。无论我们是先加入内部还是外部的“M”，我们最终都会得到相同的“M a”，这就是结合性的全部内容。值得注意的是`map(join) != join`。中间步骤的值可能不同，但最后一个“join”的最终结果将是相同的。

第二定律类似：

```js
// identity for all (M a)
;(compose(join, of) === compose(join, map(of))) === id
```

它指出，对于任何 monad `M`、`of` 和 `join` 等于 `id`。我们也可以`map(of)`并从内向外攻击它。我们称之为“三角形标识”，因为它在可视化时会形成这样的形状：

<img src="images/triangle_identity.png" alt="monad 身份法" />

如果我们从左上角开始，我们可以看到 `of` 确实将我们的 `M a` 放入另一个 `M` 容器中。然后如果我们向下移动并`join`它，我们得到的结果就像我们刚开始调用`id`一样。从右到左移动，我们看到如果我们用 `map` 潜入掩体并调用普通 `a` 的 `of`，我们仍然会得到 `M (M a)` 并且 `join`ing 会带我们回到第一广场。

我应该提到我刚刚写了 `of`，但是，对于我们正在使用的任何 monad，它必须是特定的 `M.of`。

现在，我以前在某处见过这些定律、恒等式和结合性……等等，我在想……当然是的！它们是一个类别的法则。但这意味着我们需要一个组合函数来完成定义。看：

```js
const mcompose = (f, g) => compose(chain(f), g)

// left identity
mcompose(M, f) === f

// right identity
mcompose(f, M) === f

// associativity
mcompose(mcompose(f, g), h) === mcompose(f, mcompose(g, h))
```

毕竟它们是范畴法则。 Monad 形成了一个称为“Kleisli 类别”的类别，其中所有对象都是 monad，态射是链式函数。我并不是要在不解释拼图如何组合在一起的情况下用范畴论的点点滴滴来嘲笑你。其目的是触及足够的表面以显示相关性并激发一些兴趣，同时专注于我们每天可以使用的实际属性。

＃＃ 总之

Monads 让我们深入研究嵌套计算。我们可以分配变量、运行顺序效果、执行异步任务，所有这些都无需在末日金字塔中铺设一块砖。当一个值发现自己被囚禁在同一类型的多个层中时，它们就会出手相救。在可信赖的伙伴“pointed”的帮助下，monads 能够借给我们一个未装箱的值，并且知道我们可以在完成后将其放回原处。

是的，monad 非常强大，但我们仍然发现自己需要一些额外的容器功能。例如，如果我们想一次运行一个 api 调用列表，然后收集结果怎么办？我们可以用 monad 来完成这个任务，但是我们必须等待每一个完成后再调用下一个。结合几个验证怎么样？我们想继续验证以收集错误列表，但是在第一个“Left”进入图片后，monads 会停止显示。

在下一章中，我们将看到应用函子如何融入容器世界，以及为什么在许多情况下我们更喜欢它们而不是 monad。

【第十章：应用函子】(ch10.md)

## 练习

考虑一个 User 对象如下：

```js
const user = {
  id: 1,
  name: 'Albert',
  address: {
    street: {
      number: 22,
      name: 'Walnut St',
    },
  },
}
```

{％ 锻炼 ％}
当给定用户时，使用 `safeProp` 和 `map/join` 或 `chain` 来安全地获取街道名称

{% 初始 src="./exercises/ch09/exercise_a.js#L16;" %}

```js
// getStreetName :: User -> Maybe String
const getStreetName = undefined
```

{% 解决方案 src="./exercises/ch09/solution_a.js" %}
{% 验证 src="./exercises/ch09/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

我们现在考虑以下项目：

```js
// getFile :: IO String
const getFile = IO.of('/home/mostly-adequate/ch09.md')

// pureLog :: String -> IO ()
const pureLog = (str) => new IO(() => console.log(str))
```

{％ 锻炼 ％}
使用 getFile 获取文件路径，删除目录并仅保留基本名称，
然后纯粹记录它。提示：你可能想使用 `split` 和 `last` 来获得
来自文件路径的基本名称。

{% 初始 src="./exercises/ch09/exercise_b.js#L13;" %}

```js
// logFilename :: IO ()
const logFilename = undefined
```

{% 解决方案 src="./exercises/ch09/solution_b.js" %}
{% 验证 src="./exercises/ch09/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

在本练习中，我们考虑具有以下签名的助手：

```js
// validateEmail :: Email -> Either String Email
// addToMailingList :: Email -> IO([Email])
// emailBlast :: [Email] -> IO ()
```

{％ 锻炼 ％}
使用 `validateEmail`、`addToMailingList` 和 `emailBlast` 创建一个函数
如果有效，则将新电子邮件添加到邮件列表中，然后通知整个
列表。

{% 初始 src="./exercises/ch09/exercise_c.js#L11;" %}

```js
// joinMailingList :: Email -> Either String (IO ())
const joinMailingList = undefined
```

{% 解决方案 src="./exercises/ch09/solution_c.js" %}
{% 验证 src="./exercises/ch09/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
