# 第 01 章：我们在做什么？

## 介绍

你好呀！我是富兰克林·弗里斯比教授。很高兴认识你。我们将花一些时间在一起，因为我应该教你一些关于函数式编程的知识。但关于我已经足够了，你呢？我希望你至少有点熟悉 JavaScript 语言，有一点面向对象的经验，并幻想自己是一个工人阶级的程序员。你不需要拥有昆虫学博士学位，你只需要知道如何发现和杀死一些虫子。

我不会假设您以前有任何函数式编程知识，因为我们都知道当您假设时会发生什么。但是，我希望您在处理可变状态、无限制副作用和无原则设计时遇到一些不利情况。现在我们已经正确介绍了，让我们继续吧。

本章的目的是让您了解我们在编写函数式程序时所追求的是什么。为了能够理解接下来的章节，我们必须对什么使程序具有*功能*有所了解。否则我们会发现自己漫无目的地乱涂乱画，不惜一切代价避开物体——这确实是一种笨拙的努力。我们需要一个清晰的靶心来投掷我们的代码，一些天体指南针，当水变得粗糙时。

现在，有一些通用的编程原则——各种首字母缩略词指导我们穿越任何应用程序的黑暗隧道：DRY（不要重复自己）、YAGNI（你不需要它）、松耦合高内聚、原则最不令人惊讶的是，单一的责任，等等。

我不会通过列出多年来我听到的每一条准则来打扰您......问题的关键是它们在功能设置中保持不变，尽管它们只是与我们的最终目标相切。在我们进一步讨论之前，我希望你现在能感受一下，当我们戳键盘时，我们的意图是什么；我们的功能世外桃源。

<!--BREAK-->

## 短暂的相遇

让我们从一点点疯狂开始吧。这是一个海鸥应用程序。当一群群结合在一起时，它们会变成一个更大的群，当它们繁殖时，它们会随着与它们一起繁殖的海鸥的数量而增加。现在，这不是一个好的面向对象代码，请注意，它在这里强调我们现代的、基于赋值的方法的危险。看：

```js
class Flock {
  constructor(n) {
    this.seagulls = n
  }

  conjoin(other) {
    this.seagulls += other.seagulls
    return this
  }

  breed(other) {
    this.seagulls = this.seagulls * other.seagulls
    return this
  }
}

const flockA = new Flock(4)
const flockB = new Flock(2)
const flockC = new Flock(0)
const result = flockA
  .conjoin(flockC)
  .breed(flockB)
  .conjoin(flockA.breed(flockB)).seagulls
// 32
```

到底谁会制作出如此可怕的可憎之物？跟踪变异的内部状态非常困难。而且，天哪，答案甚至是不正确的！它应该是 `16`，但是 `flockA` 在这个过程中被永久改变了。可怜的`flockA`。这是 IT 的无政府状态！这是野兽算术！

如果你不理解这个程序，没关系，我也不理解。这里要记住的一点是，即使在这么小的例子中，状态和可变值也很难理解。

让我们再试一次，这次使用更实用的方法：

```js
const conjoin = (flockX, flockY) => flockX + flockY
const breed = (flockX, flockY) => flockX * flockY

const flockA = 4
const flockB = 2
const flockC = 0
const result = conjoin(
  breed(flockB, conjoin(flockA, flockC)),
  breed(flockA, flockB),
)
// 16
```

嗯，这次我们得到了正确的答案。用更少的代码。函数嵌套有点令人困惑……（我们将在 ch5 中纠正这种情况）。它更好，但让我们深入挖掘一下。直言不讳是有好处的。如果我们更仔细地检查我们的自定义函数，我们会发现我们只是在处理简单的加法（`conjoin`）和乘法（`breed`）。

除了名称之外，这两个函数实际上没有什么特别之处。让我们将自定义函数重命名为 `multiply` 和 `add`，以显示它们的真实身份。

```js
const add = (x, y) => x + y
const multiply = (x, y) => x * y

const flockA = 4
const flockB = 2
const flockC = 0
const result = add(
  multiply(flockB, add(flockA, flockC)),
  multiply(flockA, flockB),
)
// 16
```

有了这个，我们获得了古人的知识：

```js
// associative
add(add(x, y), z) === add(x, add(y, z))

// commutative
add(x, y) === add(y, x)

// identity
add(x, 0) === x

// distributive
multiply(x, add(y, z)) === add(multiply(x, y), multiply(x, z))
```

啊，是的，那些忠实的旧数学属性应该派上用场。如果您一开始不认识它们，请不要担心。对于我们很多人来说，我们已经有一段时间没有了解这些算术定律了。让我们看看我们是否可以使用这些属性来简化我们的小海鸥程序。

```js
// Original line
add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB))

// Apply the identity property to remove the extra add
// (add(flockA, flockC) == flockA)
add(multiply(flockB, flockA), multiply(flockA, flockB))

// Apply distributive property to achieve our result
multiply(flockB, add(flockA, flockA))
```

杰出的！除了调用函数之外，我们无需编写任何自定义代码。为了完整起见，我们在这里包含了 `add` 和 `multiply` 定义，但实际上没有必要编写它们 - 我们肯定有一些现有库提供的 `add` 和 `multiply`。

你可能会想“你把这样一个数学例子放在前面是多么的稻草人”。或者“真正的程序不是那么简单，不能以这种方式推理。”我选择这个例子是因为我们大多数人已经知道加法和乘法，所以在这里很容易看出数学对我们来说非常有用。

不要绝望——在这本书中，我们将加入一些范畴论、集合论和 lambda 演算，并编写现实世界的例子，这些例子实现了与我们的一群海鸥例子一样优雅的简单性和结果。你也不必是数学家。它会感觉自然而轻松，就像您使用“普通”框架或 API 一样。

听到我们可以按照上面的功能模拟来编写完整的日常应用程序，这可能会让人感到惊讶。具有声音属性的程序。程序简洁，但易于推理。不会每次都重新发明轮子的程序。如果您是罪犯，无法无天是件好事，但在本书中，我们将承认并遵守数学定律。

我们将要使用这样一种理论，即每个部分都倾向于如此礼貌地组合在一起。我们希望用通用的、可组合的位来表示我们的特定问题，然后利用它们的属性为我们自己谋取私利。它比命令式编程的“任何事情都行”方法需要更多的纪律（我们将在本书后面详细介绍“命令式”的精确定义，但现在考虑除函数式编程之外的任何其他内容）。在有原则的数学框架内工作的回报会让您大吃一惊。

我们已经看到了我们功能性北极星的闪烁，但在我们真正开始我们的旅程之前，还有一些具体的概念需要掌握。

【第 02 章：一级函数】(ch02.md)
