# 第01章：我们在做什么？

## 介绍

你好呀！我是富兰克林·弗里斯比教授。很高兴认识你。我们将花一些时间在一起，因为我应该教你一些关于函数式编程的知识。但关于我已经足够了，你呢？我希望你至少有点熟悉 JavaScript 语言，有一点面向对象的经验，并幻想自己是一个工人阶级的程序员。你不需要拥有昆虫学博士学位，你只需要知道如何发现和杀死一些虫子。

我不会假设您以前有任何函数式编程知识，因为我们都知道当您假设时会发生什么。但是，我希望您在处理可变状态、无限制副作用和无原则设计时遇到一些不利情况。现在我们已经正确介绍了，让我们继续吧。

本章的目的是让您了解我们在编写函数式程序时所追求的是什么。为了能够理解接下来的章节，我们必须对什么使程序具有*功能*有所了解。否则我们会发现自己漫无目的地乱涂乱画，不惜一切代价避开物体——这确实是一种笨拙的努力。我们需要一个清晰的靶心来投掷我们的代码，一些天体指南针，当水变得粗糙时。

现在，有一些通用的编程原则——各种首字母缩略词指导我们穿越任何应用程序的黑暗隧道：DRY（不要重复自己）、YAGNI（你不需要它）、松耦合高内聚、原则最不令人惊讶的是，单一的责任，等等。

我不会通过列出多年来我听到的每一条准则来打扰您......问题的关键是它们在功能设置中保持不变，尽管它们只是与我们的最终目标相切。在我们进一步讨论之前，我希望你现在能感受一下，当我们戳键盘时，我们的意图是什么；我们的功能世外桃源。

<!--BREAK-->

## 短暂的相遇

让我们从一点点疯狂开始吧。这是一个海鸥应用程序。当一群群结合在一起时，它们会变成一个更大的群，当它们繁殖时，它们会随着与它们一起繁殖的海鸥的数量而增加。现在，这不是一个好的面向对象代码，请注意，它在这里强调我们现代的、基于赋值的方法的危险。看：

```js
class Flock {
  constructor(n) {
    this.seagulls = n;
  }

  conjoin(other) {
    this.seagulls += other.seagulls;
    return this;
  }

  breed(other) {
    this.seagulls = this.seagulls * other.seagulls;
    return this;
  }
}

const flockA = new Flock(4);
const flockB = new Flock(2);
const flockC = new Flock(0);
const result = flockA
  .conjoin(flockC)
  .breed(flockB)
  .conjoin(flockA.breed(flockB))
  .seagulls;
// 32
```

我们已经看到了我们功能性北极星的闪烁，但在我们真正开始我们的旅程之前，还有一些具体的概念需要掌握。

【第02章：一级函数】(ch02.md)
