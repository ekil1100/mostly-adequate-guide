#第07章：欣德利-米尔纳和我

##你的类型是什么？
如果您是函数式世界的新手，用不了多久您就会发现自己深陷类型签名中。类型是一种元语言，它使来自不同背景的人们能够简洁有效地进行交流。大多数情况下，它们是用一个名为“Hindley-Milner”的系统编写的，我们将在本章中一起研究。

使用纯函数时，类型签名具有英语语言无法比拟的表达能力。这些签名在您耳边低语着功能的私密秘密。在一个单一的、紧凑的线条中，它们暴露了行为和意图。我们可以从中推导出“自由定理”。可以推断类型，因此不需要显式类型注释。它们可以调整为精细点精度或保留一般性和抽象性。它们不仅对编译时检查很有用，而且还是最好的可用文档。因此，类型签名在函数式编程中扮演着重要的角色——比你最初想象的要多得多。

JavaScript 是一种动态语言，但这并不意味着我们都避免使用类型。我们仍在处理字符串、数字、布尔值等。只是没有任何语言级别的集成，因此我们将这些信息牢记在心。不用担心，因为我们在文档中使用签名，所以我们可以使用注释来达到我们的目的。

JavaScript 有可用的类型检查工具，例如 [Flow](https://flow.org/) 或类型化方言 [TypeScript](https://www.typescriptlang.org/)。本书的目的是为人们配备编写函数式代码的工具，因此我们将坚持使用跨 FP 语言使用的标准类型系统。


##来自神秘的故事

从满是灰尘的数学书页、浩瀚的白皮书海洋、周六早上随意的博客文章，到源代码本身，我们找到了 Hindley-Milner 类型的签名。该系统非常简单，但需要快速解释和一些练习以充分吸收这门小语言。

```js
// capitalize :: String -> String
const capitalize = s => toUpperCase(head(s)) + toLowerCase(tail(s));

capitalize('smurf'); // 'Smurf'
```

这里，`capitalize` 接受一个 `String` 并返回一个 `String`。没关系实现，这是我们感兴趣的类型签名。

在 HM 中，函数被写成 `a -> b`，其中 `a` 和 `b` 是任何类型的变量。所以`capitalize` 的签名可以理解为“一个从`String` 到`String` 的函数”。换句话说，它接受一个 `String` 作为它的输入并返回一个 `String` 作为它的输出。

让我们看看更多的函数签名：

```js
// strLength :: String -> Number
const strLength = s => s.length;

// join :: String -> [String] -> String
const join = curry((what, xs) => xs.join(what));

// match :: Regex -> String -> [String]
const match = curry((reg, s) => s.match(reg));

// replace :: Regex -> String -> String -> String
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

`strLength` 与之前的想法相同：我们接受一个 `String` 并返回一个 `Number`。

乍一看，其他人可能会让您感到困惑。在没有完全理解细节的情况下，您总是可以将最后一个类型视为返回值。所以对于`match`，你可以解释为：它需要一个`Regex`和一个`String`，并返回`[String]`。但是这里发生了一件有趣的事情，如果可以的话，我想花点时间解释一下。

对于`match`，我们可以像这样自由地对签名进行分组：

```js
// match :: Regex -> (String -> [String])
const match = curry((reg, s) => s.match(reg));
```

是的，将最后一部分放在括号中会显示更多信息。现在它被视为一个函数，它接受一个 `Regex` 并返回一个从 `String` 到 `[String]` 的函数。由于柯里化，情况确实如此：给它一个 `Regex`，我们得到一个等待它的 `String` 参数的函数。当然，我们不必这样想，但最好理解为什么最后一种类型是返回的类型。

```js
// match :: Regex -> (String -> [String])
// onHoliday :: String -> [String]
const onHoliday = match(/holiday/ig);
```

每个参数从签名的前面弹出一种类型。 `onHoliday` 是已经有一个 `Regex` 的 `match`。

```js
// replace :: Regex -> (String -> (String -> String))
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

正如你在 `replace` 上的完整括号所看到的，额外的符号可能会变得有点嘈杂和多余，所以我们简单地省略了它们。如果我们选择，我们可以一次提供所有参数，因此更容易将其视为：`replace` 接受一个 `Regex`、一个 `String`、另一个 `String` 并返回一个 `String`。

最后几点：


```js
// id :: a -> a
const id = x => x;

// map :: (a -> b) -> [a] -> [b]
const map = curry((f, xs) => xs.map(f));
```

`id` 函数接受任何旧类型 `a` 并返回相同类型的东西 `a`。我们可以像在代码中一样在类型中使用变量。像 `a` 和 `b` 这样的变量名是约定俗成的，但它们是任意的，可以用你喜欢的任何名称替换。如果它们是相同的变量，则它们必须是相同的类型。这是一个重要的规则，所以让我们重申：`a -> b` 可以是任何类型 `a` 到任何类型 `b`，但 `a -> a` 意味着它必须是相同的类型。例如，`id` 可能是`String -> String` 或`Number -> Number`，但不是`String -> Bool`。

`map` 类似地使用类型变量，但这次我们引入了 `b`，它可能与 `a` 的类型相同，也可能不同。我们可以将其读作：`map` 将一个函数从任何类型 `a` 转换为相同或不同类型的 `b`，然后获取一个由 `a` 组成的数组并产生一个由 `b` 组成的数组。

希望您已经被这种类型签名的表现之美所征服。它从字面上告诉我们这个函数几乎是逐字逐句地做了什么。它被赋予了一个从 `a` 到 `b` 的函数，一个 `a` 的数组，它为我们提供了一个 `b` 的数组。它要做的唯一明智的事情是在每个 `a` 上调用该死的函数。其他任何事情都将是一个大胆的谎言。

能够对类型及其含义进行推理是一项将带您在函数世界中走得更远的技能。不仅论文、博客、文档等会变得更容易理解，而且签名本身实际上会告诉你它的功能。成为一个流利的读者需要练习，但如果你坚持下去，你就可以在没有 RTFM 的情况下获得大量信息。

这里还有一些只是为了看看你是否可以自己破译它们。

```js
// head :: [a] -> a
const head = xs => xs[0];

// filter :: (a -> Bool) -> [a] -> [a]
const filter = curry((f, xs) => xs.filter(f));

// reduce :: ((b, a) -> b) -> b -> [a] -> b
const reduce = curry((f, x, xs) => xs.reduce(f, x));
```

`reduce` 可能是最有表现力的。然而，这是一个棘手的问题，所以如果你在努力，不要觉得不够。对于好奇的人，我将尝试用英语进行解释，尽管您自己完成签名更有启发意义。

咳咳，这里什么也没有……看签名，我们看到第一个参数是一个函数，它需要 `b` 和 `a`，并产生一个 `b`。它从哪里得到这些“a”和“b”？好吧，签名中的以下参数是一个 `b` 和一个 `a`s 的数组，所以我们只能假设会输入 `b` 和这些 `a`s 中的每一个。我们还看到结果函数是一个`b`，所以这里的想法是我们对传入函数的最终咒语将是我们的输出值。知道了 reduce 的作用，我们可以说上述调查是准确的。


## 缩小可能性

一旦引入了类型变量，就会出现一个名为 *[parametricity](https://en.wikipedia.org/wiki/Parametricity)* 的奇怪属性。此属性表明函数将*以统一的方式*作用于所有类型。我们来调查一下：

```js
// head :: [a] -> a
```

查看 `head`，我们看到它需要 `[a]` 到 `a`。除了具体类型“array”之外，它没有其他可用信息，因此，它的功能仅限于单独处理数组。如果它对变量`a` 一无所知，它可能会对它做什么？换句话说，`a` 表示它不能是 *specific* 类型，这意味着它可以是 *any* 类型，这给我们留下了一个必须对 *每种 * 可能的类型统一工作的函数。这就是*参数性*的全部内容。猜测实现，唯一合理的假设是它从该数组中获取第一个、最后一个或随机元素。 “头”这个名字应该让我们知道。

这是另一个：

```js
// reverse :: [a] -> [a]
```

仅从类型签名来看，`reverse` 可能达到什么目的？同样，它不能做任何特定于 `a` 的事情。它不能将 `a` 更改为不同的类型，否则我们会引入一个 `b`。可以排序吗？好吧，不，它没有足够的信息来对每种可能的类型进行排序。可以重新安排吗？是的，我想它可以做到这一点，但它必须以完全相同的可预测方式做到这一点。另一种可能性是它可能决定删除或复制一个元素。无论如何，关键是，可能的行为被其多态类型大大缩小了。

这种可能性的缩小使我们能够使用像 [Hoogle](https://hoogle.haskell.org/) 这样的类型签名搜索引擎来查找我们想要的函数。紧密包装在签名中的信息确实非常强大。

## 自由如定理

除了推断实现的可能性之外，这种推理还为我们提供了*自由定理*。下面是一些直接取自 [Wadler 关于该主题的论文](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf) 的随机示例定理。

```js
// head :: [a] -> a
compose(f, head) === compose(head, map(f));

// filter :: (a -> Bool) -> [a] -> [a]
compose(map(f), filter(compose(p, f))) === compose(filter(p), map(f));
```


您不需要任何代码来获得这些定理，它们直接来自类型。第一个说，如果我们得到数组的 `head`，然后在它上面运行一些函数 `f`，这相当于，顺便说一下，比我们首先对每个元素进行 `map(f)` 快得多然后取结果的“头部”。

你可能会想，这只是常识。但最后我查了一下，计算机没有常识。事实上，他们必须有一种正式的方式来自动化这些类型的代码优化。数学有一种形式化直觉的方法，这在计算机逻辑的僵化领域很有帮助。

`filter` 定理是类似的。它说如果我们组合 `f` 和 `p` 来检查哪些应该被过滤，那么实际上通过 `map` 应用 `f`（记住 `filter` 不会转换元素 - 它的签名强制 `a` 将不会被触及），它总是等价于映射我们的 `f`，然后用 `p` 谓词过滤结果。

这只是两个示例，但您可以将此推理应用于任何多态类型签名，并且它始终成立。在 JavaScript 中，有一些工具可用于声明重写规则。也可以通过 `compose` 函数本身来做到这一点。果实低垂，可能性无穷无尽。

## 约束

最后要注意的是，我们可以将类型限制为接口。

```js
// sort :: Ord a => [a] -> [a]
```

我们在这里的粗箭头左侧看到的是一个事实的陈述：`a` 必须是一个 `Ord`。或者换句话说，`a` 必须实现 `Ord` 接口。什么是“Ord”？它从何而来？在类型化语言中，它将是一个定义的接口，表示我们可以对值进行排序。这不仅告诉我们更多关于 `a` 和我们的 `sort` 函数的作用，而且还限制了域。我们称这些接口声明为*类型约束*。

```js
// assertEqual :: (Eq a, Show a) => a -> a -> Assertion
```

在这里，我们有两个约束：`Eq` 和 `Show`。这些将确保我们可以检查我们的 `a` 是否相等，如果它们不相等，则打印差异。

我们将看到更多约束的例子，并且这个想法应该在后面的章节中更加清晰。

＃＃ 总之

Hindley-Milner 类型签名在功能世界中无处不在。虽然它们易于阅读和编写，但仅通过签名来掌握理解程序的技术需要时间。从现在开始，我们将为每一行代码添加类型签名。

【第08章：特百惠】(ch08.md)
