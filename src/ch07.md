#第07章：欣德利-米尔纳和我

##你的类型是什么？
如果您是函数式世界的新手，用不了多久您就会发现自己深陷类型签名中。类型是一种元语言，它使来自不同背景的人们能够简洁有效地进行交流。大多数情况下，它们是用一个名为“Hindley-Milner”的系统编写的，我们将在本章中一起研究。

使用纯函数时，类型签名具有英语语言无法比拟的表达能力。这些签名在您耳边低语着功能的私密秘密。在一个单一的、紧凑的线条中，它们暴露了行为和意图。我们可以从中推导出“自由定理”。可以推断类型，因此不需要显式类型注释。它们可以调整为精细点精度或保留一般性和抽象性。它们不仅对编译时检查很有用，而且还是最好的可用文档。因此，类型签名在函数式编程中扮演着重要的角色——比你最初想象的要多得多。

JavaScript 是一种动态语言，但这并不意味着我们都避免使用类型。我们仍在处理字符串、数字、布尔值等。只是没有任何语言级别的集成，因此我们将这些信息牢记在心。不用担心，因为我们在文档中使用签名，所以我们可以使用注释来达到我们的目的。

JavaScript 有可用的类型检查工具，例如 [Flow](https://flow.org/) 或类型化方言 [TypeScript](https://www.typescriptlang.org/)。本书的目的是为人们配备编写函数式代码的工具，因此我们将坚持使用跨 FP 语言使用的标准类型系统。


##来自神秘的故事

从满是灰尘的数学书页、浩瀚的白皮书海洋、周六早上随意的博客文章，到源代码本身，我们找到了 Hindley-Milner 类型的签名。该系统非常简单，但需要快速解释和一些练习以充分吸收这门小语言。

```js
// capitalize :: String -> String
const capitalize = s => toUpperCase(head(s)) + toLowerCase(tail(s));

capitalize('smurf'); // 'Smurf'
```

这里，`capitalize` 接受一个 `String` 并返回一个 `String`。没关系实现，这是我们感兴趣的类型签名。

在 HM 中，函数被写成 `a -> b`，其中 `a` 和 `b` 是任何类型的变量。所以`capitalize` 的签名可以理解为“一个从`String` 到`String` 的函数”。换句话说，它接受一个 `String` 作为它的输入并返回一个 `String` 作为它的输出。

让我们看看更多的函数签名：

```js
// strLength :: String -> Number
const strLength = s => s.length;

// join :: String -> [String] -> String
const join = curry((what, xs) => xs.join(what));

// match :: Regex -> String -> [String]
const match = curry((reg, s) => s.match(reg));

// replace :: Regex -> String -> String -> String
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

`strLength` 与之前的想法相同：我们接受一个 `String` 并返回一个 `Number`。

乍一看，其他人可能会让您感到困惑。在没有完全理解细节的情况下，您总是可以将最后一个类型视为返回值。所以对于`match`，你可以解释为：它需要一个`Regex`和一个`String`，并返回`[String]`。但是这里发生了一件有趣的事情，如果可以的话，我想花点时间解释一下。

对于`match`，我们可以像这样自由地对签名进行分组：

```js
// match :: Regex -> (String -> [String])
const match = curry((reg, s) => s.match(reg));
```

Ah yes, grouping the last part in parenthesis reveals more information. Now it is seen as a function that takes a `Regex` and returns us a function from `String` to `[String]`. Because of currying, this is indeed the case: give it a `Regex` and we get a function back waiting for its `String` argument. Of course, we don't have to think of it this way, but it is good to understand why the last type is the one returned.

```js
// match :: Regex -> (String -> [String])
// onHoliday :: String -> [String]
const onHoliday = match(/holiday/ig);
```

每个参数从签名的前面弹出一种类型。 `onHoliday` 是已经有一个 `Regex` 的 `match`。

```js
// replace :: Regex -> (String -> (String -> String))
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

As you can see with the full parenthesis on `replace`, the extra notation can get a little noisy and redundant so we simply omit them. We can give all the arguments at once if we choose so it's easier to just think of it as: `replace` takes a `Regex`, a `String`, another `String` and returns you a `String`.

A few last things here:


```js
// id :: a -> a
const id = x => x;

// map :: (a -> b) -> [a] -> [b]
const map = curry((f, xs) => xs.map(f));
```

The `id` function takes any old type `a` and returns something of the same type `a`. We're able to use variables in types just like in code. Variable names like `a` and `b` are convention, but they are arbitrary and can be replaced with whatever name you'd like. If they are the same variable, they have to be the same type. That's an important rule so let's reiterate: `a -> b` can be any type `a` to any type `b`, but `a -> a` means it has to be the same type. For example, `id` may be `String -> String` or `Number -> Number`, but not `String -> Bool`.

`map` similarly uses type variables, but this time we introduce `b` which may or may not be the same type as `a`. We can read it as: `map` takes a function from any type `a` to the same or different type `b`, then takes an array of `a`'s and results in an array of `b`'s.

Hopefully, you've been overcome by the expressive beauty in this type signature. It literally tells us what the function does almost word for word. It's given a function from `a` to `b`, an array of `a`, and it delivers us an array of `b`. The only sensible thing for it to do is call the bloody function on each `a`. Anything else would be a bold face lie.

Being able to reason about types and their implications is a skill that will take you far in the functional world. Not only will papers, blogs, docs, etc, become more digestible, but the signature itself will practically lecture you on its functionality. It takes practice to become a fluent reader, but if you stick with it, heaps of information will become available to you sans RTFMing.

Here's a few more just to see if you can decipher them on your own.

```js
// head :: [a] -> a
const head = xs => xs[0];

// 过滤器 :: (a -> Bool) -> [a] -> [a]
const filter = curry((f, xs) => xs.filter(f));

// reduce :: ((b, a) -> b) -> b -> [a] -> b
const reduce = curry((f, x, xs) => xs.reduce(f, x));
```

`reduce` is perhaps, the most expressive of all. It's a tricky one, however, so don't feel inadequate should you struggle with it. For the curious, I'll try to explain in English though working through the signature on your own is much more instructive.

Ahem, here goes nothing....looking at the signature, we see the first argument is a function that expects `b` and `a`, and produces a `b`. Where might it get these `a`s and `b`s? Well, the following arguments in the signature are a `b` and an array of `a`s so we can only assume that the `b` and each of those `a`s will be fed in. We also see that the result of the function is a `b` so the thinking here is our final incantation of the passed in function will be our output value. Knowing what reduce does, we can state that the above investigation is accurate.


## Narrowing the Possibility

Once a type variable is introduced, there emerges a curious property called *[parametricity](https://en.wikipedia.org/wiki/Parametricity)*. This property states that a function will *act on all types in a uniform manner*. Let's investigate:

```js
// head :: [a] -> a
```

查看 `head`，我们看到它需要 `[a]` 到 `a`。除了具体类型“array”之外，它没有其他可用信息，因此，它的功能仅限于单独处理数组。如果它对变量`a` 一无所知，它可能会对它做什么？换句话说，`a` 表示它不能是 *specific* 类型，这意味着它可以是 *any* 类型，这给我们留下了一个必须对 *每种 * 可能的类型统一工作的函数。这就是*参数性*的全部内容。猜测实现，唯一合理的假设是它从该数组中获取第一个、最后一个或随机元素。 “头”这个名字应该让我们知道。

这是另一个：

```js
// reverse :: [a] -> [a]
```

From the type signature alone, what could `reverse` possibly be up to? Again, it cannot do anything specific to `a`. It cannot change `a` to a different type or we'd introduce a `b`. Can it sort? Well, no, it wouldn't have enough information to sort every possible type. Can it re-arrange?  Yes, I suppose it can do that, but it has to do so in exactly the same predictable way. Another possibility is that it may decide to remove or duplicate an element. In any case, the point is, the possible behaviour is massively narrowed by its polymorphic type.

This narrowing of possibility allows us to use type signature search engines like [Hoogle](https://hoogle.haskell.org/) to find a function we're after. The information packed tightly into a signature is quite powerful indeed.

## Free as in Theorem

Besides deducing implementation possibilities, this sort of reasoning gains us *free theorems*. What follows are a few random example theorems lifted directly from [Wadler's paper on the subject](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf).

```js
// head :: [a] -> a
compose(f, head) === compose(head, map(f));

// filter :: (a -> Bool) -> [a] -> [a]
compose(map(f), filter(compose(p, f))) === compose(filter(p), map(f));
```


You don't need any code to get these theorems, they follow directly from the types. The first one says that if we get the `head` of our array, then run some function `f` on it, that is equivalent to, and incidentally, much faster than, if we first `map(f)` over every element then take the `head` of the result.

You might think, well that's just common sense. But last I checked, computers don't have common sense. Indeed, they must have a formal way to automate these kind of code optimizations. Maths has a way of formalizing the intuitive, which is helpful amidst the rigid terrain of computer logic.

The `filter` theorem is similar. It says that if we compose `f` and `p` to check which should be filtered, then actually apply the `f` via `map` (remember `filter` will not transform the elements - its signature enforces that `a` will not be touched), it will always be equivalent to mapping our `f` then filtering the result with the `p` predicate.

These are just two examples, but you can apply this reasoning to any polymorphic type signature and it will always hold. In JavaScript, there are some tools available to declare rewrite rules. One might also do this via the `compose` function itself. The fruit is low hanging and the possibilities are endless.

## Constraints

One last thing to note is that we can constrain types to an interface.

```js
// sort :: Ord a => [a] -> [a]
```

我们在这里的粗箭头左侧看到的是一个事实的陈述：`a` 必须是一个 `Ord`。或者换句话说，`a` 必须实现 `Ord` 接口。什么是“Ord”？它从何而来？在类型化语言中，它将是一个定义的接口，表示我们可以对值进行排序。这不仅告诉我们更多关于 `a` 和我们的 `sort` 函数的作用，而且还限制了域。我们称这些接口声明为*类型约束*。

```js
// assertEqual :: (Eq a, Show a) => a -> a -> Assertion
```

Here, we have two constraints: `Eq` and `Show`. Those will ensure that we can check equality of our `a`s and print the difference if they are not equal.

We'll see more examples of constraints and the idea should take more shape in later chapters.

## In Summary

Hindley-Milner type signatures are ubiquitous in the functional world. Though they are simple to read and write, it takes time to master the technique of understanding programs through signatures alone. We will add type signatures to each line of code from here on out.

[Chapter 08: Tupperware](ch08.md)
