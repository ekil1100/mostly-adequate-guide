# 第 10 章：应用函子

## 应用 Applicatives

鉴于其功能起源，名称 **applicative functor** 具有令人愉快的描述性。函数式程序员以想出像 `mappend` 或 `liftA4` 这样的名字而臭名昭著，这在数学实验室中看起来很自然，但在任何其他上下文中都保持着优柔寡断的 Darth Vader 的清晰度。

无论如何，这个名字应该让这个接口给我们带来什么：_将函子应用于彼此的能力_。

现在，为什么像你这样一个正常、理性的人会想要这样的东西？将一个函子应用于另一个函子甚至*意味着*是什么？

为了回答这些问题，我们将从您在功能性旅行中可能已经遇到的情况开始。假设，假设我们有两个函子（相同类型），并且我们想以它们的两个值作为参数来调用一个函数。一些简单的事情，比如添加两个 `Container` 的值。

```js
// We can't do this because the numbers are bottled up.
add(Container.of(2), Container.of(3))
// NaN

// Let's use our trusty map
const containerOfAdd2 = map(add, Container.of(2))
// Container(add(2))
```

我们有一个 `Container`，里面有一个部分应用的函数。更具体地说，我们有一个 `Container(add(2))`，我们想将它的 `add(2)` 应用到 `Container(3)` 中的 `3` 以完成调用。换句话说，我们想将一个函子应用到另一个函子上。

现在，碰巧我们已经拥有完成这项任务的工具。我们可以像这样`chain`然后`map`部分应用的`add(2)`：

```js
Container.of(2).chain((two) => Container.of(3).map(add(two)))
```

这里的问题是，我们被困在 monad 的顺序世界中，在前一个 monad 完成其业务之前，无法评估任何内容。我们有两个强大的、独立的值，我认为没有必要仅仅为了满足 monad 的顺序需求而延迟创建 `Container(3)`。

事实上，如果我们能将一个函子的内容简洁地应用到另一个函子的值上，而没有这些不必要的函数和变量，那就太好了，如果我们发现自己在这个泡菜罐中。

## 瓶装船

<img src="images/ship_in_a_bottle.jpg" alt="https://www.deviantart.com/hollycarden" />

`ap` 是一个函数，可以将一个函子的函数内容应用于另一个函子的值内容。快说五遍。

```js
Container.of(add(2)).ap(Container.of(3))
// Container(5)

// all together now

Container.of(2).map(add).ap(Container.of(3))
// Container(5)
```

我们在那里，漂亮而整洁。 `Container(3)` 的好消息，因为它已经从嵌套的 monadic 函数的监狱中释放出来。再次值得一提的是，在这种情况下，`add` 在第一个 `map` 期间被部分应用，因此这仅在 `add` 柯里化时有效。

我们可以像这样定义 `ap`：

```js
Container.prototype.ap = function (otherContainer) {
  return otherContainer.map(this.$value)
}
```

记住，`this.$value` 将是一个函数，我们将接受另一个函子，所以我们只需要 `map` 它。有了这个，我们有了我们的接口定义：

> 一个 _applicative functor_ 是一个带有 `ap` 方法的尖头函子

注意对 **pointed** 的依赖。尖头接口在这里至关重要，我们将在以下示例中看到。

现在，我感觉到你的怀疑（或者可能是困惑和恐惧），但请保持开放的心态；这个`ap` 字符将被证明是有用的。在我们进入它之前，让我们探索一个不错的属性。

```js
F.of(x).map(f) === F.of(f).ap(F.of(x))
```

在正确的英语中，映射`f` 相当于`ap`ing 一个`f` 的函子。或者用更恰当的英语，我们可以将 `x` 放入我们的容器和 `map(f)`，或者我们可以将 `f` 和 `x` 都放入我们的容器中，然后将它们 `ap`。这允许我们以从左到右的方式编写：

```js
Maybe.of(add).ap(Maybe.of(2)).ap(Maybe.of(3))
// Maybe(5)

Task.of(add).ap(Task.of(2)).ap(Task.of(3))
// Task(5)
```

如果从中间斜视观察，人们甚至可能会认出正常函数调用的模糊形状。我们将在本章稍后介绍 pointfree 版本，但就目前而言，这是编写此类代码的首选方式。使用`of`，每个值都被传送到容器的神奇之地，这个平行的宇宙，其中每个应用程序都可以是异步或空的，或者你和`ap` 将在这个梦幻般的地方应用函数。这就像在瓶子里建造一艘船。

你在那里看到了吗？我们在示例中使用了 `Task`。这是应用函子发挥作用的主要情况。让我们看一个更深入的例子。

##协调动机

假设我们正在建立一个旅游网站，我们想要检索旅游目的地和当地事件的列表。其中每一个都是单独的、独立的 api 调用。

```js
// Http.get :: String -> Task Error HTML

const renderPage = curry((destinations, events) => {
  /* render page */
})

Task.of(renderPage).ap(Http.get('/destinations')).ap(Http.get('/events'))
// Task("<div>some page with dest and events</div>")
```

两个 `Http` 调用都会立即发生，并且在解决这两个问题后会调用 `renderPage`。将此与 monadic 版本进行对比，其中一个 `Task` 必须在下一个触发之前完成。由于我们不需要目的地来检索事件，因此我们无需进行顺序评估。

同样，因为我们使用部分应用程序来实现这个结果，我们必须确保 `renderPage` 是柯里化的，否则它不会等待两个 `Tasks` 都完成。顺便说一句，如果您曾经不得不手动完成这样的事情，您会欣赏这个界面惊人的简单性。这是一种让我们更接近奇点的优美代码。

让我们再看一个例子。

```js
// $ :: String -> IO DOM
const $ = (selector) => new IO(() => document.querySelector(selector))

// getVal :: String -> IO String
const getVal = compose(map(prop('value')), $)

// signIn :: String -> String -> Bool -> User
const signIn = curry((username, password, rememberMe) => {
  /* signing in */
})

IO.of(signIn).ap(getVal('#email')).ap(getVal('#password')).ap(IO.of(false))
// IO({ id: 3, email: 'gg@allin.com' })
```

`signIn` 是一个带有 3 个参数的柯里化函数，因此我们必须相应地使用 `ap`。对于每个 `ap`，`signIn` 会再接收一个参数，直到它完成并运行。我们可以根据需要使用尽可能多的参数继续这种模式。另一件要注意的事情是，两个参数自然地在`IO`中结束，而最后一个需要`of`的帮助才能将其提升到`IO`中，因为`ap`期望函数及其所有参数都在同一个类型。

## 兄弟，你还举重吗？

让我们研究一种编写这些应用程序调用的无点方法。由于我们知道 `map` 等于 `of/ap`，我们可以编写泛型函数，将 `ap` 指定多次：

```js
const liftA2 = curry((g, f1, f2) => f1.map(g).ap(f2))

const liftA3 = curry((g, f1, f2, f3) => f1.map(g).ap(f2).ap(f3))

// liftA4, etc
```

`liftA2` 是一个奇怪的名字。这听起来像是破旧工厂中挑剔的货运电梯之一，或者是廉价豪华轿车公司的梳妆台。然而，一旦开悟，它是不言自明的：将这些片段提升到应用函子世界。

当我第一次看到这个 2-3-4 的废话时，我觉得它丑陋且不必要。毕竟，我们可以检查 JavaScript 中函数的数量并动态构建它。然而，部分应用`liftA(N)`本身通常很有用，因此它不能改变参数长度。

让我们看看它的使用情况：

```js
// checkEmail :: User -> Either String Email
// checkName :: User -> Either String String

const user = {
  name: 'John Doe',
  email: 'blurp_blurp',
}

//  createUser :: Email -> String -> IO User
const createUser = curry((email, name) => {
  /* creating... */
})

Either.of(createUser).ap(checkEmail(user)).ap(checkName(user))
// Left('invalid email')

liftA2(createUser, checkEmail(user), checkName(user))
// Left('invalid email')
```

由于 `createUser` 有两个参数，我们使用相应的 `liftA2`。这两个语句是等价的，但 `liftA2` 版本没有提到 `Either`。这使得它更加通用和灵活，因为我们不再与特定类型结合。

让我们看看前面这样写的例子：

```js
liftA2(add, Maybe.of(2), Maybe.of(3))
// Maybe(5)

liftA2(renderPage, Http.get('/destinations'), Http.get('/events'))
// Task('<div>some page with dest and events</div>')

liftA3(signIn, getVal('#email'), getVal('#password'), IO.of(false))
// IO({ id: 3, email: 'gg@allin.com' })
```

## 运算符

在 Haskell、Scala、PureScript 和 Swift 等可以创建自己的中缀运算符的语言中，您可能会看到如下语法：

```hs
-- Haskell / PureScript
add <$> Right 2 <*> Right 3
```

```js
// JavaScript
map(add, Right(2)).ap(Right(3))
```

知道`<$>` 是`map`（又名`fmap`）和`<*>` 只是`ap` 是有帮助的。这允许更自然的函数应用程序样式，并有助于删除一些括号。

## 免费开罐器

<img src="images/canopener.jpg" alt="http://www.breannabeckmeyer.com/" />

我们还没有讲太多关于派生函数的内容。看到所有这些接口都是相互建立起来的并遵守一组定律，我们可以根据强接口定义一些较弱的接口。

例如，我们知道应用程序首先是一个函子，所以如果我们有一个应用程序实例，我们当然可以为我们的类型定义一个函子。

这种完美的计算和谐是可能的，因为我们在一个数学框架内工作。莫扎特即使在他还是个孩子的时候把 Ableton 灌输，也不能做得更好。

我之前提到过 `of/ap` 等价于 `map`。我们可以使用这些知识免费定义 `map`：

```js
// map derived from of/ap
X.prototype.map = function map(f) {
  return this.constructor.of(f).ap(this)
}
```

Monads 位于食物链的顶端，可以这么说，所以如果我们有 `chain`，我们可以免费获得 functor 和 applicative：

```js
// map derived from chain
X.prototype.map = function map(f) {
  return this.chain((a) => this.constructor.of(f(a)))
}

// ap derived from chain/map
X.prototype.ap = function ap(other) {
  return this.chain((f) => other.map(f))
}
```

如果我们可以定义一个 monad，我们就可以定义 applicative 和 functor 接口。这是非常了不起的，因为我们可以免费获得所有这些开罐器。我们甚至可以检查一个类型并自动化这个过程。

应该指出的是，`ap` 的部分吸引力在于能够同时运行事物，因此通过 `chain` 定义它就错过了这种优化。尽管如此，在找出最佳实现的同时，拥有一个即时可用的界面还是很好的。

你问，为什么不直接使用 monad 并完成它呢？使用您需要的功率水平是一种很好的做法，不多也不少。这通过排除可能的功能将认知负荷降至最低。出于这个原因，优先使用应用程序而不是 monad 是件好事。

由于向下的嵌套结构，Monads 具有独特的计算顺序、分配变量和停止进一步执行的能力。当人们看到正在使用的应用程序时，他们不必关心任何该业务。

现在，关于合法性......

## 法律

就像我们探索过的其他数学结构一样，应用函子拥有一些有用的属性，我们可以在日常代码中依赖它。首先，您应该知道应用程序是“在组合下封闭的”，这意味着 `ap` 永远不会改变我们的容器类型（这是另一个偏爱 monad 的原因）。这并不是说我们不能有多种不同的效果——我们可以堆叠我们的类型，知道它们在我们的整个应用程序中将保持不变。

展示：

```js
const tOfM = compose(Task.of, Maybe.of)

liftA2(
  liftA2(concat),
  tOfM('Rainy Days and Mondays'),
  tOfM(' always get me down'),
)
// Task(Maybe(Rainy Days and Mondays always get me down))
```

看，无需担心不同类型的混合。

是时候看看我们最喜欢的绝对法则了：_身份_：

＃＃＃ 身份

```js
// identity
A.of(id).ap(v) === v
```

是的，所以在函子内应用 `id` 不应该改变 `v` 中的值。例如：

```js
const v = Identity.of('Pillow Pets')
Identity.of(id).ap(v) === v
```

`Identity.of(id)` 让我对它的无用嗤之以鼻。无论如何，有趣的是，正如我们已经确定的，`of/ap` 与 `map` 相同，因此该定律直接来自函子恒等式：`map(id) == id`。

使用这些法则的美妙之处在于，就像激进的幼儿园体育教练一样，它们迫使我们所有的界面都能很好地协同工作。

### 同态

```js
// homomorphism
A.of(f).ap(A.of(x)) === A.of(f(x))
```

*同态*只是一个结构保留映射。事实上，函子只是类别之间的*同态*，因为它在映射下保留了原始类别的结构。

我们实际上只是将我们的普通函数和值填充到一个容器中并在其中运行计算，因此如果我们将整个内容应用到容器中（容器的左侧），我们最终会得到相同的结果也就不足为奇了。等式）或将其应用到外面，然后将其放在那里（右侧）。

一个简单的例子：

```js
Either.of(toUpperCase).ap(Either.of('oreos')) ===
  Either.of(toUpperCase('oreos'))
```

### 交换

*互换*定律指出，我们选择将函数提升到`ap`的左侧还是右侧并不重要。

```js
// interchange
v.ap(A.of(x)) === A.of((f) => f(x)).ap(v)
```

下面是一个例子：

```js
const v = Task.of(reverse)
const x = 'Sparklehorse'

v.ap(Task.of(x)) === Task.of((f) => f(x)).ap(v)
```

＃＃＃ 作品

最后，组合只是一种检查我们的标准函数组合在容器内部应用时是否成立的方法。

```js
// composition
A.of(compose).ap(u).ap(v).ap(w) === u.ap(v.ap(w))
```

```js
const u = IO.of(toUpperCase)
const v = IO.of(concat('& beyond'))
const w = IO.of('blood bath ')

IO.of(compose).ap(u).ap(v).ap(w) === u.ap(v.ap(w))
```

＃＃ 总之

applicative 的一个很好的用例是当一个人有多个函子参数时。它们使我们能够将函数应用于函子世界中的所有参数。虽然我们已经可以用 monad 做到这一点，但当我们不需要 monad 特定的功能时，我们应该更喜欢应用函子。

我们几乎完成了容器 API。我们已经学习了如何使用 `map`、`chain` 和 `ap` 函数。在下一章中，我们将学习如何更好地使用多个函子并以一种有原则的方式反汇编它们。

【第 11 章：自然而然的再次蜕变】(ch11.md)

## 练习

{％ 锻炼 ％}
编写一个函数，使用 `Maybe` 和 `ap` 将两个可能为空的数字相加。

{% 初始 src="./exercises/ch10/exercise_a.js#L3;" %}

```js
// safeAdd :: Maybe Number -> Maybe Number -> Maybe Number
const safeAdd = undefined
```

{% 解决方案 src="./exercises/ch10/solution_a.js" %}
{% 验证 src="./exercises/ch10/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

{％ 锻炼 ％}
从 exercise_b 重写`safeAdd` 以使用`liftA2` 而不是`ap`。

{% 初始 src="./exercises/ch10/exercise_b.js#L3;" %}

```js
// safeAdd :: Maybe Number -> Maybe Number -> Maybe Number
const safeAdd = undefined
```

{% 解决方案 src="./exercises/ch10/solution_b.js" %}
{% 验证 src="./exercises/ch10/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

对于下一个练习，我们考虑以下助手：

```js
const localStorage = {
  player1: { id: 1, name: 'Albert' },
  player2: { id: 2, name: 'Theresa' },
}

// getFromCache :: String -> IO User
const getFromCache = (x) => new IO(() => localStorage[x])

// game :: User -> User -> String
const game = curry((p1, p2) => `${p1.name} vs ${p2.name}`)
```

{％ 锻炼 ％}
编写一个 IO，从缓存中获取 player1 和 player2 并开始游戏。

{% 初始 src="./exercises/ch10/exercise_c.js#L16;" %}

```js
// startGame :: IO String
const startGame = undefined
```

{% 解决方案 src="./exercises/ch10/solution_c.js" %}
{% 验证 src="./exercises/ch10/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
