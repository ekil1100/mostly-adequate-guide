# 第 10 章：应用函子

## 应用 Applicatives

鉴于其功能起源，名称 **applicative functor** 具有令人愉快的描述性。函数式程序员以想出像 `mappend` 或 `liftA4` 这样的名字而臭名昭著，这在数学实验室中看起来很自然，但在任何其他上下文中都保持着优柔寡断的 Darth Vader 的清晰度。

无论如何，这个名字应该让这个接口给我们带来什么：*将函子应用于彼此的能力*。

现在，为什么像你这样一个正常、理性的人会想要这样的东西？将一个函子应用于另一个函子甚至*意味着*是什么？

为了回答这些问题，我们将从您在功能性旅行中可能已经遇到的情况开始。假设，假设我们有两个函子（相同类型），并且我们想以它们的两个值作为参数来调用一个函数。一些简单的事情，比如添加两个 `Container` 的值。

```js
// We can't do this because the numbers are bottled up.
add(Container.of(2), Container.of(3));
// NaN

// Let's use our trusty map
const containerOfAdd2 = map(add, Container.of(2));
// Container(add(2))
```

我们有一个 `Container`，里面有一个部分应用的函数。更具体地说，我们有一个 `Container(add(2))`，我们想将它的 `add(2)` 应用到 `Container(3)` 中的 `3` 以完成调用。换句话说，我们想将一个函子应用到另一个函子上。

现在，碰巧我们已经拥有完成这项任务的工具。我们可以像这样`chain`然后`map`部分应用的`add(2)`：

```js
Container.of(2).chain(two => Container.of(3).map(add(two)));
```

The issue here is that we are stuck in the sequential world of monads wherein nothing may be evaluated until the previous monad has finished its business. We have ourselves two strong, independent values and I should think it unnecessary to delay the creation of `Container(3)` merely to satisfy the monad's sequential demands.

In fact, it would be lovely if we could succinctly apply one functor's contents to another's value without these needless functions and variables should we find ourselves in this pickle jar.


## Ships in Bottles

<img src="images/ship_in_a_bottle.jpg" alt="https://www.deviantart.com/hollycarden" />

`ap` is a function that can apply the function contents of one functor to the value contents of another. Say that five times fast.

```js
Container.of(add(2)).ap(Container.of(3));
// Container(5)

// 现在都在一起了

Container.of(2).map(add).ap(Container.of(3));
// Container(5)
```

There we are, nice and neat. Good news for `Container(3)` as it's been set free from the jail of the nested monadic function. It's worth mentioning again that `add`, in this case, gets partially applied during the first `map` so this only works when `add` is curried.

We can define `ap` like so:

```js
Container.prototype.ap = function (otherContainer) {
  return otherContainer.map(this.$value);
};
```

记住，`this.$value` 将是一个函数，我们将接受另一个函子，所以我们只需要 `map` 它。有了这个，我们有了我们的接口定义：


> 一个 *applicative functor* 是一个带有 `ap` 方法的尖头函子

注意对 **pointed** 的依赖。尖头接口在这里至关重要，我们将在以下示例中看到。

现在，我感觉到你的怀疑（或者可能是困惑和恐惧），但请保持开放的心态；这个`ap` 字符将被证明是有用的。在我们进入它之前，让我们探索一个不错的属性。

```js
F.of(x).map(f) === F.of(f).ap(F.of(x));
```

In proper English, mapping `f` is equivalent to `ap`ing a functor of `f`. Or in properer English, we can place `x` into our container and `map(f)` OR we can lift both `f` and `x` into our container and `ap` them. This allows us to write in a left-to-right fashion:

```js
Maybe.of(add).ap(Maybe.of(2)).ap(Maybe.of(3));
// Maybe(5)

Task.of(add).ap(Task.of(2)).ap(Task.of(3));
// Task(5)
```

One might even recognise the vague shape of a normal function call if viewed mid squint. We'll look at the pointfree version later in the chapter, but for now, this is the preferred way to write such code. Using `of`, each value gets transported to the magical land of containers, this parallel universe where each application can be async or null or what have you and `ap` will apply functions within this fantastical place. It's like building a ship in a bottle.

Did you see there? We used `Task` in our example. This is a prime situation where applicative functors pull their weight. Let's look at a more in-depth example.

## Coordination Motivation

Say we're building a travel site and we'd like to retrieve both a list of tourist destinations and local events. Each of these are separate, stand-alone api calls.

```js
// Http.get :: String -> Task Error HTML

const renderPage = curry((destinations, events) => { /* 渲染页面 */ });

Task.of(renderPage).ap(Http.get('/destinations')).ap(Http.get('/events'));
// Task("<div>some page with dest and events</div>")
```

Both `Http` calls will happen instantly and `renderPage` will be called when both are resolved. Contrast this with the monadic version where one `Task` must finish before the next fires off. Since we don't need the destinations to retrieve events, we are free from sequential evaluation.

Again, because we're using partial application to achieve this result, we must ensure `renderPage` is curried or it will not wait for both `Tasks` to finish. Incidentally, if you've ever had to do such a thing manually, you'll appreciate the astonishing simplicity of this interface. This is the kind of beautiful code that takes us one step closer to the singularity.

Let's look at another example.

```js
// $ :: String -> IO DOM
const $ = selector => new IO(() => document.querySelector(selector));

// getVal :: String -> IO String
const getVal = compose(map(prop('value')), $);

// 登录 :: 字符串 -> 字符串 -> Bool -> 用户
const signIn = curry((username, password, rememberMe) => { /* 登录 */ });

IO.of(signIn).ap(getVal('#email')).ap(getVal('#password')).ap(IO.of(false));
// IO({ id: 3, email: 'gg@allin.com' })
```

`signIn` is a curried function of 3 arguments so we have to `ap` accordingly. With each `ap`, `signIn` receives one more argument until it is complete and runs. We can continue this pattern with as many arguments as necessary. Another thing to note is that two arguments end up naturally in `IO` whereas the last one needs a little help from `of` to lift it into `IO` since `ap` expects the function and all its arguments to be in the same type.

## Bro, Do You Even Lift?

Let's examine a pointfree way to write these applicative calls. Since we know `map` is equal to `of/ap`, we can write generic functions that will `ap` as many times as we specify:

```js
const liftA2 = curry((g, f1, f2) => f1.map(g).ap(f2));

const liftA3 = curry((g, f1, f2, f3) => f1.map(g).ap(f2).ap(f3));

// liftA4, etc
```

`liftA2` is a strange name. It sounds like one of the finicky freight elevators in a rundown factory or a vanity plate for a cheap limo company. Once enlightened, however, it's self explanatory: lift these pieces into the applicative functor world.

When I first saw this 2-3-4 nonsense it struck me as ugly and unnecessary. After all, we can check the arity of functions in JavaScript and build this up dynamically. However, it is often useful to partially apply `liftA(N)` itself, so it cannot vary in argument length.

Let's see this in use:

```js
// checkEmail :: User -> Either String Email
// checkName :: User -> Either String String

常量用户 = {
  name: 'John Doe',
  电子邮件：'blurp_blurp'，
};

// createUser :: 电子邮件 -> 字符串 -> IO 用户
const createUser = curry((email, name) => { /* 创建... */ });

.of(createUser).ap(checkEmail(user)).ap(checkName(user));
// Left('无效电子邮件')

liftA2(createUser, checkEmail(user), checkName(user));
// Left('invalid email')
```

Since `createUser` takes two arguments, we use the corresponding `liftA2`. The two statements are equivalent, but the `liftA2` version has no mention of `Either`. This makes it more generic and flexible since we are no longer married to a specific type.


Let's see the previous examples written this way:

```js
liftA2(add, Maybe.of(2), Maybe.of(3));
// Maybe(5)

LiftA2(renderPage, Http.get('/destinations'), Http.get('/events'));
// 任务('<div>一些带有目标和事件的页面</div>')

liftA3(signIn, getVal('#email'), getVal('#password'), IO.of(false));
// IO({ id: 3, email: 'gg@allin.com' })
```


## Operators

In languages like Haskell, Scala, PureScript, and Swift, where it is possible to create your own infix operators you may see syntax like this:

```hs
-- Haskell / PureScript
add <$> Right 2 <*> Right 3
```

```js
// JavaScript
map(add, Right(2)).ap(Right(3));
```

It's helpful to know that `<$>` is `map` (aka `fmap`) and `<*>` is just `ap`. This allows for a more natural function application style and can help remove some parenthesis.

## Free Can Openers
<img src="images/canopener.jpg" alt="http://www.breannabeckmeyer.com/" />

We haven't spoken much about derived functions. Seeing as all of these interfaces are built off of each other and obey a set of laws, we can define some weaker interfaces in terms of the stronger ones.

For instance, we know that an applicative is first a functor, so if we have an applicative instance, surely we can define a functor for our type.

This kind of perfect computational harmony is possible because we're working within a mathematical framework. Mozart couldn't have done better even if he had torrented Ableton as a child.

I mentioned earlier that `of/ap` is equivalent to `map`. We can use this knowledge to define `map` for free:

```js
// map derived from of/ap
X.prototype.map = function map(f) {
  return this.constructor.of(f).ap(this);
};
```

Monads 位于食物链的顶端，可以这么说，所以如果我们有 `chain`，我们可以免费获得 functor 和 applicative：

```js
// map derived from chain
X.prototype.map = function map(f) {
  return this.chain(a => this.constructor.of(f(a)));
};

// ap derived from chain/map
X.prototype.ap = function ap(other) {
  return this.chain(f => other.map(f));
};
```

如果我们可以定义一个 monad，我们就可以定义 applicative 和 functor 接口。这是非常了不起的，因为我们可以免费获得所有这些开罐器。我们甚至可以检查一个类型并自动化这个过程。

应该指出的是，`ap` 的部分吸引力在于能够同时运行事物，因此通过 `chain` 定义它就错过了这种优化。尽管如此，在找出最佳实现的同时，拥有一个即时可用的界面还是很好的。

你问，为什么不直接使用 monad 并完成它呢？使用您需要的功率水平是一种很好的做法，不多也不少。这通过排除可能的功能将认知负荷降至最低。出于这个原因，优先使用应用程序而不是 monad 是件好事。

由于向下的嵌套结构，Monads 具有独特的计算顺序、分配变量和停止进一步执行的能力。当人们看到正在使用的应用程序时，他们不必关心任何该业务。

现在，关于合法性......

## 法律

就像我们探索过的其他数学结构一样，应用函子拥有一些有用的属性，我们可以在日常代码中依赖它。首先，您应该知道应用程序是“在组合下封闭的”，这意味着 `ap` 永远不会改变我们的容器类型（这是另一个偏爱 monad 的原因）。这并不是说我们不能有多种不同的效果——我们可以堆叠我们的类型，知道它们在我们的整个应用程序中将保持不变。

展示：

```js
const tOfM = compose(Task.of, Maybe.of);

liftA2(liftA2(concat), tOfM('Rainy Days and Mondays'), tOfM(' always get me down'));
// Task(Maybe(Rainy Days and Mondays always get me down))
```

看，无需担心不同类型的混合。

是时候看看我们最喜欢的绝对法则了：*身份*：

＃＃＃ 身份

```js
// identity
A.of(id).ap(v) === v;
```

Right, so applying `id` all from within a functor shouldn't alter the value in `v`. For example:

```js
const v = Identity.of('Pillow Pets');
Identity.of(id).ap(v) === v;
```

`Identity.of(id)` 让我对它的无用嗤之以鼻。无论如何，有趣的是，正如我们已经确定的，`of/ap` 与 `map` 相同，因此该定律直接来自函子恒等式：`map(id) == id`。

使用这些法则的美妙之处在于，就像激进的幼儿园体育教练一样，它们迫使我们所有的界面都能很好地协同工作。

### 同态

```js
// homomorphism
A.of(f).ap(A.of(x)) === A.of(f(x));
```

A *homomorphism* is just a structure preserving map. In fact, a functor is just a *homomorphism* between categories as it preserves the original category's structure under the mapping.


We're really just stuffing our normal functions and values into a container and running the computation in there so it should come as no surprise that we will end up with the same result if we apply the whole thing inside the container (left side of the equation) or apply it outside, then place it in there (right side).

A quick example:

```js
Either.of(toUpperCase).ap(Either.of('oreos')) === Either.of(toUpperCase('oreos'));
```

### 交换

*互换*定律指出，我们选择将函数提升到`ap`的左侧还是右侧并不重要。

```js
// interchange
v.ap(A.of(x)) === A.of(f => f(x)).ap(v);
```

Here is an example:

```js
const v = Task.of(reverse);
const x = 'Sparklehorse';

v.ap(Task.of(x)) === Task.of(f => f(x)).ap(v);
```

### Composition

And finally composition which is just a way to check that our standard function composition holds when applying inside of containers.

```js
// composition
A.of(compose).ap(u).ap(v).ap(w) === u.ap(v.ap(w));
```

```js
const u = IO.of(toUpperCase);
const v = IO.of(concat('& beyond'));
const w = IO.of('blood bath ');

IO.of(compose).ap(u).ap(v).ap(w) === u.ap(v.ap(w));
```

＃＃ 总之

applicative 的一个很好的用例是当一个人有多个函子参数时。它们使我们能够将函数应用于函子世界中的所有参数。虽然我们已经可以用 monad 做到这一点，但当我们不需要 monad 特定的功能时，我们应该更喜欢应用函子。

我们几乎完成了容器 API。我们已经学习了如何使用 `map`、`chain` 和 `ap` 函数。在下一章中，我们将学习如何更好地使用多个函子并以一种有原则的方式反汇编它们。

【第11章：自然而然的再次蜕变】(ch11.md)


## 练习

{% exercise %}  
Write a function that adds two possibly null numbers together using `Maybe` and `ap`.  
  
{% initial src="./exercises/ch10/exercise_a.js#L3;" %}  
```js  
// safeAdd :: Maybe Number -> Maybe Number -> Maybe Number  
const safeAdd = undefined;  
```  
  
  
{% solution src="./exercises/ch10/solution_a.js" %}  
{% validation src="./exercises/ch10/validation_a.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
  
  
---  
  
  
{% exercise %}  
Rewrite `safeAdd` from exercise_b to use `liftA2` instead of `ap`.  
  
{% initial src="./exercises/ch10/exercise_b.js#L3;" %}  
```js  
// safeAdd :: Maybe Number -> Maybe Number -> Maybe Number  
const safeAdd = undefined;  
```  
  
  
{% solution src="./exercises/ch10/solution_b.js" %}  
{% validation src="./exercises/ch10/validation_b.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
  
  
---  
  
For the next exercise, we consider the following helpers:  
  
```js  
const localStorage = {  
  player1: { id:1, name: 'Albert' },  
  player2: { id:2, name: 'Theresa' },  
};  
  
// getFromCache :: String -> IO User  
const getFromCache = x => new IO(() => localStorage[x]);  
  
// game :: User -> User -> String  
const game = curry((p1, p2) => `${p1.name} vs ${p2.name}`);  
```  
  
{% exercise %}  
Write an IO that gets both player1 and player2 from the cache and starts the game.  
  
  
{% initial src="./exercises/ch10/exercise_c.js#L16;" %}  
```js  
// startGame :: IO String  
const startGame = undefined;  
```  
  
  
{% solution src="./exercises/ch10/solution_c.js" %}  
{% validation src="./exercises/ch10/validation_c.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
