# 第 06 章：示例应用程序

## 声明式编码

我们要转变观念。从现在开始，我们将不再告诉计算机如何完成它的工作，而是编写一个我们想要的结果的规范。我相信你会发现它比一直试图微观管理所有事情的压力要小得多。

声明式，与命令式相反，意味着我们将编写表达式，而不是一步一步的说明。

想想SQL。没有“先做这个，然后做那个”。有一个表达式指定我们希望从数据库中获得什么。我们不决定如何做这项工作，它决定了。当数据库升级和 SQL 引擎优化时，我们不必更改我们的查询。这是因为有很多方法可以解释我们的规范并获得相同的结果。

对于包括我在内的一些人来说，一开始很难理解声明式编码的概念，所以让我们举几个例子来感受一下。

```js
// imperative
const makes = [];
for (let i = 0; i < cars.length; i += 1) {
  makes.push(cars[i].make);
}

// declarative
const makes = cars.map(car => car.make);
```

命令式循环必须首先实例化数组。口译员必须在继续之前评估这个陈述。然后它直接遍历汽车列表，手动增加一个计数器，并以显式迭代的粗俗展示方式向我们展示它的点点滴滴。

`map` 版本是一种表达方式。它不需要任何评估顺序。对于 map 函数如何迭代以及如何组装返回的数组，这里有很大的自由度。它指定*什么*，而不是*如何*。因此，它穿着闪亮的宣言腰带。

除了更加清晰简洁之外，地图功能还可以随意优化，我们宝贵的应用代码无需更改。

对于那些认为“是的，但执行命令式循环要快得多”的人，我建议您了解 JIT 如何优化您的代码。这是一个 [很棒的视频，可能会有所启发](https://www.youtube.com/watch?v=g0ek4vV7nEA)

这是另一个例子。

```js
// imperative
const authenticate = (form) => {
  const user = toUser(form);
  return logIn(user);
};

// declarative
const authenticate = compose(logIn, toUser);
```

尽管命令式版本没有什么问题，但仍然有一个编码的逐步评估。 `compose` 表达式只是陈述了一个事实：身份验证是 `toUser` 和 `logIn` 的组合。同样，这为支持代码更改留下了回旋余地，并导致我们的应用程序代码成为高级规范。

在上面的例子中，指定了求值的顺序（`toUser` 必须在 `logIn` 之前调用），但是有很多场景顺序并不重要，这很容易通过声明式编码来指定（稍后会详细介绍） .

因为我们不必对求值顺序进行编码，所以声明式编码适用于并行计算。再加上纯函数，这就是为什么 FP 是并行未来的一个不错选择的原因——我们真的不需要做任何特殊的事情来实现并行/并发系统。

## 函数式编程的 Flickr

我们现在将以声明性的、可组合的方式构建一个示例应用程序。我们现在仍然会作弊并使用副作用，但我们会将它们保持在最低限度并与我们的纯代码库分开。我们将构建一个浏览器小部件，它吸收 flickr 图像并显示它们。让我们从搭建应用程序开始。这是html：


```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Flickr App</title>
  </head>
  <body>
    <main id="js-main" class="main"></main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>
    <script src="main.js"></script>
  </body>
</html>
```

这是 main.js 框架：

```js
const CDN = s => `https://cdnjs.cloudflare.com/ajax/libs/${s}`;
const ramda = CDN('ramda/0.21.0/ramda.min');
const jquery = CDN('jquery/3.0.0-rc1/jquery.min');

requirejs.config({ paths: { ramda, jquery } });
requirejs(['jquery', 'ramda'], ($, { compose, curry, map, prop }) => {
  // app goes here
});
```

我们正在引入 [ramda](https://ramdajs.com) 而不是 lodash 或其他一些实用程序库。它包括 `compose`、`curry` 等。我使用过 requirejs，这似乎有点矫枉过正，但我们将在整本书中使用它，一致性是关键。

现在，这已经不在了，进入规范。我们的应用程序将做 4 件事。

1. 为我们的特定搜索词构建一个 url
2. 进行 flickr api 调用
3.将生成的json转成html图片
4. 将它们放在屏幕上

上面提到了2个不纯的动作。你看到他们了吗？关于从 flickr api 获取数据并将其放置在屏幕上的那些位。让我们先定义这些，以便我们可以隔离它们。此外，我将添加我们漂亮的 `trace` 函数以便于调试。

```js
const Impure = {
  getJSON: curry((callback, url) => $.getJSON(url, callback)),
  setHtml: curry((sel, html) => $(sel).html(html)),
  trace: curry((tag, x) => { console.log(tag, x); return x; }),
};
```

在这里，我们简单地将 jQuery 的方法包装起来进行柯里化，并将参数交换到更有利的位置。我已经用 `Impure` 给它们命名了，所以我们知道这些是危险的函数。在以后的示例中，我们将使这两个函数纯。

接下来我们必须构造一个 url 来传递给我们的 `Impure.getJSON` 函数。

```js
const host = 'api.flickr.com';
const path = '/services/feeds/photos_public.gne';
const query = t => `?tags=${t}&format=json&jsoncallback=?`;
const url = t => `https://${host}${path}${query(t)}`;
```

使用幺半群（我们将在稍后了解这些）或组合子，有一些奇特且过于复杂的方式来编写 `url` pointfree。我们选择坚持使用可读版本并以正常的有针对性的方式组合此字符串。

让我们编写一个应用程序函数来进行调用并将内容放置在屏幕上。

```js
const app = compose(Impure.getJSON(Impure.trace('response')), url);
app('cats');
```

这会调用我们的 `url` 函数，然后将字符串传递给我们的 `getJSON` 函数，该函数已经部分应用了 `trace`。加载应用程序将在控制台中显示来自 api 调用的响应。

<img src="images/console_ss.png" alt="控制台响应" />

我们想用这个 json 构建图像。看起来`mediaUrls` 被埋在`items` 中，然后是每个`media` 的`m` 属性。

无论如何，为了获得这些嵌套属性，我们可以使用来自 ramda 的一个很好的通用 getter 函数，称为 `prop`。这是一个本土版本，所以你可以看到发生了什么：

```js
const prop = curry((property, object) => object[property]);
```

其实挺无聊的。我们只使用 `[]` 语法来访问任何对象的属性。让我们用它来获取我们的 `mediaUrls`。

```js
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
```

一旦我们收集了 `items`，我们必须对它们进行 `map` 以提取每个媒体 url。这会产生一个很好的 `mediaUrls` 数组。让我们将其连接到我们的应用程序并将它们打印在屏幕上。

```js
const render = compose(Impure.setHtml('#js-main'), mediaUrls);
const app = compose(Impure.getJSON(render), url);
```

我们所做的就是创建一个新的组合，它将调用我们的 `mediaUrls` 并使用它们设置 `<main>` html。我们已经用 `render` 替换了 `trace` 调用，因为除了原始 json 之外我们还有一些东西要渲染。这将在正文中粗略地显示我们的 `mediaUrls`。

我们的最后一步是将这些 `mediaUrls` 变成真正的 `images`。在更大的应用程序中，我们会使用模板/dom 库，如 Handlebars 或 React。但是对于这个应用程序，我们只需要一个 img 标签，所以让我们坚持使用 jQuery。

```js
const img = src => $('<img />', { src });
```

jQuery 的`html` 方法将接受一个标签数组。我们只需要将我们的 mediaUrls 转换为图像并将它们发送到 `setHtml`。

```js
const images = compose(map(img), mediaUrls);
const render = compose(Impure.setHtml('#js-main'), images);
const app = compose(Impure.getJSON(render), url);
```

我们完成了！

<img src="images/cats_ss.png" alt="cats grid" />

这是完成的脚本：
[包括](./exercises/ch06/main.js)

现在看看那个。对事物是什么而不是它们如何形成的精美声明性规范。我们现在将每条线视为具有成立的属性的等式。我们可以使用这些属性来推理我们的应用程序和重构。

## 有原则的重构

有一个可用的优化 - 我们映射每个项目以将其转换为媒体 url，然后我们再次映射这些 mediaUrls 以将它们转换为 img 标签。有一个关于地图和构图的法则：


```js
// map's composition law
compose(map(f), map(g)) === map(compose(f, g));
```

我们可以使用这个属性来优化我们的代码。让我们进行有原则的重构。

```js
// original code
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
const images = compose(map(img), mediaUrls);
```

让我们排列我们的地图。由于等式推理和纯度，我们可以在 `images` 中内联对 `mediaUrls` 的调用。

```js
const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(img), map(mediaUrl), prop('items'));
```

现在我们已经排列好了我们的地图，我们可以应用合成法则。

```js
/*
compose(map(f), map(g)) === map(compose(f, g));
compose(map(img), map(mediaUrl)) === map(compose(img, mediaUrl));
*/

const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(compose(img, mediaUrl)), prop('items'));
```

现在，在将每个项目转换为 img 时，bugger 只会循环一次。让我们通过提取函数使其更具可读性。

```js
const mediaUrl = compose(prop('m'), prop('media'));
const mediaToImg = compose(img, mediaUrl);
const images = compose(map(mediaToImg), prop('items'));
```

＃＃ 总之

我们已经看到了如何通过一个小而真实的应用程序来使用我们的新技能。我们已经使用我们的数学框架来推理和重构我们的代码。但是错误处理和代码分支呢？我们如何才能使整个应用程序变得纯粹，而不仅仅是命名空间破坏性函数？我们如何才能使我们的应用程序更安全、更具表现力？这些是我们将在第 2 部分中解决的问题。

【第07章：欣德利-米尔纳和我】(ch07.md)
