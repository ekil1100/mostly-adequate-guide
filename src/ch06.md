# 第 06 章：示例应用程序

## 声明式编码

我们要转变观念。从现在开始，我们将不再告诉计算机如何完成它的工作，而是编写一个我们想要的结果的规范。我相信你会发现它比一直试图微观管理所有事情的压力要小得多。

声明式，与命令式相反，意味着我们将编写表达式，而不是一步一步的说明。

想想SQL。没有“先做这个，然后做那个”。有一个表达式指定我们希望从数据库中获得什么。我们不决定如何做这项工作，它决定了。当数据库升级和 SQL 引擎优化时，我们不必更改我们的查询。这是因为有很多方法可以解释我们的规范并获得相同的结果。

对于包括我在内的一些人来说，一开始很难理解声明式编码的概念，所以让我们举几个例子来感受一下。

```js
// imperative
const makes = [];
for (let i = 0; i < cars.length; i += 1) {
  makes.push(cars[i].make);
}

// declarative
const makes = cars.map(car => car.make);
```

命令式循环必须首先实例化数组。口译员必须在继续之前评估这个陈述。然后它直接遍历汽车列表，手动增加一个计数器，并以显式迭代的粗俗展示方式向我们展示它的点点滴滴。

`map` 版本是一种表达方式。它不需要任何评估顺序。对于 map 函数如何迭代以及如何组装返回的数组，这里有很大的自由度。它指定*什么*，而不是*如何*。因此，它穿着闪亮的宣言腰带。

除了更加清晰简洁之外，地图功能还可以随意优化，我们宝贵的应用代码无需更改。

对于那些认为“是的，但执行命令式循环要快得多”的人，我建议您了解 JIT 如何优化您的代码。这是一个 [很棒的视频，可能会有所启发](https://www.youtube.com/watch?v=g0ek4vV7nEA)

这是另一个例子。

```js
// imperative
const authenticate = (form) => {
  const user = toUser(form);
  return logIn(user);
};

// declarative
const authenticate = compose(logIn, toUser);
```

尽管命令式版本没有什么问题，但仍然有一个编码的逐步评估。 `compose` 表达式只是陈述了一个事实：身份验证是 `toUser` 和 `logIn` 的组合。同样，这为支持代码更改留下了回旋余地，并导致我们的应用程序代码成为高级规范。

在上面的例子中，指定了求值的顺序（`toUser` 必须在 `logIn` 之前调用），但是有很多场景顺序并不重要，这很容易通过声明式编码来指定（稍后会详细介绍） .

因为我们不必对求值顺序进行编码，所以声明式编码适用于并行计算。再加上纯函数，这就是为什么 FP 是并行未来的一个不错选择的原因——我们真的不需要做任何特殊的事情来实现并行/并发系统。

## 函数式编程的 Flickr

我们现在将以声明性的、可组合的方式构建一个示例应用程序。我们现在仍然会作弊并使用副作用，但我们会将它们保持在最低限度并与我们的纯代码库分开。我们将构建一个浏览器小部件，它吸收 flickr 图像并显示它们。让我们从搭建应用程序开始。这是html：


```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Flickr App</title>
  </head>
  <body>
    <main id="js-main" class="main"></main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>
    <script src="main.js"></script>
  </body>
</html>
```

And here's the main.js skeleton:

```js
const CDN = s => `https://cdnjs.cloudflare.com/ajax/libs/${s}`;
const ramda = CDN('ramda/0.21.0/ramda.min');
const jquery = CDN('jquery/3.0.0-rc1/jquery.min');

requirejs.config({ paths: { ramda, jquery } });
requirejs(['jquery', 'ramda'], ($, { compose, curry, map, prop }) => {
  // app goes here
});
```

We're pulling in [ramda](https://ramdajs.com) instead of lodash or some other utility library. It includes `compose`, `curry`, and more. I've used requirejs, which may seem like overkill, but we'll be using it throughout the book and consistency is key.

Now that that's out of the way, on to the spec. Our app will do 4 things.

1. Construct a url for our particular search term
2. Make the flickr api call
3. Transform the resulting json into html images
4. Place them on the screen

There are 2 impure actions mentioned above. Do you see them? Those bits about getting data from the flickr api and placing it on the screen. Let's define those first so we can quarantine them. Also, I'll add our nice `trace` function for easy debugging.

```js
const Impure = {
  getJSON: curry((callback, url) => $.getJSON(url, callback)),
  setHtml: curry((sel, html) => $(sel).html(html)),
  trace: curry((tag, x) => { console.log(tag, x); return x; }),
};
```

在这里，我们简单地将 jQuery 的方法包装起来进行柯里化，并将参数交换到更有利的位置。我已经用 `Impure` 给它们命名了，所以我们知道这些是危险的函数。在以后的示例中，我们将使这两个函数纯。

接下来我们必须构造一个 url 来传递给我们的 `Impure.getJSON` 函数。

```js
const host = 'api.flickr.com';
const path = '/services/feeds/photos_public.gne';
const query = t => `?tags=${t}&format=json&jsoncallback=?`;
const url = t => `https://${host}${path}${query(t)}`;
```

There are fancy and overly complex ways of writing `url` pointfree using monoids(we'll learn about these later) or combinators. We've chosen to stick with a readable version and assemble this string in the normal pointful fashion.

Let's write an app function that makes the call and places the contents on the screen.

```js
const app = compose(Impure.getJSON(Impure.trace('response')), url);
app('cats');
```

这会调用我们的 `url` 函数，然后将字符串传递给我们的 `getJSON` 函数，该函数已经部分应用了 `trace`。加载应用程序将在控制台中显示来自 api 调用的响应。

<img src="images/console_ss.png" alt="控制台响应" />

我们想用这个 json 构建图像。看起来`mediaUrls` 被埋在`items` 中，然后是每个`media` 的`m` 属性。

无论如何，为了获得这些嵌套属性，我们可以使用来自 ramda 的一个很好的通用 getter 函数，称为 `prop`。这是一个本土版本，所以你可以看到发生了什么：

```js
const prop = curry((property, object) => object[property]);
```

It's quite dull actually. We just use `[]` syntax to access a property on whatever object. Let's use this to get at our `mediaUrls`.

```js
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
```

一旦我们收集了 `items`，我们必须对它们进行 `map` 以提取每个媒体 url。这会产生一个很好的 `mediaUrls` 数组。让我们将其连接到我们的应用程序并将它们打印在屏幕上。

```js
const render = compose(Impure.setHtml('#js-main'), mediaUrls);
const app = compose(Impure.getJSON(render), url);
```

All we've done is make a new composition that will call our `mediaUrls` and set the `<main>` html with them. We've replaced the `trace` call with `render` now that we have something to render besides raw json. This will crudely display our `mediaUrls` within the body.

Our final step is to turn these `mediaUrls` into bonafide `images`. In a bigger application, we'd use a template/dom library like Handlebars or React. For this application though, we only need an img tag so let's stick with jQuery.

```js
const img = src => $('<img />', { src });
```

jQuery 的`html` 方法将接受一个标签数组。我们只需要将我们的 mediaUrls 转换为图像并将它们发送到 `setHtml`。

```js
const images = compose(map(img), mediaUrls);
const render = compose(Impure.setHtml('#js-main'), images);
const app = compose(Impure.getJSON(render), url);
```

And we're done!

<img src="images/cats_ss.png" alt="cats grid" />

Here is the finished script:
[include](./exercises/ch06/main.js)

Now look at that. A beautifully declarative specification of what things are, not how they come to be. We now view each line as an equation with properties that hold. We can use these properties to reason about our application and refactor.

## A Principled Refactor

There is an optimization available - we map over each item to turn it into a media url, then we map again over those mediaUrls to turn them into img tags. There is a law regarding map and composition:


```js
// map's composition law
compose(map(f), map(g)) === map(compose(f, g));
```

我们可以使用这个属性来优化我们的代码。让我们进行有原则的重构。

```js
// original code
const mediaUrl = compose(prop('m'), prop('media'));
const mediaUrls = compose(map(mediaUrl), prop('items'));
const images = compose(map(img), mediaUrls);
```

Let's line up our maps. We can inline the call to `mediaUrls` in `images` thanks to equational reasoning and purity.

```js
const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(img), map(mediaUrl), prop('items'));
```

现在我们已经排列好了我们的地图，我们可以应用合成法则。

```js
/*
compose(map(f), map(g)) === map(compose(f, g));
compose(map(img), map(mediaUrl)) === map(compose(img, mediaUrl));
*/

const mediaUrl = compose(prop('m'), prop('media'));
const images = compose(map(compose(img, mediaUrl)), prop('items'));
```

现在，在将每个项目转换为 img 时，bugger 只会循环一次。让我们通过提取函数使其更具可读性。

```js
const mediaUrl = compose(prop('m'), prop('media'));
const mediaToImg = compose(img, mediaUrl);
const images = compose(map(mediaToImg), prop('items'));
```

## In Summary

We have seen how to put our new skills into use with a small, but real world app. We've used our mathematical framework to reason about and refactor our code. But what about error handling and code branching? How can we make the whole application pure instead of merely namespacing destructive functions? How can we make our app safer and more expressive? These are the questions we will tackle in part 2.

[Chapter 07: Hindley-Milner and Me](ch07.md)
