# 第04章：咖喱

## 没有你就活不下去
我父亲曾经解释过，在获得某些东西之前，人们可以没有它们。微波炉就是这样一种东西。智能手机，另一个。我们中间的老年人会记得没有互联网的充实生活。对我来说，咖喱就在这个名单上。

这个概念很简单：您可以使用比预期更少的参数来调用函数。它返回一个接受剩余参数的函数。

您可以选择一次调用它，也可以简单地逐个输入每个参数。

```js
const add = x => y => x + y;
const increment = add(1);
const addTen = add(10);

increment(2); // 3
addTen(2); // 12
```

这里我们创建了一个函数 `add`，它接受一个参数并返回一个函数。通过调用它，返回的函数从那时起通过闭包记住第一个参数。但是，同时使用两个参数调用它有点痛苦，因此我们可以使用一个名为 `curry` 的特殊辅助函数来简化定义和调用这样的函数。

让我们设置一些咖喱函数供我们欣赏。从现在开始，我们将召唤我们的‘咖喱’
[附录 A - 基本功能支持](./appendix_a.md) 中定义的函数。

```js
const match = curry((what, s) => s.match(what));
const replace = curry((what, replacement, s) => s.replace(what, replacement));
const filter = curry((f, xs) => xs.filter(f));
const map = curry((f, xs) => xs.map(f));
```

我遵循的模式很简单，但很重要。我策略性地将我们正在操作的数据（字符串，数组）定位为最后一个参数。使用时会很清楚为什么会这样。

（语法 `/r/g` 是一个正则表达式，意思是 _match 每个字母 'r'_。阅读 [更多关于正则表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript /Guide/Regular_Expressions) 如果你愿意。）

```js
match(/r/g, 'hello world'); // [ 'r' ]

const hasLetterR = match(/r/g); // x => x.match(/r/g)
hasLetterR('hello world'); // [ 'r' ]
hasLetterR('just j and s and t etc'); // null

filter(hasLetterR, ['rock and roll', 'smooth jazz']); // ['rock and roll']

const removeStringsWithoutRs = filter(hasLetterR); // xs => xs.filter(x => x.match(/r/g))
removeStringsWithoutRs(['rock and roll', 'smooth jazz', 'drum circle']); // ['rock and roll', 'drum circle']

const noVowels = replace(/[aeiou]/ig); // (r,x) => x.replace(/[aeiou]/ig, r)
const censored = noVowels('*'); // x => x.replace(/[aeiou]/ig, '*')
censored('Chocolate Rain'); // 'Ch*c*l*t* R**n'
```

这里演示的是能够“预加载”带有一两个参数的函数，以便接收记住这些参数的新函数。

我鼓励你克隆最充足的存储库（`git clone
https://github.com/MostlyAdequate/mostly-adequate-guide.git`)，复制上面的代码，有一个
在 REPL 中进行。 curry 函数，以及实际上在附录中定义的任何东西，
在 `support/index.js` 模块中可用。

或者，看看在 `npm` 上发布的版本：

```
npm install @mostly-adequate/support
```

## 不仅仅是双关语/特制酱汁

柯里化对很多事情都有用。我们可以通过给我们的基本函数一些参数来创建新函数，如 `hasLetterR`、`removeStringsWithoutRs` 和 `censored`。

我们还可以将任何作用于单个元素的函数转换为作用于数组的函数，只需将其用 `map` 包裹即可：

```js
const getChildren = x => x.childNodes;
const allTheChildren = map(getChildren);
```

为函数提供比预期更少的参数通常称为*部分应用*。部分应用一个函数可以删除很多样板代码。考虑一下上面的 `allTheChildren` 函数和 lodash 中未使用柯里化的 `map` 会是什么样子（注意参数的顺序不同）：

```js
const allTheChildren = elements => map(elements, getChildren);
```

我们通常不定义处理数组的函数，因为我们可以直接调用 `map(getChildren)`。与`sort`、`filter`和其他高阶函数相同（*高阶函数*是一个接受或返回函数的函数）。

当我们谈到*纯函数*时，我们说它们将 1 个输入变为 1 个输出。柯里化正是这样做的：每个参数返回一个新函数，期待剩余的参数。那，古老的运动，是 1 输入到 1 输出。

无论输出是否是另一个函数 - 它都符合纯函数的要求。我们确实一次允许多个参数，但这被视为只是为了方便起见删除了额外的“()”。


＃＃ 总之

柯里化很方便，我非常喜欢每天使用柯里化函数。它是一种腰带工具，使函数式编程不那么冗长乏味。

我们可以通过传入几个参数来动态创建新的、有用的函数，作为奖励，尽管有多个参数，我们仍然保留了数学函数定义。

让我们获得另一个名为“compose”的基本工具。

[第05章：组合编码](ch05.md)

## 练习

#### 练习注意事项

在整本书中，您可能会遇到像这样的“练习”部分。练习可以
如果您正在阅读 [gitbook](https://mostly-adequate.gitbooks.io/mostly-adequate-guide)（推荐），则直接在浏览器中完成。

请注意，对于本书的所有练习，您总是有一些辅助函数
在全局范围内可用。因此，在 [Appendix A](./appendix_a.md) 中定义的任何内容，
[附录 B](./appendix_b.md) 和 [附录 C](./appendix_c.md) 可供您使用！并作为
如果这还不够，一些练习还将定义特定于问题的函数
他们出席；事实上，考虑它们也是可用的。

> 提示：您可以通过在嵌入式编辑器中执行`Ctrl + Enter` 来提交您的解决方案！

#### 在您的机器上运行练习（可选）

如果您更喜欢使用自己的编辑器直接在文件中进行练习：

- 克隆存储库（`git clone git@github.com:MostlyAdequate/mostly-adequate-guide.git`）
- 进入 * 练习 * 部分（`cd 主要是足够的指南/练习`）
- 使用 [npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) 安装必要的管道（`npm install`）
- 通过修改对应章节文件夹中名为*exercise\_\**的文件来完成答案
- 使用 npm 运行更正（例如 `npm run ch04`）

单元测试将针对您的答案运行，并在出现错误时提供提示。顺便说一下，
练习的答案可在名为 *solution\_\** 的文件中找到。

＃＃＃＃ 让我们来练习！

{％ 锻炼 ％}
重构以通过部分应用函数来删除所有参数。
  
{% 初始 src="./exercises/ch04/exercise_a.js#L3;" %}
```js  
const words = str => split(' ', str);  
```  
  
{% 解决方案 src="./exercises/ch04/solution_a.js" %}
{% 验证 src="./exercises/ch04/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}


---


{％ 锻炼 ％}
重构以通过部分应用函数来删除所有参数。
  
{% 初始 src="./exercises/ch04/exercise_b.js#L3;" %}
```js  
const filterQs = xs => filter(x => match(/q/i, x), xs);
```  
  
{% 解决方案 src="./exercises/ch04/solution_b.js" %}
{% 验证 src="./exercises/ch04/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}


---


考虑以下功能：

```js  
const keepHighest = (x, y) => (x >= y ? x : y);  
```  

{％ 锻炼 ％}
重构 `max` 以不使用辅助函数 `keepHighest` 引用任何参数。
  
{% 初始 src="./exercises/ch04/exercise_c.js#L7;" %}
```js  
const max = xs => reduce((acc, x) => (x >= acc ? x : acc), -Infinity, xs);  
```  
  
{% 解决方案 src="./exercises/ch04/solution_c.js" %}
{% 验证 src="./exercises/ch04/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
