# 第12章：穿越石头

到目前为止，在我们的 Cirque du conteneur 中，您已经看到我们驯服了凶猛的 [functor](ch08.md#my-first-functor)，让它按照我们的意愿执行任何我们喜欢的操作。您已经对使用函数 [application](ch10.md) 收集结果同时处理许多危险效果感到眼花缭乱。坐在那里惊讶地发现容器通过 [joining](ch09.md) 消失在空气中。在副作用杂耍表演中，我们已经看到它们 [组合](ch08.md#a-spot-of-theory) 合二为一。最近，我们已经超越了自然的事物，并在您的眼前将一种类型[转换](ch11.md) 变成了另一种类型。

现在对于我们的下一个技巧，我们将研究遍历。我们将看到类型相互飙升，就好像他们是保持我们价值完好无损的空中飞人艺术家。我们将重新排序效果，例如倾斜旋转中的手推车。当我们的容器像柔术师的四肢一样交织在一起时，我们可以使用这个界面来理顺事情。我们将见证不同顺序的不同效果。把我的裤子拿来，吹口哨，让我们开始吧。

## 类型 n' 类型

让我们疯狂吧：

```js
// readFile :: FileName -> Task Error String

// firstWords :: String -> String
const firstWords = compose(intercalate(' '), take(3), split(' '));

// tldr :: FileName -> Task Error String
const tldr = compose(map(firstWords), readFile);

map(tldr, ['file1', 'file2']);
// [Task('hail the monarchy'), Task('smash the patriarchy')]
```

在这里，我们读取了一堆文件，最终得到了一堆无用的任务。我们如何分叉这些中的每一个？如果我们可以切换类型以使用 `Task Error [String]` 而不是 `[Task Error String]`，那将是最令人愉快的。那样的话，我们会有一个保存所有结果的未来值，这比几个空闲时到达的未来值更适合我们的异步需求。

这是粘性情况的最后一个示例：

```js
// getAttribute :: String -> Node -> Maybe String
// $ :: Selector -> IO Node

// getControlNode :: Selector -> IO (Maybe (IO Node))
const getControlNode = compose(map(map($)), map(getAttribute('aria-controls')), $);
```

看看那些'IO'渴望在一起。 “加入”他们会很可爱，让他们面颊跳舞，但遗憾的是，“也许”就像舞会上的伴侣一样站在他们之间。我们最好的做法是将它们的位置相互移动，这样每种类型最终都可以在一起，我们的签名可以简化为“IO（也许是节点）”。

## Type Feng Shui

*Traversable* 接口包含两个辉煌的功能：`sequence` 和`traverse`。

让我们使用 `sequence` 重新排列我们的类型：

```js
sequence(List.of, Maybe.of(['the facts'])); // [Just('the facts')]
sequence(Task.of, new Map({ a: Task.of(1), b: Task.of(2) })); // Task(Map({ a: 1, b: 2 }))
sequence(IO.of, Either.of(IO.of('buckle my shoe'))); // IO(Right('buckle my shoe'))
sequence(Either.of, [Either.of('wing')]); // Right(['wing'])
sequence(Task.of, left('wing')); // Task(Left('wing'))
```

See what has happened here? Our nested type gets turned inside out like a pair of leather trousers on a humid summer night. The inner functor is shifted to the outside and vice versa. It should be known that `sequence` is bit particular about its arguments. It looks like this:

```js
// sequence :: (Traversable t, Applicative f) => (a -> f a) -> t (f a) -> f (t a)
const sequence = curry((of, x) => x.sequence(of));
```

让我们从第二个论点开始。它必须是一个 *Traversable* 持有一个 *Applicative*，这听起来很严格，但碰巧经常是这种情况。是 `t (f a)` 变成了 `f (t a)`。这不是表达吗？这两种类型的do-si-do彼此很清楚。第一个参数只是一个拐杖，只有在无类型语言中才有必要。它提供了一个类型构造函数（我们的 *of*），以便我们可以反转 map-reluctant 类型，如 `Left` - 稍后会详细介绍。

使用`sequence`，我们可以像人行道上的提针器一样精确地转换类型。但它是如何工作的？让我们看看一个类型，比如“Either”，是如何实现它的：

```js
class Right extends Either {
  // ...
  sequence(of) {
    return this.$value.map(Either.of);
  }
}
```

Ah yes, if our `$value` is a functor (it must be an applicative, in fact), we can simply `map` our constructor to leap frog the type.

You may have noticed that we've ignored the `of` entirely. It is passed in for the occasion where mapping is futile, as is the case with `Left`:

```js
class Left extends Either {
  // ...
  sequence(of) {
    return of(this);
  }
}
```

我们希望这些类型总是以相同的排列结束，因此对于像 `Left` 这样的类型，他们实际上并不持有我们的内在应用程序，因此有必要在这样做时获得一点帮助。 *Applicative* 接口要求我们首先有一个 *Pointed Functor*，所以我们总是有一个 `of` 可以传入。在具有类型系统的语言中，可以从签名中推断出外部类型，不需要要明确给出。

## 效果分类

就我们的容器而言，不同的订单有不同的结果。如果我有`[Maybe a]`，那是可能值的集合，而如果我有`Maybe [a]`，那是可能值的集合。前者表示我们会原谅并保留“好的”，而后者表示这是一种“全有或全无”的情况。同样，`Either Error (Task Error a)` 可以代表客户端验证，而`Task Error (Either Error a)` 可以是服务器端验证。可以交换类型给我们不同的效果。

```js
// fromPredicate :: (a -> Bool) -> a -> Either e a

// partition :: (a -> Bool) -> [a] -> [Either e a]
const partition = f => map(fromPredicate(f));

// validate :: (a -> Bool) -> [a] -> Either e [a]
const validate = f => traverse(Either.of, fromPredicate(f));
```

这里我们有两个不同的函数，基于我们是 `map` 还是 `traverse`。第一个，`partition` 将根据谓词函数为我们提供一个由 `Left` 和 `Right` 组成的数组。这有助于保留宝贵的数据以备将来使用，而不是用洗澡水将其过滤掉。相反，`validate` 将给我们第一个未通过 `Left` 中的谓词的项目，或者如果一切都正常的话，则返回 `Right` 中的所有项目。通过选择不同的类型顺序，我们会得到不同的行为。

让我们看看`List`的`traverse`函数，看看`validate`方法是如何制作的。

```js
traverse(of, fn) {
    return this.$value.reduce(
      (f, a) => fn(a).map(b => bs => bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
```

This just runs a `reduce` on the list. The reduce function is `(f, a) => fn(a).map(b => bs => bs.concat(b)).ap(f)`, which looks a bit scary, so let's step through it.

1. `reduce(..., ...)`

   Remember the signature of `reduce :: [a] -> (f -> a -> f) -> f -> f`. The first argument is actually provided by the dot-notation on `$value`, so it's a list of things. 
   Then we need a function from a `f` (the accumulator) and a `a` (the iteree) to return us a new accumulator. 

2. `of(new List([]))`

   The seed value is `of(new List([]))`, which in our case is `Right([]) :: Either e [a]`. Notice that `Either e [a]` will also be our final resulting type!

3. `fn :: Applicative f => a -> f a`

   If we apply it to our example above, `fn` is actually `fromPredicate(f) :: a -> Either e a`.  
   > fn(a) :: Either e a

4. `.map(b => bs => bs.concat(b))`

   When `Right`, `Either.map` passes the right value to the function and returns a new `Right` with the result. In this case the function has one parameter (`b`), and returns another function (`bs => bs.concat(b)`, where `b` is in scope due to the closure). When `Left`, the left value is returned.  
   > fn(a).map(b => bs => bs.concat(b)) :: Either e ([a] -> [a])

5. .`ap(f)`

   Remember that `f` is an Applicative here, so we can apply the function `bs => bs.concat(b)` to whatever value `bs :: [a]` is in `f`. Fortunately for us, `f` comes from our initial seed and has the following type: `f :: Either e [a]` which is by the way, preserved when we apply `bs => bs.concat(b)`. 
   When `f` is `Right`, this calls `bs => bs.concat(b)`, which returns a `Right` with the item added to the list. When `Left`, the left value (from the previous step or previous iteration respectively) is returned. 
   > fn(a).map(b => bs => bs.concat(b)).ap(f) :: Either e [a]

This apparently miraculous transformation is achieved with just 6 measly lines of code in `List.traverse`, and is accomplished with `of`, `map` and `ap`, so will work for any Applicative Functor. This is a great example 
of how those abstraction can help to write highly generic code with only a few assumptions (that can, incidentally, be declared and checked at the type level!).

## Waltz of the Types

Time to revisit and clean our initial examples.

```js
// readFile :: FileName -> Task Error String

// firstWords :: String -> String
const firstWords = compose(intercalate(' '), take(3), split(' '));

// tldr :: FileName -> 任务错误字符串
const tldr = compose(map(firstWords), readFile);

traverse(Task.of, tldr, ['file1', 'file2']);
// Task(['hail the monarchy', 'smash the patriarchy']);
```

Using `traverse` instead of `map`, we've successfully herded those unruly `Task`s into a nice coordinated array of results. This is like `Promise.all()`, if you're familiar, except it isn't just a one-off, custom function, no, this works for any *traversable* type. These mathematical apis tend to capture most things we'd like to do in an interoperable, reusable way, rather than each library reinventing these functions for a single type.

Let's clean up the last example for closure (no, not that kind):

```js
// getAttribute :: String -> Node -> Maybe String
// $ :: Selector -> IO Node

// getControlNode :: Selector -> IO (Maybe Node)
const getControlNode = compose(chain(traverse(IO.of, $)), map(getAttribute('aria-controls')), $);
```

Instead of `map(map($))` we have `chain(traverse(IO.of, $))` which inverts our types as it maps then flattens the two `IO`s via `chain`.

## No Law and Order

Well now, before you get all judgemental and bang the backspace button like a gavel to retreat from the chapter, take a moment to recognize that these laws are useful code guarantees. 'Tis my conjecture that the goal of most program architecture is an attempt to place useful restrictions on our code to narrow the possibilities, to guide us into the answers as designers and readers.

An interface without laws is merely indirection. Like any other mathematical structure, we must expose properties for our own sanity. This has a similar effect as encapsulation since it protects the data, enabling us to swap out the interface with another law abiding citizen.

Come along now, we've got some laws to suss out.

### Identity

```js
const identity1 = compose(sequence(Identity.of), map(Identity.of));
const identity2 = Identity.of;

// 用 Right 测试一下
identity1(Either.of('stuff'));
// 身份（右（'东西'））

identity2(Either.of('stuff'));
// Identity(Right('stuff'))
```

This should be straightforward. If we place an `Identity` in our functor, then turn it inside out with `sequence` that's the same as just placing it on the outside to begin with. We chose `Right` as our guinea pig as it is easy to try the law and inspect. An arbitrary functor there is normal, however, the use of a concrete functor here, namely `Identity` in the law itself might raise some eyebrows. Remember a [category](ch05.md#category-theory) is defined by morphisms between its objects that have associative composition and identity. When dealing with the category of functors, natural transformations are the morphisms and `Identity` is, well identity. The `Identity` functor is as fundamental in demonstrating laws as our `compose` function. In fact, we should give up the ghost and follow suit with our [Compose](ch08.md#a-spot-of-theory) type:

### Composition

```js
const comp1 = compose(sequence(Compose.of), map(Compose.of));
const comp2 = (Fof, Gof) => compose(Compose.of, map(sequence(Gof)), sequence(Fof));


// 用我们现有的一些类型进行测试
comp1(Identity(Right([true])));
// Compose(Right([Identity(true)]))

comp2(Either.of, Array)(Identity(Right([true])));
// Compose(Right([Identity(true)]))
```

This law preserves composition as one would expect: if we swap compositions of functors, we shouldn't see any surprises since the composition is a functor itself. We arbitrarily chose `true`, `Right`, `Identity`, and `Array` to test it out. Libraries like [quickcheck](https://hackage.haskell.org/package/QuickCheck) or [jsverify](http://jsverify.github.io/) can help us test the law by fuzz testing the inputs.

As a natural consequence of the above law, we get the ability to [fuse traversals](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf), which is nice from a performance standpoint.

### Naturality

```js
const natLaw1 = (of, nt) => compose(nt, sequence(of));
const natLaw2 = (of, nt) => compose(sequence(of), map(nt));

// 使用随机自然变换和我们友好的 Identity/Right 函子进行测试。

//maybeToEither :: Maybe a -> Each () a
const MaybeToEither = x => (x.$value ? new Right(x.$value) : new Left());

natLaw1(Maybe.of,maybeToEither)(Identity.of(Maybe.of('barlow one')));
// 右（身份（'barlow one'））

natLaw2(Either.of, maybeToEither)(Identity.of(Maybe.of('barlow one')));
// Right(Identity('barlow one'))
```

This is similar to our identity law. If we first swing the types around then run a natural transformation on the outside, that should equal mapping a natural transformation, then flipping the types.

A natural consequence of this law is:

```js
traverse(A.of, A.of) === A.of;
```

从性能的角度来看，这又是一件好事。


＃＃ 总之

*Traversable* 是一个强大的界面，它使我们能够轻松地重新排列我们的类型，而远程动力室内设计师则可以使用它。我们可以用不同的顺序实现不同的效果，并消除那些使我们无法“加入”它们的令人讨厌的皱纹。接下来，我们将绕道而行，看看函数式编程中最强大的接口之一，甚至可能是代数本身：[Monoids 将它们整合在一起](ch13.md)

## 练习

考虑以下要素：

```js
// httpGet :: Route -> Task Error JSON

// routes :: Map Route Route
const routes = new Map({ '/': '/', '/about': '/about' });
```


{％ 锻炼 ％}
使用可遍历接口将`getJsons`的类型签名改为
Map Route Route → 任务错误（Map Route JSON）

  
{% initial src="./exercises/ch12/exercise_a.js#L11;" %}  
```js  
// getJsons :: Map Route Route -> Map Route (Task Error JSON)
const getJsons = map(httpGet);
```  
  
  
{% solution src="./exercises/ch12/solution_a.js" %}  
{% validation src="./exercises/ch12/validation_a.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
  
  
---  


We now define the following validation function:

```js
// validate :: Player -> Either String Player
const validate = player => (player.name ? Either.of(player) : left('must have name'));
```


{％ 锻炼 ％}
使用 traversable 和 `validate` 函数，更新 `startGame`（及其签名）
只有在所有玩家都有效时才开始游戏

  
{% initial src="./exercises/ch12/exercise_b.js#L7;" %}  
```js  
// startGame :: [Player] -> [Either Error String]
const startGame = compose(map(map(always('game started!'))), map(validate));
```  
  
  
{% solution src="./exercises/ch12/solution_b.js" %}  
{% validation src="./exercises/ch12/validation_b.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
  
  
---  


Finally, we consider some file-system helpers:

```js
// readfile :: String -> String -> Task Error String
// readdir :: String -> Task Error [String]
```

{％ 锻炼 ％}
使用 traversable 重新排列和展平嵌套的 Tasks & Maybe

  
{% initial src="./exercises/ch12/exercise_c.js#L8;" %}  
```js  
// readFirst :: String -> Task Error (Maybe (Task Error String))
const readFirst = compose(map(map(readfile('utf-8'))), map(safeHead), readdir);
```  
  
  
{% solution src="./exercises/ch12/solution_c.js" %}  
{% validation src="./exercises/ch12/validation_c.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
