# 第12章：穿越石头

到目前为止，在我们的 Cirque du conteneur 中，您已经看到我们驯服了凶猛的 [functor](ch08.md#my-first-functor)，让它按照我们的意愿执行任何我们喜欢的操作。您已经对使用函数 [application](ch10.md) 收集结果同时处理许多危险效果感到眼花缭乱。坐在那里惊讶地发现容器通过 [joining](ch09.md) 消失在空气中。在副作用杂耍表演中，我们已经看到它们 [组合](ch08.md#a-spot-of-theory) 合二为一。最近，我们已经超越了自然的事物，并在您的眼前将一种类型[转换](ch11.md) 变成了另一种类型。

现在对于我们的下一个技巧，我们将研究遍历。我们将看到类型相互飙升，就好像他们是保持我们价值完好无损的空中飞人艺术家。我们将重新排序效果，例如倾斜旋转中的手推车。当我们的容器像柔术师的四肢一样交织在一起时，我们可以使用这个界面来理顺事情。我们将见证不同顺序的不同效果。把我的裤子拿来，吹口哨，让我们开始吧。

## 类型 n' 类型

让我们疯狂吧：

```js
// readFile :: FileName -> Task Error String

// firstWords :: String -> String
const firstWords = compose(intercalate(' '), take(3), split(' '));

// tldr :: FileName -> Task Error String
const tldr = compose(map(firstWords), readFile);

map(tldr, ['file1', 'file2']);
// [Task('hail the monarchy'), Task('smash the patriarchy')]
```

在这里，我们读取了一堆文件，最终得到了一堆无用的任务。我们如何分叉这些中的每一个？如果我们可以切换类型以使用 `Task Error [String]` 而不是 `[Task Error String]`，那将是最令人愉快的。那样的话，我们会有一个保存所有结果的未来值，这比几个空闲时到达的未来值更适合我们的异步需求。

这是粘性情况的最后一个示例：

```js
// getAttribute :: String -> Node -> Maybe String
// $ :: Selector -> IO Node

// getControlNode :: Selector -> IO (Maybe (IO Node))
const getControlNode = compose(map(map($)), map(getAttribute('aria-controls')), $);
```

看看那些'IO'渴望在一起。 “加入”他们会很可爱，让他们面颊跳舞，但遗憾的是，“也许”就像舞会上的伴侣一样站在他们之间。我们最好的做法是将它们的位置相互移动，这样每种类型最终都可以在一起，我们的签名可以简化为“IO（也许是节点）”。

## Type Feng Shui

*Traversable* 接口包含两个辉煌的功能：`sequence` 和`traverse`。

让我们使用 `sequence` 重新排列我们的类型：

```js
sequence(List.of, Maybe.of(['the facts'])); // [Just('the facts')]
sequence(Task.of, new Map({ a: Task.of(1), b: Task.of(2) })); // Task(Map({ a: 1, b: 2 }))
sequence(IO.of, Either.of(IO.of('buckle my shoe'))); // IO(Right('buckle my shoe'))
sequence(Either.of, [Either.of('wing')]); // Right(['wing'])
sequence(Task.of, left('wing')); // Task(Left('wing'))
```

看看这里发生了什么？在潮湿的夏夜，我们的嵌套类型像一条皮裤一样内外翻转。内部函子移到外面，反之亦然。应该知道，`sequence` 对它的参数有点讲究。它看起来像这样：

```js
// sequence :: (Traversable t, Applicative f) => (a -> f a) -> t (f a) -> f (t a)
const sequence = curry((of, x) => x.sequence(of));
```

让我们从第二个论点开始。它必须是一个 *Traversable* 持有一个 *Applicative*，这听起来很严格，但碰巧经常是这种情况。是 `t (f a)` 变成了 `f (t a)`。这不是表达吗？这两种类型的do-si-do彼此很清楚。第一个参数只是一个拐杖，只有在无类型语言中才有必要。它提供了一个类型构造函数（我们的 *of*），以便我们可以反转 map-reluctant 类型，如 `Left` - 稍后会详细介绍。

使用`sequence`，我们可以像人行道上的提针器一样精确地转换类型。但它是如何工作的？让我们看看一个类型，比如“Either”，是如何实现它的：

```js
class Right extends Either {
  // ...
  sequence(of) {
    return this.$value.map(Either.of);
  }
}
```

是的，如果我们的 `$value` 是一个函子（实际上它必须是一个应用程序），我们可以简单地 `map` 我们的构造函数来跳过类型。

您可能已经注意到我们完全忽略了 `of`。它是在映射无效的情况下传入的，就像 `Left` 的情况一样：

```js
class Left extends Either {
  // ...
  sequence(of) {
    return of(this);
  }
}
```

我们希望这些类型总是以相同的排列结束，因此对于像 `Left` 这样的类型，他们实际上并不持有我们的内在应用程序，因此有必要在这样做时获得一点帮助。 *Applicative* 接口要求我们首先有一个 *Pointed Functor*，所以我们总是有一个 `of` 可以传入。在具有类型系统的语言中，可以从签名中推断出外部类型，不需要要明确给出。

## 效果分类

就我们的容器而言，不同的订单有不同的结果。如果我有`[Maybe a]`，那是可能值的集合，而如果我有`Maybe [a]`，那是可能值的集合。前者表示我们会原谅并保留“好的”，而后者表示这是一种“全有或全无”的情况。同样，`Either Error (Task Error a)` 可以代表客户端验证，而`Task Error (Either Error a)` 可以是服务器端验证。可以交换类型给我们不同的效果。

```js
// fromPredicate :: (a -> Bool) -> a -> Either e a

// partition :: (a -> Bool) -> [a] -> [Either e a]
const partition = f => map(fromPredicate(f));

// validate :: (a -> Bool) -> [a] -> Either e [a]
const validate = f => traverse(Either.of, fromPredicate(f));
```

这里我们有两个不同的函数，基于我们是 `map` 还是 `traverse`。第一个，`partition` 将根据谓词函数为我们提供一个由 `Left` 和 `Right` 组成的数组。这有助于保留宝贵的数据以备将来使用，而不是用洗澡水将其过滤掉。相反，`validate` 将给我们第一个未通过 `Left` 中的谓词的项目，或者如果一切都正常的话，则返回 `Right` 中的所有项目。通过选择不同的类型顺序，我们会得到不同的行为。

让我们看看`List`的`traverse`函数，看看`validate`方法是如何制作的。

```js
traverse(of, fn) {
    return this.$value.reduce(
      (f, a) => fn(a).map(b => bs => bs.concat(b)).ap(f),
      of(new List([])),
    );
  }
```

这只是在列表上运行一个 `reduce`。 reduce函数是`(f, a) => fn(a).map(b => bs => bs.concat(b)).ap(f)`，看起来有点吓人，让我们一步一步来.

1.`减少（...，...）`

   记住 `reduce :: [a] -> (f -> a -> f) -> f -> f` 的签名。第一个参数实际上是由 $value 上的点符号提供的，所以它是一个列表。
   然后我们需要一个来自 `f`（累加器）和一个 `a`（iteree）的函数来返回一个新的累加器。

2.`of(new List([]))`

   种子值是`of(new List([]))`，在我们的例子中是`Right([]) :: Each e [a]`。请注意，`Either e [a]` 也将是我们最终的结果类型！

3. `fn :: Applicative f => a -> f a`

   如果我们把它应用到我们上面的例子中，`fn` 实际上是 `fromPredicate(f) :: a -> Each e a`。
   > fn (a) :: e a

4.`.map(b => bs => bs.concat(b))`

   当`Right` 时，`Either.map` 将正确的值传递给函数并返回一个带有结果的新的`Right`。在这种情况下，函数有一个参数（`b`），并返回另一个函数（`bs => bs.concat(b)`，其中由于闭包，`b` 在范围内）。当为“Left”时，返回左值。
   > fn(a).map(b => bs => bs.concat(b)) :: e ([a] -> [a])

5. .`ap(f)`

   记住 `f` 在这里是一个 Applicative，所以我们可以将函数 `bs => bs.concat(b)` 应用到 `bs :: [a]` 在 `f` 中的任何值。对我们来说幸运的是，`f` 来自我们的初始种子，并且具有以下类型：`f :: Each e [a]` 顺便说一下，在我们应用 `bs => bs.concat(b)` 时会保留。
   当 `f` 是 `Right` 时，这会调用 `bs => bs.concat(b)`，它返回一个 `Right`，其中的项目被添加到列表中。当为“Left”时，返回左值（分别来自上一步或上一次迭代）。
   > fn(a).map(b => bs => bs.concat(b)).ap(f) :: e [a]

这个看似神奇的转换是在 List.traverse 中仅用 6 行微不足道的代码就可以实现的，并且是通过 `of`、`map` 和 `ap` 实现的，因此适用于任何 Applicative Functor。这是一个很好的例子
这些抽象如何帮助编写高度通用的代码，只需几个假设（顺便说一下，可以在类型级别声明和检查！）。

## 类型的华尔兹

是时候重新审视和清理我们最初的例子了。

```js
// readFile :: FileName -> Task Error String

// firstWords :: String -> String
const firstWords = compose(intercalate(' '), take(3), split(' '));

// tldr :: FileName -> Task Error String
const tldr = compose(map(firstWords), readFile);

traverse(Task.of, tldr, ['file1', 'file2']);
// Task(['hail the monarchy', 'smash the patriarchy']);
```

使用 `traverse` 而不是 `map`，我们已经成功地将那些不守规矩的 `Task` 集中到一个很好的协调结果数组中。这就像`Promise.all()`，如果你熟悉的话，除了它不仅仅是一个一次性的自定义函数，不，这适用于任何 *traversable* 类型。这些数学 api 倾向于以可互操作、可重用的方式捕获我们想要做的大多数事情，而不是每个库都为单一类型重新发明这些函数。

让我们清理最后一个闭包示例（不，不是那种）：

```js
// getAttribute :: String -> Node -> Maybe String
// $ :: Selector -> IO Node

// getControlNode :: Selector -> IO (Maybe Node)
const getControlNode = compose(chain(traverse(IO.of, $)), map(getAttribute('aria-controls')), $);
```

我们有 `chain(traverse(IO.of, $))` 代替 `map(map($))`，它在映射时反转我们的类型，然后通过 `chain` 将两个 `IO` 展平。

##没有法律和秩序

现在，在您做出所有判断并像木槌一样敲击退格按钮以退出本章之前，请花点时间认识到这些法律是有用的代码保证。 '这是我的推测，大多数程序架构的目标是试图对我们的代码施加有用的限制，以缩小可能性，引导我们作为设计者和读者找到答案。

没有规律的接口只是间接的。像任何其他数学结构一样，我们必须为了自己的理智公开属性。这与封装具有类似的效果，因为它保护数据，使我们能够与另一个守法公民交换接口。

现在来吧，我们有一些法律需要弄清楚。

＃＃＃ 身份

```js
const identity1 = compose(sequence(Identity.of), map(Identity.of));
const identity2 = Identity.of;

// test it out with Right
identity1(Either.of('stuff'));
// Identity(Right('stuff'))

identity2(Either.of('stuff'));
// Identity(Right('stuff'))
```

这应该很简单。如果我们在我们的函子中放置一个 `Identity`，然后用 `sequence` 将它翻过来，这与刚开始时将它放在外面是一样的。我们选择了“Right”作为我们的豚鼠，因为它很容易尝试法律和检查。一个任意的函子是正常的，然而，在这里使用一个具体的函子，即法律本身中的“身份”可能会引起一些人的注意。请记住，[category](ch05.md#category-theory) 是由其对象之间的态射定义的，这些对象具有关联组合和身份。在处理函子的范畴时，自然变换是态射，而“恒等式”是恒等式。 `Identity` 函子和我们的 `compose` 函数一样，是证明定律的基础。事实上，我们应该放弃ghost并效仿我们的[Compose](ch08.md#a-spot-of-theory)类型：

＃＃＃ 作品

```js
const comp1 = compose(sequence(Compose.of), map(Compose.of));
const comp2 = (Fof, Gof) => compose(Compose.of, map(sequence(Gof)), sequence(Fof));


// Test it out with some types we have lying around
comp1(Identity(Right([true])));
// Compose(Right([Identity(true)]))

comp2(Either.of, Array)(Identity(Right([true])));
// Compose(Right([Identity(true)]))
```

该定律保留了人们所期望的组合：如果我们交换函子的组合，我们应该不会看到任何意外，因为组合本身就是一个函子。我们随意选择了`true`、`Right`、`Identity`和`Array`来测试一下。像 [quickcheck](https://hackage.haskell.org/package/QuickCheck) 或 [jsverify](http://jsverify.github.io/) 这样的库可以通过对输入进行模糊测试来帮助我们测试法律。

作为上述定律的自然结果，我们获得了[融合遍历](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)的能力，这从性能上来说很好立场。

### 自然

```js
const natLaw1 = (of, nt) => compose(nt, sequence(of));
const natLaw2 = (of, nt) => compose(sequence(of), map(nt));

// test with a random natural transformation and our friendly Identity/Right functors.

// maybeToEither :: Maybe a -> Either () a
const maybeToEither = x => (x.$value ? new Right(x.$value) : new Left());

natLaw1(Maybe.of, maybeToEither)(Identity.of(Maybe.of('barlow one')));
// Right(Identity('barlow one'))

natLaw2(Either.of, maybeToEither)(Identity.of(Maybe.of('barlow one')));
// Right(Identity('barlow one'))
```

这类似于我们的身份法。如果我们首先摆动类型，然后在外部运行自然转换，这应该等于映射自然转换，然后翻转类型。

该法的自然结果是：

```js
traverse(A.of, A.of) === A.of;
```

从性能的角度来看，这又是一件好事。


＃＃ 总之

*Traversable* 是一个强大的界面，它使我们能够轻松地重新排列我们的类型，而远程动力室内设计师则可以使用它。我们可以用不同的顺序实现不同的效果，并消除那些使我们无法“加入”它们的令人讨厌的皱纹。接下来，我们将绕道而行，看看函数式编程中最强大的接口之一，甚至可能是代数本身：[Monoids 将它们整合在一起](ch13.md)

## 练习

考虑以下要素：

```js
// httpGet :: Route -> Task Error JSON

// routes :: Map Route Route
const routes = new Map({ '/': '/', '/about': '/about' });
```


{％ 锻炼 ％}
使用可遍历接口将`getJsons`的类型签名改为
Map Route Route → 任务错误（Map Route JSON）

  
{% 初始 src="./exercises/ch12/exercise_a.js#L11;" %}
```js  
// getJsons :: Map Route Route -> Map Route (Task Error JSON)
const getJsons = map(httpGet);
```  
  
  
{% 解决方案 src="./exercises/ch12/solution_a.js" %}
{% 验证 src="./exercises/ch12/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
  
  
---


我们现在定义以下验证函数：

```js
// validate :: Player -> Either String Player
const validate = player => (player.name ? Either.of(player) : left('must have name'));
```


{％ 锻炼 ％}
使用 traversable 和 `validate` 函数，更新 `startGame`（及其签名）
只有在所有玩家都有效时才开始游戏

  
{% 初始 src="./exercises/ch12/exercise_b.js#L7;" %}
```js  
// startGame :: [Player] -> [Either Error String]
const startGame = compose(map(map(always('game started!'))), map(validate));
```  
  
  
{% 解决方案 src="./exercises/ch12/solution_b.js" %}
{% 验证 src="./exercises/ch12/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
  
  
---


最后，我们考虑一些文件系统助手：

```js
// readfile :: String -> String -> Task Error String
// readdir :: String -> Task Error [String]
```

{％ 锻炼 ％}
使用 traversable 重新排列和展平嵌套的 Tasks & Maybe

  
{% 初始 src="./exercises/ch12/exercise_c.js#L8;" %}
```js  
// readFirst :: String -> Task Error (Maybe (Task Error String))
const readFirst = compose(map(map(readfile('utf-8'))), map(safeHead), readdir);
```  
  
  
{% 解决方案 src="./exercises/ch12/solution_c.js" %}
{% 验证 src="./exercises/ch12/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
