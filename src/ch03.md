# 第 3 章：纯函数带来的纯幸福

##哦要再次纯洁

我们需要弄清楚的一件事是纯函数的概念。

> 纯函数是一个函数，给定相同的输入，将始终返回相同的输出并且没有任何可观察到的副作用。

以“切片”和“拼接”为例。它们是做完全相同的事情的两个函数 - 请注意，以截然不同的方式，但仍然是同一件事。我们说 `slice` 是 _pure_ 是因为它每次输入都返回相同的输出，保证。然而，`splice` 会咀嚼它的数组并将它永远改变后吐出来，这是一个可观察到的效果。

```js
const xs = [1, 2, 3, 4, 5]

// pure
xs.slice(0, 3) // [1,2,3]

xs.slice(0, 3) // [1,2,3]

xs.slice(0, 3) // [1,2,3]

// impure
xs.splice(0, 3) // [1,2,3]

xs.splice(0, 3) // [4,5]

xs.splice(0, 3) // []
```

在函数式编程中，我们不喜欢像 `splice` 这样的笨拙的函数来 _mutate_ 数据。这永远不会发生，因为我们正在努力寻找每次都返回相同结果的可靠函数，而不是像 `splice` 那样会留下一团糟的函数。

让我们再看一个例子。

```js
// impure
let minimum = 21
const checkAge = (age) => age >= minimum

// pure
const checkAge = (age) => {
  const minimum = 21
  return age >= minimum
}
```

在不纯的部分，`checkAge` 依赖于可变变量 `minimum` 来确定结果。换句话说，它取决于系统状态，这是令人失望的，因为它通过引入外部环境增加了[认知负荷](https://en.wikipedia.org/wiki/Cognitive_load)。

在这个例子中它可能看起来并不多，但这种对状态的依赖是系统复杂性的最大贡献者之一 (http://curtclifton.net/papers/MoseleyMarks06a.pdf)。这个 `checkAge` 可能会返回不同的结果，这取决于输入的外部因素，这不仅使它失去纯粹的资格，而且每次我们对软件进行推理时都会使我们的思想陷入困境。

另一方面，它的纯粹形式是完全自给自足的。我们还可以让 `minimum` 不可变，这样可以保持状态的纯度，因为状态永远不会改变。为此，我们必须创建一个对象来冻结。

```js
const immutableState = Object.freeze({ minimum: 21 })
```

## 副作用可能包括...

让我们更多地看看这些“副作用”，以提高我们的直觉。那么在*纯函数*的定义中提到的这个无疑是邪恶的*副作用*是什么？我们将把 _effect_ 称为在我们的计算中发生的任何事情，而不是结果的计算。

效果本质上没有什么坏处，我们将在接下来的章节中到处使用它们。这是带有负面含义的 _side_ 部分。水本身并不是幼虫的固有孵化器，它是产生群体的*停滞*部分，我向你保证，\*副作用在你自己的程序中是类似的滋生地。

> *副作用*是在计算结果期间发生的系统状态或与外部世界的*可观察交互*的变化。

副作用可能包括但不限于

- 改变文件系统
- 向数据库中插入一条记录
- 进行 http 调用
- 突变 \*打印到屏幕/记录
- 获取用户输入
- 查询 DOM
- 访问系统状态

这样的例子不胜枚举。与函数之外的世界的任何交互都是副作用，这一事实可能会促使您怀疑没有它们的编程的实用性。函数式编程的哲学假设副作用是导致错误行为的主要原因。

并不是我们被禁止使用它们，而是我们想要控制它们并以受控方式运行它们。当我们在后面的章节中讨论函子和 monad 时，我们将学习如何做到这一点，但现在，让我们尝试将这些隐匿的函数与我们的纯函数分开。

副作用使函数失去*纯*的资格。这是有道理的：根据定义，纯函数必须始终在给定相同输入的情况下返回相同的输出，这在处理本地函数之外的问题时是无法保证的。

让我们仔细看看为什么我们坚持每个输入的输出相同。弹出你的衣领，我们要看看一些 8 年级的数学。

## 8 年级数学

来自 mathisfun.com：

> 函数是值之间的特殊关系：
> 它的每个输入值只返回一个输出值。

换句话说，它只是两个值之间的关系：输入和输出。尽管每个输入只有一个输出，但每个输入的输出不一定是唯一的。下面显示了一个完全有效的函数图，从 `x` 到 `y`；

<img src="images/function-sets.gif" alt="函数集" />(https://www.mathsisfun.com/sets/function.html)

相比之下，下图显示了一个*不是*函数的关系，因为输入值“5”指向多个输出：

<img src="images/relation-not-function.gif" alt="relation not function" />(https://www.mathsisfun.com/sets/function.html)

函数可以被描述为一组具有位置（输入，输出）的对：`[(1,2), (3,6), (5,10)]`（看起来这个函数将其输入加倍）。

或者也许是一张桌子：

<table><tr><th>输入</th><th>输出</th></tr><tr><td>1</td><td> 2</td></tr><tr><td> 2</td><td> 4</td></tr><tr><td> 3</td><td> 6</td></tr></table>

或者甚至是一个以 `x` 作为输入和 `y` 作为输出的图形：

<img src="images/fn_graph.png" width="300" height="300" alt="函数图" />

如果输入决定输出，则不需要实现细节。由于函数只是输入到输出的映射，因此可以简单地记下对象字面量并使用 `[]` 而不是 `()` 来运行它们。

```js
const toLowerCase = {
  A: 'a',
  B: 'b',
  C: 'c',
  D: 'd',
  E: 'e',
  F: 'f',
}
toLowerCase['C'] // 'c'

const isPrime = {
  1: false,
  2: true,
  3: true,
  4: false,
  5: true,
  6: false,
}
isPrime[3] // true
```

当然，您可能想要计算而不是手写，但这说明了考虑函数的不同方式。 （您可能会想“带有多个参数的函数呢？”。确实，这在从数学角度考虑时会带来一些不便。现在，我们可以将它们捆绑在一个数组中，或者只考虑“参数”对象作为输入。当我们了解 _currying_ 时，我们将看到如何直接对函数的数学定义进行建模。）

这里有一个戏剧性的启示：纯函数*是*数学函数，它们是函数式编程的全部内容。与这些小天使一起编程可以带来巨大的好处。让我们来看看为什么我们愿意竭尽全力保持纯洁的一些原因。

## 纯洁的案例

### 可缓存

对于初学者来说，纯函数总是可以通过输入缓存。这通常使用一种称为记忆化的技术来完成：

```js
const squareNumber = memoize((x) => x * x)

squareNumber(4) // 16

squareNumber(4) // 16, returns cache for input 4

squareNumber(5) // 25

squareNumber(5) // 25, returns cache for input 5
```

这是一个简化的实现，尽管有很多更强大的版本可用。

```js
const memoize = (f) => {
  const cache = {}

  return (...args) => {
    const argStr = JSON.stringify(args)
    cache[argStr] = cache[argStr] || f(...args)
    return cache[argStr]
  }
}
```

需要注意的是，您可以通过延迟评估将一些不纯的函数转化为纯函数：

```js
const pureHttpCall = memoize((url, params) => () => $.getJSON(url, params))
```

有趣的是，我们实际上并没有进行 http 调用——而是返回一个在调用时会这样做的函数。这个函数是纯函数，因为在给定相同的输入的情况下它总是返回相同的输出：给定 `url` 和 `params` 的函数将进行特定的 http 调用。

我们的 `memoize` 函数工作得很好，虽然它不缓存 http 调用的结果，而是缓存生成的函数。

这还不是很有用，但我们很快就会学习一些技巧来使它有用。要点是我们可以缓存每个函数，无论它们看起来多么具有破坏性。

### 便携/自记录

纯函数是完全自包含的。功能所需的一切都放在一个银盘上。想一想……这有什么好处？对于初学者来说，函数的依赖关系是明确的，因此更容易看到和理解——幕后没有什么有趣的事情发生。

```js
// impure
const signUp = (attrs) => {
  const user = saveUser(attrs)
  welcomeUser(user)
}

// pure
const signUp = (Db, Email, attrs) => () => {
  const user = saveUser(Db, attrs)
  welcomeUser(Email, user)
}
```

这里的例子表明，纯函数必须诚实地说明它的依赖关系，并因此准确地告诉我们它在做什么。仅从它的签名中，我们就知道它将使用一个 `Db`、`Email` 和 `attrs`，至少可以这么说。

我们将学习如何在不延迟求值的情况下使这种函数成为纯函数，但重点应该明确的是，纯函数形式比其狡猾的不纯函数提供的信息要多得多，这取决于谁知道。

还有一点需要注意的是，我们被迫“注入”依赖项，或将它们作为参数传递，这使我们的应用程序更加灵活，因为我们已经参数化了我们的数据库或邮件客户端或您拥有的东西（别担心，我们将看到一种方法来使这比听起来不那么乏味）。如果我们选择使用不同的 Db，我们只需要用它来调用我们的函数。如果我们发现自己正在编写一个新的应用程序，我们想在其中重用这个可靠的函数，我们只需给这个函数提供我们当时拥有的任何 `Db` 和 `Email`。

在 JavaScript 设置中，可移植性可能意味着通过套接字序列化和发送函数。这可能意味着在网络工作者中运行我们所有的应用程序代码。便携性是一个强大的特性。

与命令式编程中的“典型”方法和过程相反，它们通过状态、依赖关系和可用效果深深植根于其环境中，纯函数可以在我们心中想要的任何地方运行。

您最后一次将方法复制到新应用中是什么时候？我最喜欢的一句话来自 Erlang 的创造者乔·阿姆斯特朗：“面向对象语言的问题在于它们有所有这些隐含的环境，它们随身携带。你想要一个香蕉，但你得到的是一只拿着香蕉……还有整个丛林”。

### 可测试

接下来，我们开始意识到纯函数使测试变得更加容易。我们不必在每次测试后模拟“真正的”支付网关或设置和断言世界状态。我们只是给函数输入和断言输出。

事实上，我们发现功能社区开创了新的测试工具，可以用生成的输入来爆炸我们的功能，并断言属性保持输出。这超出了本书的范围，但我强烈建议您搜索并尝试*Quickcheck*——一种专为纯功能环境量身定制的测试工具。

＃＃＃ 合理的

许多人认为使用纯函数最大的好处是*引用透明*。当一个代码点可以代替它的评估值而不改变程序的行为时，它是引用透明的。

由于纯函数没有副作用，它们只能通过其输出值影响程序的行为。此外，由于可以仅使用其输入值可靠地计算它们的输出值，因此纯函数将始终保持引用透明性。让我们看一个例子。

```js
const { Map } = require('immutable')

// Aliases: p = player, a = attacker, t = target
const jobe = Map({ name: 'Jobe', hp: 20, team: 'red' })
const michael = Map({ name: 'Michael', hp: 20, team: 'green' })
const decrementHP = (p) => p.set('hp', p.get('hp') - 1)
const isSameTeam = (p1, p2) => p1.get('team') === p2.get('team')
const punch = (a, t) => (isSameTeam(a, t) ? t : decrementHP(t))

punch(jobe, michael) // Map({name:'Michael', hp:19, team: 'green'})
```

`decrementHP`、`isSameTeam` 和 `punch` 都是纯粹的，因此引用透明。我们可以使用一种称为 _ 等式推理 _ 的技术，其中用“等于”代替“等于”来推理代码。这有点像手动评估代码而不考虑程序评估的怪癖。使用引用透明度，让我们稍微玩一下这段代码。

首先，我们将内联函数 `isSameTeam`。

```js
const punch = (a, t) => (a.get('team') === t.get('team') ? t : decrementHP(t))
```

由于我们的数据是不可变的，我们可以简单地用他们的实际价值替换团队

```js
const punch = (a, t) => ('red' === 'green' ? t : decrementHP(t))
```

我们看到在这种情况下它是假的，所以我们可以删除整个 if 分支

```js
const punch = (a, t) => decrementHP(t)
```

如果我们内联 `decrementHP`，我们会看到，在这种情况下，punch 变成了将 `hp` 减 1 的调用。

```js
const punch = (a, t) => t.set('hp', t.get('hp') - 1)
```

这种对代码进行推理的能力对于重构和理解代码来说是非常棒的。事实上，我们使用这种技术来重构我们的海鸥群程序。我们使用等式推理来利用加法和乘法的特性。事实上，我们将在整本书中使用这些技术。

### 并行代码

最后，这里是妙招，我们可以并行运行任何纯函数，因为它不需要访问共享内存，并且根据定义，由于某些副作用，它不会出现竞争条件。

这在具有线程的服务器端 js 环境中以及在具有 Web Worker 的浏览器中是很有可能的，尽管由于处理不纯函数时的复杂性，当前的文化似乎避免了它。

＃＃ 总之

我们已经了解了纯函数是什么以及为什么我们作为函数式程序员相信它们是猫的晚装。从现在开始，我们将努力以纯粹的方式编写所有函数。我们需要一些额外的工具来帮助我们做到这一点，但与此同时，我们将尝试将不纯函数与其余纯代码分开。

如果没有一些额外的工具，用纯函数编写程序会有点费力。我们必须通过到处传递参数来处理数据，我们被禁止使用状态，更不用说效果了。如何编写这些受虐狂的程序？让我们获得一个叫做 curry 的新工具。

【第 04 章：咖喱】(ch04.md)
