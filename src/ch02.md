# 第 2 章：一等函数

## 快速回顾

当我们说函数是“一流的”时，我们的意思是它们就像其他人一样......所以换句话说，一个普通的类。我们可以像对待任何其他数据类型一样对待函数，它们没有什么特别之处——它们可以存储在数组中，作为函数参数传递，分配给变量，等等。

那是 JavaScript 101，但值得一提，因为在 github 上快速搜索代码将揭示集体逃避，或者可能是对这个概念的普遍无知。我们要假装举个例子吗？我们应该。

```js
const hi = (name) => `Hi ${name}`
const greeting = (name) => hi(name)
```

在这里，`greeting` 中`hi` 的函数包装器是完全多余的。为什么？因为函数在 JavaScript 中是*可调用的*。当 `hi` 末尾有 `()` 时，它将运行并返回一个值。如果没有，它只是返回存储在变量中的函数。可以肯定的是，看看你自己：

```js
hi // name => `Hi ${name}`
hi('jonas') // "Hi jonas"
```

由于 `greeting` 只是反过来用相同的参数调用 `hi`，我们可以简单地写：

```js
const greeting = hi
greeting('times') // "Hi times"
```

换句话说，`hi` 已经是一个需要一个参数的函数，为什么要在它周围放置另一个函数，它只是用相同的参数调用 `hi`？它没有任何他妈的意义。这就像在七月的死期穿上你最重的派克大衣，只是为了吹爆空气并要求吃冰棍。

这是令人讨厌的冗长，而且碰巧的是，将一个函数与另一个函数包围起来只是为了延迟评估是不好的做法（稍后我们将看到原因，但这与维护有关）

在继续之前，充分理解这一点至关重要，因此让我们检查一些从 npm 包库中挖掘出的更有趣的示例。

```js
// ignorant
const getServerStuff = (callback) => ajaxCall((json) => callback(json))

// enlightened
const getServerStuff = ajaxCall
```

世界上到处都是这样的 ajax 代码。这是两者等效的原因：

```js
// this line
ajaxCall((json) => callback(json))

// is the same as this line
ajaxCall(callback)

// so refactor getServerStuff
const getServerStuff = (callback) => ajaxCall(callback)

// ...which is equivalent to this
const getServerStuff = ajaxCall // <-- look mum, no ()'s
```

伙计们，这就是它的完成方式。再一次让我们明白为什么我如此执着。

```js
const BlogController = {
  index(posts) {
    return Views.index(posts)
  },
  show(post) {
    return Views.show(post)
  },
  create(attrs) {
    return Db.create(attrs)
  },
  update(post, attrs) {
    return Db.update(post, attrs)
  },
  destroy(post) {
    return Db.destroy(post)
  },
}
```

这个荒谬的控制器是 99% 的绒毛。我们可以将其重写为：

```js
const BlogController = {
  index: Views.index,
  show: Views.show,
  create: Db.create,
  update: Db.update,
  destroy: Db.destroy,
}
```

...或者完全废弃它，因为它只是将我们的 Views 和 Db 捆绑在一起。

## 为什么偏爱头等舱？

好的，让我们深入了解支持一流功能的原因。正如我们在 `getServerStuff` 和 `BlogController` 示例中看到的那样，很容易添加不提供附加值的间接层，只会增加需要维护和搜索的冗余代码量。

此外，如果必须更改这样一个不必要的包装函数，我们也必须更改我们的包装函数。

```js
httpGet('/post/2', (json) => renderPost(json))
```

如果 `httpGet` 更改为发送可能的 `err`，我们将需要返回并更改“胶水”。

```js
// go back to every httpGet call in the application and explicitly pass err along.
httpGet('/post/2', (json, err) => renderPost(json, err))
```

如果我们将其编写为一流的函数，则不需要更改：

```js
// renderPost is called from within httpGet with however many arguments it wants
httpGet('/post/2', renderPost)
```

除了删除不必要的函数之外，我们还必须命名和引用参数。你看，名字有点问题。我们有潜在的用词不当——尤其是随着代码库的老化和需求的变化。

同一个概念有多个名称是项目中常见的混淆来源。还有通用代码的问题。例如，这两个函数做的完全一样，但感觉更通用和可重用：

```js
// specific to our current blog
const validArticles = articles =>
  articles.filter(article => article !== null && article !== undefined),

// vastly more relevant for future projects
const compact = xs => xs.filter(x => x !== null && x !== undefined);
```

通过使用特定的命名，我们似乎将自己与特定的数据（在本例中为“文章”）联系在一起。这种情况经常发生，并且是许多重塑的源泉。

我必须提到的是，就像面向对象的代码一样，你必须意识到 `this` 会咬你一口。如果底层函数使用 this 并且我们称它为第一类，我们就会受到这种泄漏抽象的愤怒。

```js
const fs = require('fs')

// scary
fs.readFile('freaky_friday.txt', Db.save)

// less so
fs.readFile('freaky_friday.txt', Db.save.bind(Db))
```

与自身绑定后，`Db` 可以自由访问其原型垃圾代码。我避免像脏尿布一样使用“this”。编写函数式代码时真的没有必要。但是，在与其他库交互时，您可能不得不默许我们周围的疯狂世界。

有些人会争辩说，“this”对于优化速度是必要的。如果你是微优化排序，请关闭本书。如果你不能拿回你的钱，也许你可以把它换成更复杂的东西。

有了这个，我们准备继续前进。

【第 03 章：纯粹的幸福，纯粹的功能】(ch03.md)
