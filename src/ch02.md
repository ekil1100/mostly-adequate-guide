# 第 2 章：一等函数

## 快速回顾
当我们说函数是“一流的”时，我们的意思是它们就像其他人一样......所以换句话说，一个普通的类。我们可以像对待任何其他数据类型一样对待函数，它们没有什么特别之处——它们可以存储在数组中，作为函数参数传递，分配给变量，等等。

那是 JavaScript 101，但值得一提，因为在 github 上快速搜索代码将揭示集体逃避，或者可能是对这个概念的普遍无知。我们要假装举个例子吗？我们应该。

```js
const hi = name => `Hi ${name}`;
const greeting = name => hi(name);
```

Here, the function wrapper around `hi` in `greeting` is completely redundant. Why? Because functions are *callable* in JavaScript. When `hi` has the `()` at the end it will run and return a value. When it does not, it simply returns the function stored in the variable. Just to be sure, have a look yourself:


```js
hi; // name => `Hi ${name}`
hi("jonas"); // "Hi jonas"
```

由于 `greeting` 只是反过来用相同的参数调用 `hi`，我们可以简单地写：

```js
const greeting = hi;
greeting("times"); // "Hi times"
```

In other words, `hi` is already a function that expects one argument, why place another function around it that simply calls `hi` with the same bloody argument? It doesn't make any damn sense. It's like donning your heaviest parka in the dead of July just to blast the air and demand an ice lolly.

It is obnoxiously verbose and, as it happens, bad practice to surround a function with another function merely to delay evaluation (we'll see why in a moment, but it has to do with maintenance)

A solid understanding of this is critical before moving on, so let's examine a few more fun examples excavated from the library of npm packages.

```js
// ignorant
const getServerStuff = callback => ajaxCall(json => callback(json));

// enlightened
const getServerStuff = ajaxCall;
```

The world is littered with ajax code exactly like this. Here is the reason both are equivalent:

```js
// this line
ajaxCall(json => callback(json));

// 与这一行相同
ajaxCall(回调);

// 所以重构 getServerStuff
const getServerStuff = callback => ajaxCall(callback);

// ...which is equivalent to this
const getServerStuff = ajaxCall; // <-- look mum, no ()'s
```

And that, folks, is how it is done. Once more so that we understand why I'm being so persistent.

```js
const BlogController = {
  index(posts) { return Views.index(posts); },
  show(post) { return Views.show(post); },
  create(attrs) { return Db.create(attrs); },
  update(post, attrs) { return Db.update(post, attrs); },
  destroy(post) { return Db.destroy(post); },
};
```

这个荒谬的控制器是 99% 的绒毛。我们可以将其重写为：

```js
const BlogController = {
  index: Views.index,
  show: Views.show,
  create: Db.create,
  update: Db.update,
  destroy: Db.destroy,
};
```

... or scrap it altogether since it does nothing more than just bundle our Views and Db together.

## Why Favor First Class?

Okay, let's get down to the reasons to favor first class functions. As we saw in the `getServerStuff` and `BlogController` examples, it's easy to add layers of indirection that provide no added value and only increase the amount of redundant code to maintain and search through.

In addition, if such a needlessly wrapped function must be changed, we must also need to change our wrapper function as well.

```js
httpGet('/post/2', json => renderPost(json));
```

如果 `httpGet` 更改为发送可能的 `err`，我们将需要返回并更改“胶水”。

```js
// go back to every httpGet call in the application and explicitly pass err along.
httpGet('/post/2', (json, err) => renderPost(json, err));
```

Had we written it as a first class function, much less would need to change:

```js
// renderPost is called from within httpGet with however many arguments it wants
httpGet('/post/2', renderPost);
```

除了删除不必要的函数之外，我们还必须命名和引用参数。你看，名字有点问题。我们有潜在的用词不当——尤其是随着代码库的老化和需求的变化。

同一个概念有多个名称是项目中常见的混淆来源。还有通用代码的问题。例如，这两个函数做的完全一样，但感觉更通用和可重用：

```js
// specific to our current blog
const validArticles = articles =>
  articles.filter(article => article !== null && article !== undefined),

// vastly more relevant for future projects
const compact = xs => xs.filter(x => x !== null && x !== undefined);
```

通过使用特定的命名，我们似乎将自己与特定的数据（在本例中为“文章”）联系在一起。这种情况经常发生，并且是许多重塑的源泉。

我必须提到的是，就像面向对象的代码一样，你必须意识到 `this` 会咬你一口。如果底层函数使用 this 并且我们称它为第一类，我们就会受到这种泄漏抽象的愤怒。

```js
const fs = require('fs');

// scary
fs.readFile('freaky_friday.txt', Db.save);

// less so
fs.readFile('freaky_friday.txt', Db.save.bind(Db));
```

与自身绑定后，`Db` 可以自由访问其原型垃圾代码。我避免像脏尿布一样使用“this”。编写函数式代码时真的没有必要。但是，在与其他库交互时，您可能不得不默许我们周围的疯狂世界。

有些人会争辩说，“this”对于优化速度是必要的。如果你是微优化排序，请关闭本书。如果你不能拿回你的钱，也许你可以把它换成更复杂的东西。

有了这个，我们准备继续前进。

【第03章：纯粹的幸福，纯粹的功能】(ch03.md)
