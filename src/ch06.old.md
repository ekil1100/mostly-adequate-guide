# 第六章：应用范例

## 声明式编程

可以试着换一种思维模式。我们不再告诉计算机如何按步骤去运行，而是写出一个表达式告诉计算机我们想要得到的结果。你会惊讶的发现，这比什么都需要操心来的轻松的多。

声明式（而不是命令式）意味着我们将编写表达式，而不是编写指令。

比如 SQL，它没有执行的先后次序，只有一个描述了从数据库中获取什么内容的表达式。我们不需要去告诉程序如何运行，它会自己处理并得到我们想要的结果。升级数据库并优化 SQL 引擎后，我们不必更改原先的表达式，因为程序内部可以有很多不同的方式解释我们的表达式并得到相同的结果。

对于大部分人（包括我自己），一开始很难理解声明式编程的概念，所以让我们来举一些示例体会一下吧。

```js
// imperative
const makes = []
for (let i = 0; i < cars.length; i += 1) {
  makes.push(cars[i].make)
}

// declarative
const makes = cars.map((car) => car.make)
```

命令式的循环必须先初始化一个数组，解释器在执行下一个语句之前必须先评估这个语句。然后迭代 `cars`，再手动的增加一个计数器，把每个步骤都展示出来，非常的不优雅。

`map` 版本则是一种表达式。它不需要评估顺序。对于 `map` 函数如何迭代以及如何组装并返回数组，有很大的自由度。它指定 _what_，而不是 _how_。因此，它穿戴着闪亮的声明式腰带。

`map` 功能除了更加清晰简洁外，还可以随意优化，我们珍贵的应用代码不需要做任何修改。

对于那些认为"执行命令式循环要快得多"的人，我建议你可以自学 JIT 是如何优化代码的。这是一个[很好的视频，可能会给你一些启示](https://www.youtube.com/watch?v=g0ek4vV7nEA)。

下面是另一个示例。

```js
// imperative
const authenticate = (form) => {
  const user = toUser(form)
  return logIn(user)
}

// declarative
const authenticate = compose(logIn, toUser)
```

尽管命令式没有任何问题，但仍然需要一行行评估代码。 `compose` 表达式只是陈述了一个事实：身份验证是 `toUser` 和 `logIn` 的组合。同样，这为支持代码更改留下了回旋的余地，并使我们的应用程序代码成为高层次的规范。

在上面的例子中，指定了求值的顺序（`toUser` 必须在 `logIn` 之前调用），但是在很多场景下顺序并不重要，这很容易通过声明式来说明（稍后会详细介绍）。

Because we don't have to encode the order of evaluation, declarative coding lends itself to parallel computing. This coupled with pure functions is why FP is a good option for the parallel future - we don't really need to do anything special to achieve parallel/concurrent systems.

因为我们不必对求值顺序进行编码，所以声明式编码适用于并行计算。再加上纯函数，这就是为什么 FP 是并行未来的一个不错选择的原因——我们真的不需要做任何特殊的事情来实现并行/并发系统。

## A Flickr of Functional Programming

## 函数式编程的 Flickr

We will now build an example application in a declarative, composable way. We'll still cheat and use side effects for now, but we'll keep them minimal and separate from our pure codebase. We are going to build a browser widget that sucks in flickr images and displays them. Let's start by scaffolding the app. Here's the html:

我们现在将以声明性的、可组合的方式构建一个示例应用程序。我们现在仍然会作弊并使用副作用，但我们会将它们保持在最低限度并与我们的纯代码库分开。我们将构建一个浏览器小部件，它吸收 flickr 图像并显示它们。让我们从搭建应用程序开始。这是 html：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Flickr App</title>
  </head>
  <body>
    <main id="js-main" class="main"></main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script>
    <script src="main.js"></script>
  </body>
</html>
```

And here's the main.js skeleton:

这是 main.js 框架：

```js
const CDN = (s) => `https://cdnjs.cloudflare.com/ajax/libs/${s}`
const ramda = CDN('ramda/0.21.0/ramda.min')
const jquery = CDN('jquery/3.0.0-rc1/jquery.min')

requirejs.config({ paths: { ramda, jquery } })
requirejs(['jquery', 'ramda'], ($, { compose, curry, map, prop }) => {
  // app goes here
})
```

We're pulling in [ramda](https://ramdajs.com) instead of lodash or some other utility library. It includes `compose`, `curry`, and more. I've used requirejs, which may seem like overkill, but we'll be using it throughout the book and consistency is key.

我们正在引入 [ramda](https://ramdajs.com) 而不是 lodash 或其他一些实用程序库。它包括 `compose`、`curry` 等。我使用过 requirejs，这似乎有点矫枉过正，但我们将在整本书中使用它，一致性是关键。

Now that that's out of the way, on to the spec. Our app will do 4 things.

现在，这已经不在了，进入规范。我们的应用程序将做 4 件事。

1. Construct a url for our particular search term
2. Make the flickr api call
3. Transform the resulting json into html images
4. Place them on the screen

5. 为我们的特定搜索词构建一个 url
6. 进行 flickr api 调用
7. 将生成的 json 转成 html 图片
8. 将它们放在屏幕上

There are 2 impure actions mentioned above. Do you see them? Those bits about getting data from the flickr api and placing it on the screen. Let's define those first so we can quarantine them. Also, I'll add our nice `trace` function for easy debugging.

上面提到了 2 个不纯的动作。你看到他们了吗？关于从 flickr api 获取数据并将其放置在屏幕上的那些位。让我们先定义这些，以便我们可以隔离它们。此外，我将添加我们漂亮的 `trace` 函数以便于调试。

```js
const Impure = {
  getJSON: curry((callback, url) => $.getJSON(url, callback)),
  setHtml: curry((sel, html) => $(sel).html(html)),
  trace: curry((tag, x) => {
    console.log(tag, x)
    return x
  }),
}
```

Here we've simply wrapped jQuery's methods to be curried and we've swapped the arguments to a more favorable position. I've namespaced them with `Impure` so we know these are dangerous functions. In a future example, we will make these two functions pure.

在这里，我们简单地将 jQuery 的方法包装起来进行柯里化，并将参数交换到更有利的位置。我已经用 `Impure` 给它们命名了，所以我们知道这些是危险的函数。在以后的示例中，我们将使这两个函数纯。

Next we must construct a url to pass to our `Impure.getJSON` function.

接下来我们必须构造一个 url 来传递给我们的 `Impure.getJSON` 函数。

```js
const host = 'api.flickr.com'
const path = '/services/feeds/photos_public.gne'
const query = (t) => `?tags=${t}&format=json&jsoncallback=?`
const url = (t) => `https://${host}${path}${query(t)}`
```

There are fancy and overly complex ways of writing `url` pointfree using monoids(we'll learn about these later) or combinators. We've chosen to stick with a readable version and assemble this string in the normal pointful fashion.

使用幺半群（我们将在稍后了解这些）或组合子，有一些奇特且过于复杂的方式来编写 `url` pointfree。我们选择坚持使用可读版本并以正常的有针对性的方式组合此字符串。

Let's write an app function that makes the call and places the contents on the screen.

让我们编写一个应用程序函数来进行调用并将内容放置在屏幕上。

```js
const app = compose(Impure.getJSON(Impure.trace('response')), url)
app('cats')
```

This calls our `url` function, then passes the string to our `getJSON` function, which has been partially applied with `trace`. Loading the app will show the response from the api call in the console.

这会调用我们的 `url` 函数，然后将字符串传递给我们的 `getJSON` 函数，该函数已经部分应用了 `trace`。加载应用程序将在控制台中显示来自 api 调用的响应。

<img src="images/console_ss.png" alt="console response" />

<img src="images/console_ss.png" alt="控制台响应" />

We'd like to construct images out of this json. It looks like the `mediaUrls` are buried in `items` then each `media`'s `m` property.

我们想用这个 json 构建图像。看起来`mediaUrls` 被埋在`items` 中，然后是每个`media` 的`m` 属性。

Anyhow, to get at these nested properties we can use a nice universal getter function from ramda called `prop`. Here's a homegrown version so you can see what's happening:

我们想用这个 json 构建图像。看起来`mediaUrls` 被埋在`items` 中，然后是每个`media` 的`m` 属性。

```js
const prop = curry((property, object) => object[property])
```

It's quite dull actually. We just use `[]` syntax to access a property on whatever object. Let's use this to get at our `mediaUrls`.

其实挺无聊的。我们只使用 `[]` 语法来访问任何对象的属性。让我们用它来获取我们的 `mediaUrls`。

```js
const mediaUrl = compose(prop('m'), prop('media'))
const mediaUrls = compose(map(mediaUrl), prop('items'))
```

Once we gather the `items`, we must `map` over them to extract each media url. This results in a nice array of `mediaUrls`. Let's hook this up to our app and print them on the screen.

一旦我们收集了 `items`，我们必须对它们进行 `map` 以提取每个媒体 url。这会产生一个很好的 `mediaUrls` 数组。让我们将其连接到我们的应用程序并将它们打印在屏幕上。

```js
const render = compose(Impure.setHtml('#js-main'), mediaUrls)
const app = compose(Impure.getJSON(render), url)
```

All we've done is make a new composition that will call our `mediaUrls` and set the `<main>` html with them. We've replaced the `trace` call with `render` now that we have something to render besides raw json. This will crudely display our `mediaUrls` within the body.

我们所做的就是创建一个新的组合，它将调用我们的 `mediaUrls` 并设置 `<main> ` html 与他们。我们已经用 `render` 替换了 `trace` 调用，因为除了原始 json 之外我们还有一些东西要渲染。这将在正文中粗略地显示我们的 `mediaUrls`。

Our final step is to turn these `mediaUrls` into bonafide `images`. In a bigger application, we'd use a template/dom library like Handlebars or React. For this application though, we only need an img tag so let's stick with jQuery.

我们的最后一步是将这些 `mediaUrls` 变成真正的 `images`。在更大的应用程序中，我们会使用模板/dom 库，如 Handlebars 或 React。但是对于这个应用程序，我们只需要一个 img 标签，所以让我们坚持使用 jQuery。

```js
const img = (src) => $('<img />', { src })
```

jQuery's `html` method will accept an array of tags. We only have to transform our mediaUrls into images and send them along to `setHtml`.

jQuery 的`html` 方法将接受一个标签数组。我们只需要将我们的 mediaUrls 转换为图像并将它们发送到 `setHtml`。

```js
const images = compose(map(img), mediaUrls)
const render = compose(Impure.setHtml('#js-main'), images)
const app = compose(Impure.getJSON(render), url)
```

And we're done!

我们完成了！

<img src="images/cats_ss.png" alt="cats grid" />

<img src="images/cats_ss.png" alt="猫格" />

Here is the finished script:
[include](./exercises/ch06/main.js)

Now look at that. A beautifully declarative specification of what things are, not how they come to be. We now view each line as an equation with properties that hold. We can use these properties to reason about our application and refactor.

## A Principled Refactor

There is an optimization available - we map over each item to turn it into a media url, then we map again over those mediaUrls to turn them into img tags. There is a law regarding map and composition:

```js
// map's composition law
compose(map(f), map(g)) === map(compose(f, g))
```

We can use this property to optimize our code. Let's have a principled refactor.

```js
// original code
const mediaUrl = compose(prop('m'), prop('media'))
const mediaUrls = compose(map(mediaUrl), prop('items'))
const images = compose(map(img), mediaUrls)
```

Let's line up our maps. We can inline the call to `mediaUrls` in `images` thanks to equational reasoning and purity.

```js
const mediaUrl = compose(prop('m'), prop('media'))
const images = compose(map(img), map(mediaUrl), prop('items'))
```

Now that we've lined up our `map`s we can apply the composition law.

```js
/*
compose(map(f), map(g)) === map(compose(f, g));
compose(map(img), map(mediaUrl)) === map(compose(img, mediaUrl));
*/

const mediaUrl = compose(prop('m'), prop('media'))
const images = compose(map(compose(img, mediaUrl)), prop('items'))
```

Now the bugger will only loop once while turning each item into an img. Let's just make it a little more readable by extracting the function out.

```js
const mediaUrl = compose(prop('m'), prop('media'))
const mediaToImg = compose(img, mediaUrl)
const images = compose(map(mediaToImg), prop('items'))
```

## In Summary

We have seen how to put our new skills into use with a small, but real world app. We've used our mathematical framework to reason about and refactor our code. But what about error handling and code branching? How can we make the whole application pure instead of merely namespacing destructive functions? How can we make our app safer and more expressive? These are the questions we will tackle in part 2.

[Chapter 07: Hindley-Milner and Me](ch07.md)
