# 第 5 章：通过组合进行编码

## 功能性畜牧业

这是“撰写”：

```js
const compose = (...fns) => (...args) => fns.reduceRight((res, fn) => [fn.call(null, ...res)], args)[0];
```

......不要害怕！这是_compose_的9000级超级赛亚人形态。为了推理起见，让我们放弃可变参数的实现，并考虑一种可以将两个函数组合在一起的更简单的形式。一旦你明白了这一点，你就可以进一步推动抽象，并认为它只适用于任意数量的函数（我们甚至可以证明这一点）！
亲爱的读者，这里有一个更友好的 _compose_ 给你：

```js
const compose2 = (f, g) => x => f(g(x));
```

`f` 和 `g` 是函数，而 `x` 是通过它们“管道化”的值。

组合感觉就像功能管理。你，函数的培育者，选择两个你想要结合的特征并将它们混合在一起以产生一个全新的。用法如下：

```js
const toUpperCase = x => x.toUpperCase();
const exclaim = x => `${x}!`;
const shout = compose(exclaim, toUpperCase);

shout('send in the clowns'); // "SEND IN THE CLOWNS!"
```

两个函数的组合返回一个新函数。这是完全有道理的：组合某种类型的两个单元（在本例中为函数）应该产生一个该类型的新单元。您不会将两个乐高积木塞在一起并获得林肯日志。这里有一个理论，我们将在适当的时候发现一些潜在的规律。

在我们对 `compose` 的定义中，`g` 将在 `f` 之前运行，创建从右到左的数据流。这比嵌套一堆函数调用更具可读性。如果没有 compose，上面的内容将是：

```js
const shout = x => exclaim(toUpperCase(x));
```

我们不是从内到外，而是从右到左跑，我想这是向左方向迈出的一步（嘘！）。让我们看一个例子，其中顺序很重要：

```js
const head = x => x[0];
const reverse = reduce((acc, x) => [x, ...acc], []);
const last = compose(head, reverse);

last(['jumpkick', 'roundhouse', 'uppercut']); // 'uppercut'
```

`reverse` 将翻转列表，而 `head` 抓取初始项目。这导致了一个有效但效率低下的“last”函数。组合中的函数顺序在这里应该是显而易见的。我们可以定义一个从左到右的版本，但是，我们更接近地反映了数学版本的现状。没错，作文直接来自数学书。事实上，也许是时候看看适用于任何组合的属性了。

```js
// associativity
compose(f, compose(g, h)) === compose(compose(f, g), h);
```

组合是关联的，这意味着您如何将其中的两个组合在一起并不重要。所以，如果我们选择大写字符串，我们可以这样写：

```js
compose(toUpperCase, compose(head, reverse));
// or
compose(compose(toUpperCase, head), reverse);
```

由于我们如何对 `compose` 的调用进行分组并不重要，因此结果将是相同的。这允许我们编写一个可变参数组合并按如下方式使用它：

```js
// previously we'd have to write two composes, but since it's associative, 
// we can give compose as many fn's as we like and let it decide how to group them.
const arg = ['jumpkick', 'roundhouse', 'uppercut'];
const lastUpper = compose(toUpperCase, head, reverse);
const loudLastUpper = compose(exclaim, toUpperCase, head, reverse);

lastUpper(arg); // 'UPPERCUT'
loudLastUpper(arg); // 'UPPERCUT!'
```

应用关联属性为我们提供了这种灵活性和安心，即结果将是等效的。稍微复杂的可变参数定义包含在本书的支持库中，并且是您可以在 [lodash][lodash-website]、[underscore][underscore-website] 和 [ramda][ 等库中找到的正常定义。拉姆达网站]。

关联性的一个令人愉快的好处是，任何一组函数都可以被提取出来并捆绑在它们自己的组合中。让我们重构我们之前的例子：

```js
const loudLastUpper = compose(exclaim, toUpperCase, head, reverse);

// -- or ---------------------------------------------------------------

const last = compose(head, reverse);
const loudLastUpper = compose(exclaim, toUpperCase, last);

// -- or ---------------------------------------------------------------

const last = compose(head, reverse);
const angry = compose(exclaim, toUpperCase);
const loudLastUpper = compose(angry, last);

// more variations...
```

没有正确或错误的答案 - 我们只是以我们喜欢的任何方式将我们的乐高积木塞在一起。通常最好以可重用的方式对事物进行分组，例如“last”和“angry”。如果熟悉 Fowler 的“[Refactoring][refactoring-book]”，人们可能会认为这个过程是“[extract function][extract-function-refactor]”......除非所有对象状态都不需要担心。

##无点

Pointfree 风格意味着永远不必说出您的数据。打扰一下。这意味着函数从不提及它们操作的数据。一流的函数、柯里化和组合都很好地结合在一起，创造了这种风格。

> 提示：`replace` 和`toLowerCase` 的Pointfree 版本在[附录C -
> Pointfree 实用程序](./appendix_c.md)。不要犹豫，快来看看吧！

```js
// not pointfree because we mention the data: word
const snakeCase = word => word.toLowerCase().replace(/\s+/ig, '_');

// pointfree
const snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase);
```

看到我们如何部分应用`replace`了吗？我们正在做的是通过 1 个参数的每个函数来传输我们的数据。柯里化允许我们准备每个函数来获取它的数据，对其进行操作，并传递它。还有一点需要注意的是，在 pointfree 版本中我们不需要数据来构建我们的函数，而在 pointful 版本中，我们必须先让我们的“word”可用。

让我们再看一个例子。

```js
// not pointfree because we mention the data: name
const initials = name => name.split(' ').map(compose(toUpperCase, head)).join('. ');

// pointfree
// NOTE: we use 'intercalate' from the appendix instead of 'join' introduced in Chapter 09!
const initials = compose(intercalate('. '), map(compose(toUpperCase, head)), split(' '));

initials('hunter stockton thompson'); // 'H. S. T'
```

Pointfree 代码可以再次帮助我们删除不必要的名称并保持简洁和通用。 Pointfree 是功能代码的一个很好的试金石，因为它让我们知道我们有一些小函数可以将输入输出到输出。例如，不能编写一个 while 循环。但是请注意，pointfree 是一把双刃剑，有时会混淆意图。并非所有的功能代码都是 pointfree 的，这没关系。我们会尽可能地争取它，否则坚持使用正常的功能。

##调试
一个常见的错误是组合类似 `map` 的东西，一个有两个参数的函数，而没有首先部分应用它。

```js
// wrong - we end up giving angry an array and we partially applied map with who knows what.
const latin = compose(map, angry, reverse);

latin(['frog', 'eyes']); // error

// right - each function expects 1 argument.
const latin = compose(map(angry), reverse);

latin(['frog', 'eyes']); // ['EYES!', 'FROG!'])
```

如果您在调试组合时遇到问题，我们可以使用这个有用但不纯的跟踪功能来查看发生了什么。

```js
const trace = curry((tag, x) => {
  console.log(tag, x);
  return x;
});

const dasherize = compose(
  intercalate('-'),
  toLower,
  split(' '),
  replace(/\s{2,}/ig, ' '),
);

dasherize('The world is a vampire');
// TypeError: Cannot read property 'apply' of undefined
```

这里出了点问题，让我们`trace`

```js
const dasherize = compose(
  intercalate('-'),
  toLower,
  trace('after split'),
  split(' '),
  replace(/\s{2,}/ig, ' '),
);

dasherize('The world is a vampire');
// after split [ 'The', 'world', 'is', 'a', 'vampire' ]
```

啊!我们需要“映射”这个“toLower”，因为它正在处理一个数组。

```js
const dasherize = compose(
  intercalate('-'),
  map(toLower),
  split(' '),
  replace(/\s{2,}/ig, ' '),
);

dasherize('The world is a vampire'); // 'the-world-is-a-vampire'
```

`trace` 函数允许我们查看某个点的数据以进行调试。为了便于开发，Haskell 和 PureScript 等语言具有类似的功能。

组合将成为我们构建程序的工具，而且幸运的是，它得到了一个强大的理论的支持，可以确保事情对我们有用。让我们来研究一下这个理论。


##范畴论

范畴论是数学的一个抽象分支，可以将集合论、类型论、群论、逻辑等几个不同分支的概念形式化。它主要处理对象、态射和变换，这与编程非常接近。这是从每个单独的理论中看到的相同概念的图表。

<img src="images/cat_theory.png" alt="分类理论" />

对不起，我不是故意吓唬你的。我不希望您对所有这些概念都非常熟悉。我的观点是向您展示我们有多少重复，以便您了解为什么范畴论旨在统一这些东西。

在范畴论中，我们有一种叫做……范畴的东西。它被定义为具有以下组件的集合：

  * 对象集合
  * 态射的集合
  * 关于态射的组合概念
  * 一个特殊的态射称为恒等

范畴论足够抽象，可以对许多事物进行建模，但让我们将其应用于类型和函数，这正是我们目前所关心的。

**对象集合**
对象将是数据类型。例如，“String”、“Boolean”、“Number”、“Object”等。我们经常将数据类型视为所有可能值的集合。可以将“Boolean”视为“[true, false]”的集合，将“Number”视为所有可能数值的集合。将类型视为集合很有用，因为我们可以使用集合论来处理它们。


**态射的集合**
态射将成为我们每天的标准纯函数。

**关于态射的组合概念**
正如您可能已经猜到的那样，这是我们全新的玩具 - `compose`。我们已经讨论过我们的 `compose` 函数是结合的，这并非巧合，因为它是范畴论中任何组合都必须保持的属性。

这是一张演示构图的图像：

<img src="images/cat_comp1.png" alt="类别合成1" />
<img src="images/cat_comp2.png" alt="类别合成2" />

这是代码中的一个具体示例：

```js
const g = x => x.length;
const f = x => x === 4;
const isFourLetterWord = compose(f, g);
```

**一个特殊的态射称为恒等**
让我们介绍一个名为 `id` 的有用函数。这个函数只是简单地接受一些输入并将它吐回给你。看一看：

```js
const id = x => x;
```

您可能会问自己“该死的有什么用？”。我们将在接下来的章节中广泛使用这个函数，但现在把它想象成一个可以代表我们价值的函数——一个伪装成日常数据的函数。

`id` 必须与 compose 配合得很好。这是一个始终适用于每个一元（一元：单参数函数）函数 f 的属性：

```js
// identity
compose(id, f) === compose(f, id) === f;
// true
```

嘿，这就像数字上的身份属性！如果这不是立即清楚，请花一些时间。明白无用。我们很快就会看到 `id` 到处使用，但现在我们看到它是一个充当给定值的替代品的函数。这在编写 pointfree 代码时非常有用。

所以你有它，一类类型和功能。如果这是您的第一次介绍，我想您对类别是什么以及它为什么有用还是有点模糊。我们将在整本书中以这些知识为基础。到目前为止，在本章中，在这一行中，您至少可以将其视为为我们提供了一些关于组合的智慧 - 即关联性和身份属性。

你问还有哪些其他类别？好吧，我们可以为有向图定义一个，节点是对象，边是态射，组合只是路径连接。我们可以将 Numbers 定义为对象，将 `>=` 定义为态射（实际上任何偏序或全序都可以是一个范畴）。类别有很多，但就本书而言，我们只关心上面定义的类别。我们已经充分浏览了表面，必须继续前进。


＃＃ 总之
组合像一系列管道一样将我们的功能连接在一起。数据将流经我们的应用程序——毕竟纯函数是输入到输出的，因此打破这条链将忽略输出，使我们的软件变得无用。

我们认为构图是最重要的设计原则。这是因为它使我们的应用程序简单合理。类别理论将在应用程序架构、建模副作用和确保正确性方面发挥重要作用。

我们现在正处于在实践中看到其中一些对我们有益的时刻。让我们做一个示例应用程序。

【第06章：示例应用】(ch06.md)

## 练习

在以下每个练习中，我们将考虑具有以下形状的 Car 对象：

```js
{
  name: 'Aston Martin One-77',
  horsepower: 750,
  dollar_value: 1850000,
  in_stock: true,
}
```


{％ 锻炼 ％}
使用 `compose()` 重写下面的函数。
  
{% 初始 src="./exercises/ch05/exercise_a.js#L12;" %}
```js  
const isLastInStock = (cars) => {  
  const lastCar = last(cars);  
  return prop('in_stock', lastCar);  
};  
```  
  
{% 解决方案 src="./exercises/ch05/solution_a.js" %}
{% 验证 src="./exercises/ch05/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}


---


考虑以下功能：

```js
const average = xs => reduce(add, 0, xs) / xs.length;
```

{％ 锻炼 ％}
使用辅助函数 `average` 将 `averageDollarValue` 重构为组合。
  
{% 初始 src="./exercises/ch05/exercise_b.js#L7;" %}
```js  
const averageDollarValue = (cars) => {  
  const dollarValues = map(c => c.dollar_value, cars);  
  return average(dollarValues);  
};  
```  
  
{% 解决方案 src="./exercises/ch05/solution_b.js" %}
{% 验证 src="./exercises/ch05/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}


---


{％ 锻炼 ％}
使用 `compose()` 和其他 pointfree 风格的函数重构 `fastestCar`。提示，
`append` 函数可能会派上用场。
  
{% 初始 src="./exercises/ch05/exercise_c.js#L4;" %}
```js  
const fastestCar = (cars) => {  
  const sorted = sortBy(car => car.horsepower);  
  const fastest = last(sorted);  
  return concat(fastest.name, ' is the fastest');  
};  
```  
  
{% 解决方案 src="./exercises/ch05/solution_c.js" %}
{% 验证 src="./exercises/ch05/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

[lodash 网站]：https://lodash.com/
[下划线网站]：https://underscorejs.org/
[ramda-网站]：https://ramdajs.com/
[重构书]：https://martinfowler.com/books/refactoring.html
[提取功能重构]：https://refactoring.com/catalog/extractFunction.html
