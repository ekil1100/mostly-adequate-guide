# 第 11 章：自然而然地再次转变

我们将在日常代码的实际效用环境中讨论*自然转换*。碰巧它们是范畴论的支柱，并且在应用数学推理和重构我们的代码时绝对不可或缺。因此，由于我的范围有限，我相信我有责任告诉您您将要目睹的可悲的不公正。让我们开始。

## 诅咒这个巢穴

我想解决嵌套的问题。不是很快成为父母的本能冲动，他们会强迫性地整理和重新安排，但......实际上，想想看，这与我们将在接下来的章节中看到的标记相去不远...无论如何，我所说的*嵌套*是将两个或更多不同类型都挤在一个值周围，就像新生儿一样抱着它。

```js
Right(Maybe('b'))

IO(Task(IO(1000)))

;[Identity('bee thousand')]
```

到目前为止，我们已经通过精心制作的示例设法避免了这种常见情况，但在实践中，作为一种代码，类型往往会像驱魔中的耳塞一样纠缠在一起。如果我们在进行过程中不小心地保持我们的类型有条理，我们的代码读起来会比猫咖啡馆里的 beatnik 还要毛茸茸。

##情景喜剧

```js
// getValue :: Selector -> Task Error (Maybe String)
// postComment :: String -> Task Error Comment
// validate :: String -> Either ValidationError String

// saveComment :: () -> Task Error (Maybe (Either ValidationError (Task Error Comment)))
const saveComment = compose(
  map(map(map(postComment))),
  map(map(validate)),
  getValue('#comment'),
)
```

帮派都在这里，让我们的类型签名很沮丧。请允许我简要解释一下代码。我们首先使用`getValue('#comment')` 获取用户输入，这是一个检索元素上文本的操作。现在，它可能会在查找元素时出错，或者值字符串可能不存在，因此它返回“任务错误（可能是字符串）”。之后，我们必须对 `Task` 和 `Maybe` 都进行 `map` 以将我们的文本传递给 `validate`，后者反过来给我们返回 `Either` 一个 `ValidationError` 或我们的 `String`。然后映射数天，将我们当前的“任务错误（可能（验证错误字符串））”中的“字符串”发送到“postComment”，它返回我们生成的“任务”。

多么可怕的混乱。抽象类型的拼贴画，业余类型的表现主义，多态的波洛克，整体的蒙德里安。这个常见问题有很多解决方案。我们可以将这些类型组合成一个巨大的容器，对一些类型进行排序和“连接”，将它们同质化，解构它们，等等。在本章中，我们将专注于通过*自然变换* 将它们同质化。

＃＃ 全天然

*自然变换*是“函子之间的态射”，即对容器本身进行操作的函数。类型上，它是一个函数`(Functor f, Functor g) => f a -> g a`。它的特别之处在于我们不能以任何理由窥视我们的函子的内容。可以将其视为高度机密信息的交换 - 双方都没有注意到盖有“绝密”印章的密封马尼拉信封中的内容。这是结构性操作。功能性服装变化。形式上，*自然变换*是满足以下条件的任何函数：

<img width=600 src="images/natural_transformation.png" alt="自然变换图" />

或在代码中：

```js
// nt :: (Functor f, Functor g) => f a -> g a
compose(map(f), nt) === compose(nt, map(f))
```

图表和代码都说同样的事情：我们可以先运行我们的自然变换，然后运行 `map` 或 `map`，然后运行我们的自然变换并得到相同的结果。顺便说一下，这源自 [自由定理](ch07.md#free-as-in-theorem)，尽管自然变换（和函子）不限于类型上的函数。

## 有原则的类型转换

作为程序员，我们熟悉类型转换。我们将 `Strings` 之类的类型转换为 `Booleans`，将 `Integers` 转换为 `Floats`（尽管 JavaScript 只有 `Numbers`）。这里的区别只是我们正在使用代数容器，我们有一些理论可供我们使用。

让我们以其中一些为例：

```js
// idToMaybe :: Identity a -> Maybe a
const idToMaybe = (x) => Maybe.of(x.$value)

// idToIO :: Identity a -> IO a
const idToIO = (x) => IO.of(x.$value)

// eitherToTask :: Either a b -> Task a b
const eitherToTask = either(Task.rejected, Task.of)

// ioToTask :: IO a -> Task () a
const ioToTask = (x) =>
  new Task((reject, resolve) => resolve(x.unsafePerform()))

// maybeToTask :: Maybe a -> Task () a
const maybeToTask = (x) => (x.isNothing ? Task.rejected() : Task.of(x.$value))

// arrayToMaybe :: [a] -> Maybe a
const arrayToMaybe = (x) => Maybe.of(x[0])
```

看到这个想法了吗？我们只是将一个函子改成另一个函子。我们可以在此过程中丢失信息，只要我们将 `map` 的值不会在 shape shift shuffle 中丢失。这就是重点：根据我们的定义，即使在转换之后，`map` 也必须继续。

一种看待它的方式是我们正在改变我们的效果。有鉴于此，我们可以将 `ioToTask` 视为将同步转换为异步或将 `arrayToMaybe` 从不确定性转换为可能的失败。请注意，我们无法在 JavaScript 中将异步转换为同步，因此我们无法编写 `taskToIO` - 这将是一种超自然的转换。

## 功能羡慕

假设我们想在“List”上使用另一种类型的一些特性，比如“sortBy”。 *自然转换*提供了一种很好的方式来转换为目标类型，因为我们知道我们的`map` 将会是健全的。

```js
// arrayToList :: [a] -> List a
const arrayToList = List.of

const doListyThings = compose(sortBy(h), filter(g), arrayToList, map(f))
const doListyThings_ = compose(sortBy(h), filter(g), map(f), arrayToList) // law applied
```

我们的鼻子摆动，我们的魔杖点击三下，放入`arrayToList`，瞧！我们的`[a]` 是一个`List a`，如果愿意，我们可以`sortBy`。

此外，通过将 `map(f)` 移动到 _natural transformation_ 的左侧，可以更容易地优化/融合操作，如 `doListyThings_` 所示。

## 同构 JavaScript

当我们可以完全来回而不会丢失任何信息时，这被认为是*同构*。这只是“拥有相同数据”的花哨词。如果我们可以提供“to”和“from”*自然变换*作为证明，我们就说这两种类型是*同构的*：

```js
// promiseToTask :: Promise a b -> Task a b
const promiseToTask = (x) =>
  new Task((reject, resolve) => x.then(resolve).catch(reject))

// taskToPromise :: Task a b -> Promise a b
const taskToPromise = (x) =>
  new Promise((resolve, reject) => x.fork(reject, resolve))

const x = Promise.resolve('ring')
taskToPromise(promiseToTask(x)) === x

const y = Task.of('rabbit')
promiseToTask(taskToPromise(y)) === y
```

Q.E.D. `Promise` 和 `Task` 是*同构的*。我们还可以编写一个 `listToArray` 来补充我们的 `arrayToList` 并表明它们也是。作为一个反例，`arrayToMaybe` 不是 _同构_，因为它会丢失信息：

```js
// maybeToArray :: Maybe a -> [a]
const maybeToArray = (x) => (x.isNothing ? [] : [x.$value])

// arrayToMaybe :: [a] -> Maybe a
const arrayToMaybe = (x) => Maybe.of(x[0])

const x = ['elvis costello', 'the attractions']

// not isomorphic
maybeToArray(arrayToMaybe(x)) // ['elvis costello']

// but is a natural transformation
compose(arrayToMaybe, map(replace('elvis', 'lou')))(x) // Just('lou costello')
// ==
compose(map(replace('elvis', 'lou')), arrayToMaybe)(x) // Just('lou costello')
```

然而，它们确实是*自然变换*，因为两边的`map`产生相同的结果。我在这里提到了*同构*，在我们讨论这个主题的时候，在章节中间，但不要让它愚弄你，它们是一个非常强大和普遍的概念。无论如何，让我们继续前进。

## 更广泛的定义

这些结构函数无论如何都不限于类型转换。

这里有一些不同的：

```hs
reverse :: [a] -> [a]

join :: (Monad m) => m (m a) -> m a

head :: [a] -> a

of :: a -> f a
```

自然变换定律也适用于这些函数。可能会绊倒你的一件事是`head :: [a] -> a` 可以被视为`head :: [a] -> Identity a`。我们可以随意插入“恒等式”，同时证明定律，因为我们可以反过来证明“a”与“恒等式”同构（看，我告诉过你*同构*普遍存在）。

## 一种嵌套解决方案

回到我们的喜剧类型签名。我们可以在整个调用代码中加入一些*自然转换*来强制每个不同的类型，使它们是统一的，因此可以“连接”。

```js
// getValue :: Selector -> Task Error (Maybe String)
// postComment :: String -> Task Error Comment
// validate :: String -> Either ValidationError String

// saveComment :: () -> Task Error Comment
const saveComment = compose(
  chain(postComment),
  chain(eitherToTask),
  map(validate),
  chain(maybeToTask),
  getValue('#comment'),
)
```

那么我们这里有什么？我们简单地添加了 `chain(maybeToTask)` 和 `chain(eitherToTask)`。两者具有相同的效果；他们自然地将我们的“Task”持有的函子转换为另一个“Task”，然后“加入”两者。就像窗台上的鸽子尖刺一样，我们避免在源头筑巢。正如他们在光明之城所说，“Mieux vaut prévenir que guérir”——一盎司的预防胜过一磅的治疗。

＃＃ 总之

*自然变换*是我们函子本身的函数。它们是范畴论中一个极其重要的概念，一旦采用更多的抽象，它们就会开始出现在任何地方，但现在，我们已经将它们限定在一些具体的应用中。正如我们所看到的，我们可以通过转换类型来实现不同的效果，并保证我们的组合将保持不变。它们还可以帮助我们处理嵌套类型，尽管它们具有将我们的函子同质化为最小公分母的一般效果，实际上，这是具有最不稳定效果的函子（在大多数情况下为“任务”）。

这种持续而乏味的类型分类是我们为实现它们而付出的代价——从以太中召唤它们。当然，隐性效果要阴险得多，所以我们在这里打一场好仗。在我们可以卷入更大类型的合并之前，我们需要更多的工具来解决我们的问题。接下来，我们将看看使用 _Traversable_ 重新排序我们的类型。

【第十二章：穿越石头】(ch12.md)

## 练习

{％ 锻炼 ％}
编写一个自然变换，将“Either b a”转换为“Maybe a”

{% 初始 src="./exercises/ch11/exercise_a.js#L3;" %}

```js
// eitherToMaybe :: Either b a -> Maybe a
const eitherToMaybe = undefined
```

{% 解决方案 src="./exercises/ch11/solution_a.js" %}
{% 验证 src="./exercises/ch11/validation_a.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

```js
// eitherToTask :: Either a b -> Task a b
const eitherToTask = either(Task.rejected, Task.of)
```

{％ 锻炼 ％}
使用“eitherToTask”，简化“findNameById”以移除嵌套的“Either”。

{% 初始 src="./exercises/ch11/exercise_b.js#L6;" %}

```js
// findNameById :: Number -> Task Error (Either Error User)
const findNameById = compose(map(map(prop('name'))), findUserById)
```

{% 解决方案 src="./exercises/ch11/solution_b.js" %}
{% 验证 src="./exercises/ch11/validation_b.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}

---

提醒一下，在练习的上下文中可以使用以下功能：

```hs
split :: String -> String -> [String]
intercalate :: String -> [String] -> String
```

{％ 锻炼 ％}
写出 String 和 [Char] 之间的同构。

{% 初始 src="./exercises/ch11/exercise_c.js#L8;" %}

```js
// strToList :: String -> [Char]
const strToList = undefined

// listToStr :: [Char] -> String
const listToStr = undefined
```

{% 解决方案 src="./exercises/ch11/solution_c.js" %}
{% 验证 src="./exercises/ch11/validation_c.js" %}
{% 上下文 src="./exercises/support.js" %}
{% 锻炼%}
