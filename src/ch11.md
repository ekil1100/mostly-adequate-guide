# 第11章：自然而然地再次转变

我们将在日常代码的实际效用环境中讨论*自然转换*。碰巧它们是范畴论的支柱，并且在应用数学推理和重构我们的代码时绝对不可或缺。因此，由于我的范围有限，我相信我有责任告诉您您将要目睹的可悲的不公正。让我们开始。

## 诅咒这个巢穴

我想解决嵌套的问题。不是很快成为父母的本能冲动，他们会强迫性地整理和重新安排，但......实际上，想想看，这与我们将在接下来的章节中看到的标记相去不远...无论如何，我所说的*嵌套*是将两个或更多不同类型都挤在一个值周围，就像新生儿一样抱着它。

```js
Right(Maybe('b'));

IO(Task(IO(1000)));

[Identity('bee thousand')];
```

到目前为止，我们已经通过精心制作的示例设法避免了这种常见情况，但在实践中，作为一种代码，类型往往会像驱魔中的耳塞一样纠缠在一起。如果我们在进行过程中不小心地保持我们的类型有条理，我们的代码读起来会比猫咖啡馆里的beatnik 还要毛茸茸。

##情景喜剧

```js
// getValue :: Selector -> Task Error (Maybe String)
// postComment :: String -> Task Error Comment
// validate :: String -> Either ValidationError String

// saveComment :: () -> Task Error (Maybe (Either ValidationError (Task Error Comment)))
const saveComment = compose(
  map(map(map(postComment))),
  map(map(validate)),
  getValue('#comment'),
);
```

帮派都在这里，让我们的类型签名很沮丧。请允许我简要解释一下代码。我们首先使用`getValue('#comment')` 获取用户输入，这是一个检索元素上文本的操作。现在，它可能会在查找元素时出错，或者值字符串可能不存在，因此它返回“任务错误（可能是字符串）”。之后，我们必须对 `Task` 和 `Maybe` 都进行 `map` 以将我们的文本传递给 `validate`，后者反过来给我们返回 `Either` 一个 `ValidationError` 或我们的 `String`。然后映射数天，将我们当前的“任务错误（可能（验证错误字符串））”中的“字符串”发送到“postComment”，它返回我们生成的“任务”。

多么可怕的混乱。抽象类型的拼贴画，业余类型的表现主义，多态的波洛克，整体的蒙德里安。这个常见问题有很多解决方案。我们可以将这些类型组合成一个巨大的容器，对一些类型进行排序和“连接”，将它们同质化，解构它们，等等。在本章中，我们将专注于通过*自然变换* 将它们同质化。

＃＃ 全天然

*自然变换*是“函子之间的态射”，即对容器本身进行操作的函数。类型上，它是一个函数`(Functor f, Functor g) => f a -> g a`。它的特别之处在于我们不能以任何理由窥视我们的函子的内容。可以将其视为高度机密信息的交换 - 双方都没有注意到盖有“绝密”印章的密封马尼拉信封中的内容。这是结构性操作。功能性服装变化。形式上，*自然变换*是满足以下条件的任何函数：

<img width=600 src="images/natural_transformation.png" alt="自然变换图" />

或在代码中：

```js
// nt :: (Functor f, Functor g) => f a -> g a
compose(map(f), nt) === compose(nt, map(f));
```

Both the diagram and the code say the same thing: We can run our natural transformation then `map` or `map` then run our natural transformation and get the same result. Incidentally, that follows from a [free theorem](ch07.md#free-as-in-theorem) though natural transformations (and functors) are not limited to functions on types.

## Principled Type Conversions

As programmers we are familiar with type conversions. We transform types like `Strings` into `Booleans` and `Integers` into `Floats` (though JavaScript only has `Numbers`). The difference here is simply that we're working with algebraic containers and we have some theory at our disposal.

Let's look at some of these as examples:

```js
// idToMaybe :: Identity a -> Maybe a
const idToMaybe = x => Maybe.of(x.$value);

// idToIO :: 身份 a -> IO a
const idToIO = x => IO.of(x.$value);

// 任一任务 :: 任一 a b -> 任务 a b
const anyToTask = 要么（Task.rejected, Task.of）;

// ioToTask :: IO a -> Task() a
const ioToTask = x => new Task((reject, resolve) => resolve(x.unsafePerform()));

// MaybeToTask :: Maybe a -> Task () a
const MaybeToTask = x => (x.isNothing ? Task.rejected() : Task.of(x.$value));

// arrayToMaybe :: [a] -> Maybe a
const arrayToMaybe = x => Maybe.of(x[0]);
```

See the idea? We're just changing one functor to another. We are permitted to lose information along the way so long as the value we'll `map` doesn't get lost in the shape shift shuffle. That is the whole point: `map` must carry on, according to our definition, even after the transformation.

One way to look at it is that we are transforming our effects. In that light, we can view `ioToTask` as converting synchronous to asynchronous or `arrayToMaybe` from nondeterminism to possible failure. Note that we cannot convert asynchronous to synchronous in JavaScript so we cannot write `taskToIO` - that would be a supernatural transformation.

## Feature Envy

Suppose we'd like to use some features from another type like `sortBy` on a `List`. *Natural transformations* provide a nice way to convert to the target type knowing our `map` will be sound.

```js
// arrayToList :: [a] -> List a
const arrayToList = List.of;

const doListyThings = compose(sortBy(h), filter(g), arrayToList, map(f));
const doListyThings_ = compose(sortBy(h), filter(g), map(f), arrayToList); // law applied
```

A wiggle of our nose, three taps of our wand, drop in `arrayToList`, and voilà! Our `[a]` is a `List a` and we can `sortBy` if we please.

Also, it becomes easier to optimize / fuse operations by moving `map(f)` to the left of *natural transformation* as shown in `doListyThings_`.

## Isomorphic JavaScript

When we can completely go back and forth without losing any information, that is considered an *isomorphism*. That's just a fancy word for "holds the same data". We say that two types are *isomorphic* if we can provide the "to" and "from" *natural transformations* as proof:

```js
// promiseToTask :: Promise a b -> Task a b
const promiseToTask = x => new Task((reject, resolve) => x.then(resolve).catch(reject));

// taskToPromise :: Task a b -> Promise a b
const taskToPromise = x => new Promise((resolve, reject) => x.fork(reject, resolve));

const x = Promise.resolve('ring');
taskToPromise(promiseToTask(x)) === x;

const y = Task.of('rabbit');
promiseToTask(taskToPromise(y)) === y;
```

Q.E.D. `Promise` and `Task` are *isomorphic*. We can also write a `listToArray` to complement our `arrayToList` and show that they are too. As a counter example, `arrayToMaybe` is not an *isomorphism* since it loses information:

```js
// maybeToArray :: Maybe a -> [a]
const maybeToArray = x => (x.isNothing ? [] : [x.$value]);

// arrayToMaybe :: [a] -> 也许 a
const arrayToMaybe = x => Maybe.of(x[0]);

const x = ['elvis costello', '景点'];

// 不是同构的
也许ToArray(arrayToMaybe(x)); // ['elvis costello']

// but is a natural transformation
compose(arrayToMaybe, map(replace('elvis', 'lou')))(x); // Just('lou costello')
// ==
compose(map(replace('elvis', 'lou')), arrayToMaybe)(x); // Just('lou costello')
```

They are indeed *natural transformations*, however, since `map` on either side yields the same result. I mention *isomorphisms* here, mid-chapter while we're on the subject, but don't let that fool you, they are an enormously powerful and pervasive concept. Anyways, let's move on.

## A Broader Definition

These structural functions aren't limited to type conversions by any means.

Here are a few different ones:

```hs
reverse :: [a] -> [a]

加入 :: (Monad m) => m (m a) -> m a

头 :: [a] -> a

of :: a -> f a
```

The natural transformation laws hold for these functions too. One thing that might trip you up is that `head :: [a] -> a` can be viewed as `head :: [a] -> Identity a`. We are free to insert `Identity` wherever we please whilst proving laws since we can, in turn, prove that `a` is isomorphic to `Identity a` (see, I told you *isomorphisms* were pervasive).

## One Nesting Solution

Back to our comedic type signature. We can sprinkle in some *natural transformations* throughout the calling code to coerce each varying type so they are uniform and, therefore, `join`able.

```js
// getValue :: Selector -> Task Error (Maybe String)
// postComment :: String -> Task Error Comment
// validate :: String -> Either ValidationError String

// saveComment :: () -> Task Error Comment
const saveComment = compose(
  chain(postComment),
  chain(eitherToTask),
  map(validate),
  chain(maybeToTask),
  getValue('#comment'),
);
```

So what do we have here? We've simply added `chain(maybeToTask)` and `chain(eitherToTask)`. Both have the same effect; they naturally transform the functor our `Task` is holding into another `Task` then `join` the two. Like pigeon spikes on a window ledge, we avoid nesting right at the source. As they say in the city of light, "Mieux vaut prévenir que guérir" - an ounce of prevention is worth a pound of cure.

## In Summary

*Natural transformations* are functions on our functors themselves. They are an extremely important concept in category theory and will start to appear everywhere once more abstractions are adopted, but for now, we've scoped them to a few concrete applications. As we saw, we can achieve different effects by converting types with the guarantee that our composition will hold. They can also help us with nested types, although they have the general effect of homogenizing our functors to the lowest common denominator, which in practice, is the functor with the most volatile effects (`Task` in most cases).

This continual and tedious sorting of types is the price we pay for having materialized them - summoned them from the ether. Of course, implicit effects are much more insidious and so here we are fighting the good fight. We'll need a few more tools in our tackle before we can reel in the larger type amalgamations. Next up, we'll look at reordering our types with *Traversable*.

[Chapter 12: Traversing the Stone](ch12.md)


## Exercises

{% exercise %}  
Write a natural transformation that converts `Either b a` to `Maybe a`
  
{% initial src="./exercises/ch11/exercise_a.js#L3;" %}  
```js  
// eitherToMaybe :: Either b a -> Maybe a  
const eitherToMaybe = undefined;  
```  
  
  
{% solution src="./exercises/ch11/solution_a.js" %}  
{% validation src="./exercises/ch11/validation_a.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
  
  
---  


```js
// eitherToTask :: Either a b -> Task a b
const eitherToTask = either(Task.rejected, Task.of);
```

{% exercise %}  
Using `eitherToTask`, simplify `findNameById` to remove the nested `Either`.
  
{% initial src="./exercises/ch11/exercise_b.js#L6;" %}  
```js  
// findNameById :: Number -> Task Error (Either Error User)  
const findNameById = compose(map(map(prop('name'))), findUserById);  
```  
  
  
{% solution src="./exercises/ch11/solution_b.js" %}  
{% validation src="./exercises/ch11/validation_b.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
  
  
---  


提醒一下，在练习的上下文中可以使用以下功能：

```hs
split :: String -> String -> [String]
intercalate :: String -> [String] -> String
```

{% exercise %}  
Write the isomorphisms between String and [Char].
  
{% initial src="./exercises/ch11/exercise_c.js#L8;" %}  
```js  
// strToList :: String -> [Char]  
const strToList = undefined;  
  
// listToStr :: [Char] -> String  
const listToStr = undefined;  
```  
  
  
{% solution src="./exercises/ch11/solution_c.js" %}  
{% validation src="./exercises/ch11/validation_c.js" %}  
{% context src="./exercises/support.js" %}  
{% endexercise %}  
